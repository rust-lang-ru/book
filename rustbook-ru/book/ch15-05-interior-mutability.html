<!DOCTYPE HTML>
<html lang="ru-RU" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RefCell&lt;T&gt; и внутренняя изменяемость - Язык программирования Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Язык программирования Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Предисловие</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Введение</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> С чего начать</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Установка</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Привет, Мир!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Программирование игры в загадки</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Общие концепции программирования</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Переменные и изменяемость</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Виды Данных</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Функции</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Комментарии</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Управляющие конструкции</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Понимание владения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Что такое "владение"?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Ссылки и заимствование</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Вид среза</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Использование структур для объединения связанных данных</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Определение и создание экземпляров структур</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Пример программы, использующей структуры</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Синтаксис способа</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Перечисления и сопоставление с образцом</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Определение Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Конструкция потока управления match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Лаконичный поток управления с if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Управление растущими проектами с помощью пакетов, крейтов и модулей</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Пакеты и крейты</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Определение модулей для управления областью действия и конфиденциальностью</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Пути для ссылки на элемент в дереве модулей</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Введение путей в область видимости с помощью ключевого слова use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Общие собрания</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Хранение списков значений с векторами</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Хранение закодированного текста UTF-8 со строками</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Хранение ключей со связанными значениями в HashMap</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Обработка ошибок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Неустранимые ошибки с panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Устранимые ошибки с Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! или Не panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Общие виды, трейты (характеристики) и время жизни</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Обобщённые виды данных</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Трейты (характеристики): определение разделяемого поведения</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Валидация ссылок посредством сроков жизни</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Написание самостоятельно х тестов</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Как писать тесты</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Управление выполнением тестов</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Организация тестов</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Проект с вводом-выводом: создание программы приказной строки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Получение переменных приказной строки</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Чтение файла</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Рефакторинг для обеспечения модульности и улучшения обработки ошибок</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Разработка функциональности библиотеки с помощью разработки через тестирование</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Работа с переменными среды</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Запись сообщений об ошибках в stderr вместо stdout</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Функциональные возможности языка: повторители и замыкания</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Замыкания: анонимные функции, которые захватывают своё окружение</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Обработка последовательности элементов с помощью повторителей</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Улучшение нашего проекта с вводом/выводом</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Сравнение производительности: циклы и повторители</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Подробнее о Cargo и Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Настройка билдов с помощью профилей выпуска</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Публикация крейта на Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Рабочие области Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Установка двоичных файлов с Crates.io с помощью cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Расширение возможностей Cargo путём добавления пользовательских приказов</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Умные указатели</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Использование Box&lt;T&gt; для указания на данные в куче</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Работа с умными указателями как с обычными ссылками с помощью трейта Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Выполнение кода при очистке с помощью трейта Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, умный указатель с подсчётом ссылок</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html" class="active"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; и внутренняя изменяемость</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Ссылочные циклы могут привести к утечке памяти</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Безбоязненный параллелизм</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Использование потоков для параллельного выполнения кода</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Пересылка сообщений для передачи данных между потоками</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Параллелизм с общим состоянием</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Расширяемый параллелизм с помощью трейтов Sync и Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Возможности объектно-ориентированного программирования Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Характеристики объектно-ориентированных языков</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Использование трейт-объектов, допускающих значения разных видов</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Реализация шаблона объектно-ориентированного проектирования</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Шаблоны и сопоставление</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Все места, где могут использоваться шаблоны</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Опровержимость: может ли шаблон не соответствовать</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Синтаксис шаблона</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Расширенные возможности</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Небезопасный код в Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Продвинутые типажи</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Продвинутые виды</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Продвинутые функции и замыкания</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Макросы</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Финальный проект: создание многопоточного веб-сервера</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Создание однопоточного веб-сервера</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Превращение нашего однопоточного сервера в многопоточный сервер</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 	Мягкое завершение работы и очистка</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Приложения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> А — Ключевые слова</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B — Операторы и символы</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C — Выводимые трейты</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D — Полезные средства разработки</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E — Издания</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F — Переводы книги</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G — Как создаётся Rust и «Nightly Rust»</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Язык программирования Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="refcellt-и-шаблон-внутренней-изменяемости"><a class="header" href="#refcellt-и-шаблон-внутренней-изменяемости"><code>RefCell&lt;T&gt;</code> и шаблон внутренней изменяемости</a></h2>
<p><em>Внутренняя изменяемость</em> - это паттерн проектирования Rust, который позволяет вам изменять данные даже при наличии неизменяемых ссылок на эти данные; обычно такое действие запрещено правилами заимствования. Для изменения данных паттерн использует <code>unsafe</code> код внутри структуры данных, чтобы обойти обычные правила Rust, регулирующие изменяемость и заимствование. Небезопасный (unsafe) код даёт понять сборщику, что мы самостоятельно следим за соблюдением этих правил, а не полагаемся на то, что сборщик будет делать это для нас; подробнее о небезопасном коде мы поговорим в главе 19.</p>
<p>Мы можем использовать виды, в которых применяется паттерн внутренней изменяемости, только если мы можем обеспечить, что правила заимствования будут соблюдаться во время выполнения, несмотря на то, что сборщик не сможет этого обеспечить. В этом случае <code>небезопасный</code> код оборачивается безопасным API, и внешне вид остаётся неизменяемым.</p>
<p>Давайте изучим данную концепцию с помощью вида данных <code>RefCell&lt;T&gt;</code>, который реализует этот шаблон.</p>
<h3 id="Применение-правил-заимствования-во-время-выполнения-с-помощью-refcellt"><a class="header" href="#Применение-правил-заимствования-во-время-выполнения-с-помощью-refcellt">Применение правил заимствования во время выполнения с помощью <code>RefCell&lt;T&gt;</code></a></h3>
<p>В отличие от <code>Rc&lt;T&gt;</code> вид <code>RefCell&lt;T&gt;</code> предоставляет единоличное владение данными, которые он содержит. В чем же отличие вида <code>RefCell&lt;T&gt;</code> от <code>Box&lt;T&gt;</code>? Давайте вспомним правила заимствования из Главы 4:</p>
<ul>
<li>В любой момент времени вы можете иметь <em>либо</em> одну изменяемую ссылку либо сколько угодно неизменяемых ссылок (но не оба вида ссылок одновременно).</li>
<li>Ссылки всегда должны быть действительными.</li>
</ul>
<p>С помощью ссылок и вида <code>Box&lt;T&gt;</code> инварианты правил заимствования применяются на этапе сборки. С помощью <code>RefCell&lt;T&gt;</code> они применяются <em>во время работы программы</em>. Если вы нарушите эти правила, работая с ссылками, то будет ошибка сборки. Если вы работаете с <code>RefCell&lt;T&gt;</code> и нарушите эти правила, то программа вызовет панику и завершится.</p>
<p>Преимущества проверки правил заимствования во время сборки заключаются в том, что ошибки будут обнаруживаться раньше - ещё в процессе разработки, а производительность во время выполнения не пострадает, поскольку весь анализ завершён заранее. По этим причинам проверка правил заимствования во время сборки является лучшим выбором в большинстве случаев, и именно поэтому она используется в Rust по умолчанию.</p>
<p>Преимущество проверки правил заимствования во время выполнения заключается в том, что определённые сценарии, безопасные для памяти, разрешаются там, где они были бы запрещены проверкой во время сборки. Статический анализ, как и сборщик Rust, по своей сути консервативен. Некоторые свойства кода невозможно обнаружить, анализируя код: самый известный пример - проблема остановки, которая выходит за рамки этой книги, но является важной темой для исследования.</p>
<p>Поскольку некоторый анализ невозможен, то если сборщик Rust не может быть уверен, что код соответствует правилам владения, он может отклонить корректную программу; таким образом он является консервативным. Если Rust принял некорректную программу, то пользователи не смогут доверять заверениям, которые даёт Rust. Однако, если Rust отклонит корректную программу, то программист будет испытывать неудобства, но ничего катастрофического не произойдёт. Вид <code>RefCell&lt;T&gt;</code> полезен, когда вы уверены, что ваш код соответствует правилам заимствования, но сборщик не может понять и обеспечить этого.</p>
<p>Подобно виду <code>Rc&lt;T&gt;</code>, вид <code>RefCell&lt;T&gt;</code> предназначен только для использования в однопоточных сценариях и выдаст ошибку времени сборки, если вы попытаетесь использовать его в многопоточном среде. Мы поговорим о том, как получить функциональность <code>RefCell&lt;T&gt;</code> во многопоточной программе в главе 16.</p>
<p>Вот список причин выбора видов <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code> или <code>RefCell&lt;T&gt;</code>:</p>
<ul>
<li>Вид <code>Rc&lt;T&gt;</code> разрешает множественное владение одними и теми же данными; виды <code>Box&lt;T&gt;</code> и <code>RefCell&lt;T&gt;</code> разрешают иметь единственных владельцев.</li>
<li>Вид <code>Box&lt;T&gt;</code> разрешает неизменяемые или изменяемые владения, проверенные при сборки; вид <code>Rc&lt;T&gt;</code> разрешает только неизменяемые владения, проверенные при сборки; вид <code>RefCell&lt;T&gt;</code> разрешает неизменяемые или изменяемые владения, проверенные во время выполнения.</li>
<li>Поскольку <code>RefCell&lt;T&gt;</code> разрешает изменяемые заимствования, проверенные во время выполнения, можно изменять значение внутри <code>RefCell&lt;T&gt;</code> даже если <code>RefCell&lt;T&gt;</code> является неизменным.</li>
</ul>
<p>Изменение значения внутри неизменного значения является шаблоном <em>внутренней изменяемости</em> (interior mutability). Давайте посмотрим на ситуацию, в которой внутренняя изменяемость полезна и рассмотрим, как это возможно.</p>
<h3 id="Внутренняя-изменяемость-изменяемое-заимствование-неизменяемого-значения"><a class="header" href="#Внутренняя-изменяемость-изменяемое-заимствование-неизменяемого-значения">Внутренняя изменяемость: изменяемое заимствование неизменяемого значения</a></h3>
<p>Следствием правил заимствования является то, что когда у вас есть неизменяемое значение, вы не можете заимствовать его с изменением. Например, этот код не будет собираться:</p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch15-smart-pointers/no-listing-01-cant-borrow-immutable-as-mutable/src/main.rs}}</code></pre>
<p>Если вы попытаетесь собрать этот код, вы получите следующую ошибку:</p>
<pre><code class="language-console">{{#include ../listings/ch15-smart-pointers/no-listing-01-cant-borrow-immutable-as-mutable/output.txt}}
</code></pre>
<p>Однако бывают ситуации, в которых было бы полезно, чтобы объект мог изменять себя при помощи своих методов, но казался неизменным для прочего кода. Код вне методов этого объекта не должен иметь возможности изменять его содержимое. Использование <code>RefCell&lt;T&gt;</code> - один из способов получить возможность внутренней изменяемости, но при этом <code>RefCell&lt;T&gt;</code> не позволяет полностью обойти правила заимствования: средство проверки правил заимствования в сборщике позволяет эту внутреннюю изменяемость, однако правила заимствования проверяются во время выполнения. Если вы нарушите правила, то вместо ошибки сборки вы получите <code>panic!</code>.</p>
<p>Давайте разберём практический пример, в котором мы можем использовать <code>RefCell&lt;T&gt;</code> для изменения неизменяемого значения и посмотрим, почему это полезно.</p>
<h4 id="Вариант-использования-внутренней-изменяемости-мок-объекты"><a class="header" href="#Вариант-использования-внутренней-изменяемости-мок-объекты">Вариант использования внутренней изменяемости: мок объекты</a></h4>
<p>Иногда во время тестирования программист использует один вид вместо другого для того, чтобы проверить определённое поведение и убедиться, что оно реализовано правильно. Такой вид-заместитель называется <em>тестовым повторителем</em>. Воспринимайте его как «каскадёра» в кинематографе, когда повторитель заменяет актёра для выполнения определённой сложной сцены. Тестовые повторители заменяют другие виды при выполнении тестов. <em>Инсценировочные (mock) объекты</em> — это особый вид тестовых повторителей, которые сохраняют данные происходящих во время теста действий тем самым позволяя вам убедиться впоследствии, что все действия были выполнены правильно.</p>
<p>В Rust нет объектов в том же смысле, в каком они есть в других языках и в Rust нет функциональности мок объектов, встроенных в стандартную библиотеку, как в некоторых других языках. Однако вы определённо можете создать структуру, которая будет служить тем же целям, что и мок объект.</p>
<p>Вот сценарий, который мы будем тестировать: мы создадим библиотеку, которая отслеживает значение по отношению к заранее определённому максимальному значению и отправляет сообщения в зависимости от того, насколько текущее значение находится близко к такому максимальному значению. Эта библиотека может использоваться, например, для отслеживания квоты количества вызовов API пользователя, которые ему разрешено делать.</p>
<p>Наша библиотека будет предоставлять только функции отслеживания того, насколько близко к максимальному значению находится значение и какие сообщения должны быть внутри в этот момент. Ожидается, что приложения, использующие нашу библиотеку, предоставят механизм для отправки сообщений: приложение может поместить сообщение в приложение, отправить электронное письмо, отправить текстовое сообщение или что-то ещё. Библиотеке не нужно знать эту подробность. Все что ему нужно - это что-то, что реализует типаж, который мы предоставим с названием <code>Messenger</code>. Приложение 15-20 показывает код библиотеки:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-20/src/lib.rs}}</code></pre>
<p><span class="caption">Приложение 15-20: Библиотека для отслеживания степени приближения того или иного значения к максимально допустимой величине и предупреждения, в случае если значение достигает определённого уровня</span></p>
<p>Одна важная часть этого кода состоит в том, что типаж <code>Messenger</code> имеет один способ <code>send</code>, принимающий переменнойми неизменяемую ссылку на <code>self</code> и текст сообщения. Он является внешней оболочкой, который должен иметь наш мок объект. Другой важной частью является то, что мы хотим проверить поведение метода <code>set_value</code> у вида <code>LimitTracker</code>. Мы можем изменить значение, которое передаём свойствоом <code>value</code>, но <code>set_value</code> ничего не возвращает и нет основания, чтобы мы могли бы проверить утверждения о выполнении метода. Мы хотим иметь возможность  сказать, что если мы создаём <code>LimitTracker</code> с чем-то, что реализует типаж <code>Messenger</code> и с определённым значением для <code>max</code>, то когда мы передаём разные числа в переменной <code>value</code> экземпляр self.messenger отправляет соответствующие сообщения.</p>
<p>Нам нужен мок объект, который вместо отправки электронного письма или текстового сообщения будет отслеживать сообщения, которые были ему поручены для отправки через <code>send</code>. Мы можем создать новый экземпляр мок объекта, создать <code>LimitTracker</code> с использованием мок объект для него, вызвать способ <code>set_value</code> у экземпляра <code>LimitTracker</code>, а затем проверить, что мок объект имеет ожидаемое сообщение. В приложении 15-21 показана попытка реализовать мок объект, чтобы сделать именно то что хотим, но анализатор заимствований не разрешит такой код:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-21/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 15-21: Попытка реализовать <code>MockMessenger</code>, которая не была принята механизмом проверки заимствований</span></p>
<p>Этот тестовый код определяет структуру <code>MockMessenger</code>, в которой есть поле <code>sent_messages</code> со значениями вида <code>Vec</code> из <code>String</code> для отслеживания сообщений, которые поручены структуре для отправки. Мы также определяем ассоциированную функцию <code>new</code>, чтобы было удобно создавать новые экземпляры <code>MockMessenger</code>, которые создаются с пустым списком сообщений. Затем мы реализуем типаж <code>Messenger</code> для вида <code>MockMessenger</code>, чтобы передать <code>MockMessenger</code> в <code>LimitTracker</code>. В сигнатуре метода <code>send</code> мы принимаем сообщение для передачи в качестве свойства и сохраняем его в <code>MockMessenger</code> внутри списка <code>sent_messages</code>.</p>
<p>В этом тесте мы проверяем, что происходит, когда <code>LimitTracker</code> сказано установить <code>value</code> в значение, превышающее 75 процентов от значения <code>max</code>. Сначала мы создаём новый <code>MockMessenger</code>, который будет иметь пустой список сообщений. Затем мы создаём новый <code>LimitTracker</code> и передаём ему ссылку на новый <code>MockMessenger</code> и <code>max</code> значение равное 100. Мы вызываем способ <code>set_value</code> у <code>LimitTracker</code> со значением 80, что составляет более 75 процентов от 100. Затем мы с помощью утверждения проверяем, что <code>MockMessenger</code> должен содержать одно сообщение из списка внутренних сообщений.</p>
<p>Однако с этим тестом есть одна проблема, показанная ниже:</p>
<pre><code class="language-console">{{#include ../listings/ch15-smart-pointers/listing-15-21/output.txt}}
</code></pre>
<p>Мы не можем изменять <code>MockMessenger</code> для отслеживания сообщений, потому что способ <code>send</code> принимает неизменяемую ссылку на <code>self</code>. Мы также не можем принять предложение из текста ошибки, чтобы использовать <code>&amp;mut self</code>, потому что тогда сигнатура <code>send</code> не будет соответствовать сигнатуре в определении типажа <code>Messenger</code> (не стесняйтесь попробовать и посмотреть, какое сообщение об ошибке получите вы).</p>
<p>Это ситуация, в которой внутренняя изменяемость может помочь! Мы сохраним <code>sent_messages</code> внутри вида <code>RefCell&lt;T&gt;</code>, а затем в методе <code>send</code> сообщение сможет изменить список <code>sent_messages</code> для хранения сообщений, которые мы видели. Приложение 15-22 показывает, как это выглядит:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-22/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 15-22: Использование <code>RefCell&lt;T&gt;</code> для изменения внутреннего значения, в то время как внешнее значение считается неизменяемым</span></p>
<p>Поле <code>sent_messages</code> теперь имеет вид <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> вместо <code>Vec&lt;String&gt;</code>. В функции <code>new</code> мы создаём новый экземпляр <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> для пустого вектора.</p>
<p>Для реализации метода <code>send</code> первый свойство по-прежнему является неизменяемым для заимствования <code>self</code>, которое соответствует определению типажа. Мы вызываем <code>borrow_mut</code> для <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> в <code>self.sent_messages</code>, чтобы получить изменяемую ссылку на значение внутри <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, которое является вектором. Затем мы можем вызвать <code>push</code> у изменяемой ссылки на вектор, чтобы отслеживать сообщения, отправленные во время теста.</p>
<p>Последнее изменение, которое мы должны сделать, заключается в утверждении для проверки: чтобы увидеть, сколько элементов находится во внутреннем векторе, мы вызываем способ <code>borrow</code> у <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, чтобы получить неизменяемую ссылку на внутренний вектор сообщений.</p>
<p>Теперь, когда вы увидели как использовать <code>RefCell&lt;T&gt;</code>, давайте изучим как он работает!</p>
<h4 id="Отслеживание-заимствований-во-время-выполнения-с-помощью-refcellt"><a class="header" href="#Отслеживание-заимствований-во-время-выполнения-с-помощью-refcellt">Отслеживание заимствований во время выполнения с помощью <code>RefCell&lt;T&gt;</code></a></h4>
<p>При создании неизменных и изменяемых ссылок мы используем синтаксис <code>&amp;</code> и <code>&amp;mut</code> соответственно. У вида <code>RefCell&lt;T&gt;</code>, мы используем методы <code>borrow</code> и <code>borrow_mut</code>, которые являются частью безопасного API, который принадлежит <code>RefCell&lt;T&gt;</code>. Способ <code>borrow</code> возвращает вид умного указателя <code>Ref&lt;T&gt;</code>, способ <code>borrow_mut</code> возвращает вид умного указателя <code>RefMut&lt;T&gt;</code>. Оба вида реализуют типаж <code>Deref</code>, поэтому мы можем рассматривать их как обычные ссылки.</p>
<p>Вид <code>RefCell&lt;T&gt;</code> отслеживает сколько умных указателей <code>Ref&lt;T&gt;</code> и <code>RefMut&lt;T&gt;</code> активны в данное время. Каждый раз, когда мы вызываем <code>borrow</code>, вид <code>RefCell&lt;T&gt;</code> увеличивает количество активных заимствований. Когда значение <code>Ref&lt;T&gt;</code> выходит из области видимости, то количество неизменяемых заимствований уменьшается на единицу. Как и с правилами заимствования во время сборки, <code>RefCell&lt;T&gt;</code> позволяет иметь много неизменяемых заимствований или одно изменяемое заимствование в любой момент времени.</p>
<p>Если попытаться нарушить эти правила, то вместо получения ошибки сборщика, как это было бы со ссылками, реализация <code>RefCell&lt;T&gt;</code> будет вызывать панику во время выполнения. В приложении 15-23 показана модификация реализации <code>send</code> из приложения 15-22. Мы намеренно пытаемся создать два изменяемых заимствования активных для одной и той же области видимости, чтобы показать как <code>RefCell&lt;T&gt;</code> не позволяет нам делать так во время выполнения.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore panics">{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-23/src/lib.rs:here}}</code></pre>
<p><span class="caption">Приложение 15-23: Создание двух изменяемых ссылок в одной области видимости, чтобы убедиться, что <code>RefCell&lt;T&gt;</code> вызовет панику</span></p>
<p>Мы создаём переменную <code>one_borrow</code> для умного указателя <code>RefMut&lt;T&gt;</code> возвращаемого из метода <code>borrow_mut</code>. Затем мы создаём другое изменяемое заимствование таким же образом в переменной <code>two_borrow</code>. Это создаёт две изменяемые ссылки в одной области видимости, что недопустимо. Когда мы запускаем тесты для нашей библиотеки, код в приложении 15-23 собирается без ошибок, но тест завершится неудачно:</p>
<pre><code class="language-console">{{#include ../listings/ch15-smart-pointers/listing-15-23/output.txt}}
</code></pre>
<p>Обратите внимание, что код вызвал панику с сообщением <code>already borrowed: BorrowMutError</code>. Вот так вид <code>RefCell&lt;T&gt;</code> обрабатывает нарушения правил заимствования во время выполнения.</p>
<p>Решение отлавливать ошибки заимствования во время выполнения, а не во время сборки, как мы сделали здесь, означает, что вы потенциально будете находить ошибки в своём коде на более поздних этапах разработки: возможно, не раньше, чем ваш код будет развернут в рабочем окружении. Кроме того, ваш код будет иметь небольшие потери производительности в процессе работы, поскольку заимствования будут отслеживаться во время выполнения, а не во время сборки. Однако использование <code>RefCell&lt;T&gt;</code> позволяет написать объект-имитатор, который способен изменять себя, чтобы сохранять сведения о тех значениях, которые он получал, пока вы использовали его в среде, где разрешены только неизменяемые значения. Вы можете использовать <code>RefCell&lt;T&gt;</code>, несмотря на его недостатки, чтобы получить больше функциональности, чем дают обычные ссылки.</p>
<h3 id="Наличие-нескольких-владельцев-изменяемых-данных-путём-объединения-видов-rct-и-refcellt"><a class="header" href="#Наличие-нескольких-владельцев-изменяемых-данных-путём-объединения-видов-rct-и-refcellt">Наличие нескольких владельцев изменяемых данных путём объединения видов <code>Rc&lt;T&gt;</code> и <code>RefCell&lt;T&gt;</code></a></h3>
<p>Обычный способ использования <code>RefCell&lt;T&gt;</code> заключается в его сочетании с видом <code>Rc&lt;T&gt;</code>. Напомним, что вид <code>Rc&lt;T&gt;</code> позволяет иметь нескольких владельцев некоторых данных, но даёт только неизменяемый доступ к этим данным. Если у вас есть <code>Rc&lt;T&gt;</code>, который внутри содержит вид <code>RefCell&lt;T&gt;</code>, вы можете получить значение, которое может иметь несколько владельцев <em>и</em> которое можно изменять!</p>
<p>Например, вспомните пример cons списка приложения 15-18, где мы использовали <code>Rc&lt;T&gt;</code>, чтобы несколько списков могли совместно владеть другим списком. Поскольку <code>Rc&lt;T&gt;</code> содержит только неизменяемые значения, мы не можем изменить ни одно из значений в списке после того, как мы их создали. Давайте добавим вид <code>RefCell&lt;T&gt;</code>, чтобы получить возможность изменять значения в списках. В приложении 15-24 показано использование <code>RefCell&lt;T&gt;</code> в определении <code>Cons</code> так, что мы можем изменить значение хранящееся во всех списках:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-24/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Приложение 15-24: Использование <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> для создания <code>List</code>, который мы можем изменять</span></p>
<p>Мы создаём значение, которое является экземпляром <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> и сохраняем его в переменной с именем <code>value</code>, чтобы получить к ней прямой доступ позже. Затем мы создаём <code>List</code> в переменной <code>a</code> с вариантом <code>Cons</code>, который содержит <code>value</code>. Нам нужно вызвать клонирование <code>value</code>, так как обе переменные <code>a</code> и <code>value</code> владеют внутренним значением <code>5</code>, а не передают владение из <code>value</code> в переменную <code>a</code> или не выполняют заимствование с помощью <code>a</code> переменной <code>value</code>.</p>
<p>Мы оборачиваем список у переменной <code>a</code> в вид <code>Rc&lt;T&gt;</code>, поэтому при создании списков в переменные <code>b</code> и <code>c</code> они оба могут ссылаться на <code>a</code>, что мы и сделали в приложении 15-18.</p>
<p>После создания списков <code>a</code>, <code>b</code> и <code>c</code> мы хотим добавить 10 к значению в <code>value</code>. Для этого вызовем <code>borrow_mut</code> у <code>value</code>, который использует функцию самостоятельного разыменования, о которой мы говорили в главе 5 (см. раздел <a href="ch05-03-method-syntax.html#wheres-the---operator">"Где находится оператор <code>-&gt;</code>?"</a><!-- ignore -->) во внутреннее значение <code>RefCell&lt;T&gt;</code>. Способ <code>borrow_mut</code> возвращает умный указатель <code>RefMut&lt;T&gt;</code>, и мы используя оператор разыменования, изменяем внутреннее значение.</p>
<p>Когда мы печатаем <code>a</code>, <code>b</code> и <code>c</code> то видим, что все они имеют изменённое значение равное 15, а не 5:</p>
<pre><code class="language-console">{{#include ../listings/ch15-smart-pointers/listing-15-24/output.txt}}
</code></pre>
<p>Эта техника довольно изящна! Используя <code>RefCell&lt;T&gt;</code>, мы получаем внешне неизменяемое значение <code>List</code>. Но мы можем использовать методы <code>RefCell&lt;T&gt;</code>, которые предоставляют доступ к его внутренностям, чтобы мы могли изменять наши данные, когда это необходимо. Проверка правил заимствования во время выполнения защищает нас от гонок данных, и иногда стоит немного пожертвовать производительностью ради такой гибкости наших структур данных. Обратите внимание, что <code>RefCell&lt;T&gt;</code> не работает для многопоточного кода! <code>Mutex&lt;T&gt;</code> - это thread-safe исполнение <code>RefCell&lt;T&gt;</code>, а <code>Mutex&lt;T&gt;</code> мы обсудим в главе 16.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-04-rc.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch15-06-reference-cycles.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-04-rc.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch15-06-reference-cycles.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
