## Вид данных - Cрезы

*Срезы* позволяют ссылаться на непрерывную последовательность переменных в собрании, а не на всё собрание. Срез является своего рода ссылкой, поэтому он не имеет права владения.

Вот небольшая неполадка программирования: напишите способ (функцию), которая принимает строку слов, разделённых пробелами, и возвращает первое слово, которое она находит в этой строке. Если способ (функция) не находит пробела в строке, вся строка должна состоять из одного слова, поэтому должна быть возвращена вся строка.

Давайте рассмотрим, как бы мы написали ярлык этого способа (функции) без использования срезов, чтобы понять неполадку, которую решат срезы:

```rust,ignore
fn первое_слово(s: &String) -> ?
```

Способ (функция) `первое_слово` имеет `&String` в качестве свойства. Мы не хотим владения, так что всё в порядке. Но что мы должны вернуть? На самом деле у нас нет способа говорить о *части* строки. Однако мы могли бы вернуть порядковый указатель конца слова, обозначенного пробелом. Давайте попробуем, как показано в Приложении 4-7.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:here}}
```

<span class="caption">Приложение 4-7: Способ (функция) <code>первое_слово</code>, возвращающая значение порядкового указателя байта в свойство <code>String</code></span>

Поскольку нам нужно просмотреть в `String` каждый знак и проверить, является ли значение пробелом, мы преобразуем нашу `String` в массив байтов с помощью способа `as_bytes`.

```rust,ignore
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:as_bytes}}
```

Далее, мы создаём <em>повторитель </em> по массиву байт используя способ `iter`:

```rust,ignore
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:iter}}
```

Мы обсудим повторители более подробно в [Главе 13]<!-- ignore -->. На данное мгновение знайте, что `iter` — это способ, который возвращает каждая переменная в собрании, а `enumerate` оборачивает итог `iter` и вместо этого возвращает каждая переменная как часть составного ряда. Первая переменная составного ряда, возвращаемый из `enumerate`, является порядковым указателем, а вторая переменная — ссылкой на переменную. Это немного удобнее, чем вычислять порядковый указатель самостоятельно.

Поскольку способ `enumerate` возвращает составной ряд, мы можем использовать образцы для разъединения этого составного ряда. Мы подробнее обсудим образцы в [Главе 6]<!-- ignore -->. В круговороте `for` мы указываем образец, имеющий `i` для порядкового указателя в составном ряде и `&предмет` для одного байта в составном ряде. Поскольку мы получаем ссылку на переменную из `.iter().enumerate()`, мы используем `&` в образце.

Внутри круговорота `for` мы ищем байт, представляющий пробел, используя правила написания байтовой записи. Если мы находим пробел, мы возвращаем положение. В противном случае мы возвращаем длину строки с помощью `s.len()`.

```rust,ignore
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:inside_for}}
```

Теперь у нас есть способ узнать порядковый указатель байта указывающего на конец первого слова в строке, но есть неполадка. Мы возвращаем сам `usize`, но это Число имеет значение только в среде `&String`. Другими словами, поскольку это значение отдельное от `String`, то нет заверения, что оно все ещё будет действительным в будущем. Рассмотрим программу из приложения 4-8, которая использует способ (функцию) `первое_слово` приложения 4-7.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-08/src/main.rs:here}}
```

<span class="caption">Приложение 4-8: Сохранение итога вызова способы (функции) <code>первое_слово</code> и последующего изменения содержимого <code>String</code></span>

Данная приложение собирается без ошибок и будет успешно работать, даже после того как мы воспользуемся переменной `word` после вызова `s.clear()`. Так как значение `word` совсем не связано с состоянием переменной `s`, то `word` сохраняет своё значение `5` без изменений. Мы бы могли воспользоваться значением `5` чтобы получить первое слово из переменной `s`, но это приведёт к ошибке, потому что содержимое `s` изменилось после того как мы сохранили `5` в переменной `word` (стало пустой строкой в вызове `s.clear()`).

Необходимость беспокоиться о том, что порядковый указатель в переменной `word` не согласуется с данными в переменной  `s` является утомительной и подверженной ошибкам! Управление этими порядковыми указателями становится ещё более хрупким, если мы напишем способ (функцию) `второе_слово`. Её ярлык мог бы выглядеть так:

```rust,ignore
fn второе_слово(s: &String) -> (uразмер, usize) {
```

Теперь мы отслеживаем начальный *и* конечный порядковый указатель, и у нас есть ещё больше значений, которые были рассчитаны на основе данных в определённом состоянии, но вообще не привязаны к этому состоянию. У нас есть три несвязанные переменные, которые необходимо согласовать.

К счастью в Ржавчине есть решение данных сбоев: строковые срезы.

### Строковые срезы

Строковый срез - это ссылка на часть строки `String` и он выглядит следующим образом:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-17-slice/src/main.rs:here}}
```

Вместо ссылки на всю `String` `здравствуй` является ссылкой на часть `String`, указанную в дополнительном куске рукописи `[0..5]`. Мы создаём срезы, используя ряд в квадратных скобках, указав `[starting_index..ending_index]`, где `starting_index` — это первое положение, а`ending_index` конечный_порядковый указатель— это на единицу больше, чем последнее положение в срезе. Внутри вида данных среза хранится: начальное положение и длина среза, что соответствует `ending_index` - `starting_index`. Итак, в случае `let мир = &s[6..11];`, `world` будет срезом, содержащим указатель на байт с порядковым указателем 6 `s` со значением длины `5`.

Рисунок 4-6 отображает это на рисунке.

 <img alt="world containing a pointer to the 6th byte of String s and a length 5" src="img/trpl04-06.svg" class="">

<span class="caption">Рисунок 4-6: Строковый срез ссылается на часть <code>String</code></span>

С правилами написания Ржавчины `..`, если вы хотите начать с порядкового указателя 0, вы можете отбросить значение перед двумя точками. Другими словами, они равнозначны:

```rust
let s = String::from("здравствуй");

let срез = &s[0..2];
let срез = &s[..2];
```

Таким же образом, если ваш срез включает последний байт `String`, вы можете отбросить конечный номер. Это означает, что они равнозначны:

```rust
let s = String::from("здравствуй");

let длина = s.len();

let срез = &s[3..длина];
let срез = &s[3..];
```

Вы также можете отбросить оба значения, чтобы получить часть всей строки. Итак, они равнозначны:

```rust
let s = String::from("здравствуй");

let длина = s.len();

let срез = &s[0..длина];
let срез = &s[..];
```

>  Примечание. Порядковые указатели ряда срезов строк должны располагаться в допустимых границах знаков UTF-8. Если вы попытаетесь создать отрывок строки нарушая границы знака, в котором больше одного байта, ваше приложение завершится с ошибкой. В целях введения срезов строк мы предполагаем, что в этом разделе используется только ASCII; более подробное обсуждение обработки UTF-8 находится в разделе [«Сохранение закодированного писания UTF-8 со строками»]<!-- ignore --> раздел Главы 8.
>

Давайте используем полученные сведения и перепишем способ `первое_слово` так, чтобы он возвращал срез. Для обозначения вида данных "срез строки" существует запись `&str`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-18-first-word-slice/src/main.rs:here}}
```

Мы получаем порядковый указатель конца слова так же, как в приложении 4.7, ища первое вхождение пробела. Когда мы находим пробел, мы возвращаем отрывок строки, используя начало строки и порядковый указатель пробела в качестве начального и конечного порядковых указателей.

Теперь, когда мы вызываем `первое_слово`, мы возвращаем одно значение, привязанное к основным данным. Значение состоит из ссылки на начальную точку среза и количества переменных в срезе.

Подобным образом можно переписать и второй способ `второе_слово`:

```rust,ignore
fn второе_слово(s: &String) -> &str {
```

Теперь у нас есть простой API, который гораздо сложнее испортить, потому что сборщик заверяет, что ссылки в `String` останутся действительными. Помните ошибку в программе в приложении 4-8, когда мы получили порядковый указатель до конца первого слова, но затем очистили строку, так что наш порядковый указатель стал недействительным? Эта рукопись была разумно неправильной, но не показывала немедленных ошибок. Неполадки проявятся позже, если мы попытаемся использовать порядковый указатель первого слова с пустой строкой. Срезы делают эту ошибку невозможной и сообщают нам о неполадке с нашей рукописью гораздо раньше. Так, использование исполнения способа `первое_слово` со срезом вернёт ошибку сборки:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-19-slice-error/src/main.rs:here}}
```

Ошибка сборки:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-19-slice-error/output.txt}}
```

Напомним из правил заимствования, что если у нас есть неизменяемая ссылка на что-то, мы не можем также взять изменяемую ссылку. Поскольку для `clear` необходимо обрезать `String`, необходимо получить изменяемую ссылку. `println!` после вызова `clear` использует ссылку в `word`, поэтому неизменяемая ссылка в это мгновение всё ещё должна быть действительной. Ржавчина запрещает одновременное существование изменяемой ссылки в виде`clear` и неизменяемой ссылки в `word`, и сборка завершается ошибкой. Ржавчина не только упростил использование нашего API, но и устранил целое семейство ошибок во время сборки!

<!-- Old heading. Do not remove or links may break. -->

<a id="string-literals-are-slices"></a>

#### Строковые записи - это срезы

Напомним, что мы говорили о строковых записях, хранящихся внутри исполняемого файла. Теперь, когда мы знаем чем являются срезы, мы правильно понимаем что такое строковые записи:

```rust
let s = "Здравствуй мир!";
```

Вид данных `s` здесь `&str`: это срез, указывающий на эту определенную точку исполняемого файла. Вот почему строковые записи неизменяемы; `&str` — неизменяемая ссылка.

#### Строковые срезы как свойства

Знание того, что вы можете брать срезы записей и `String` значений, приводит нас к ещё одному улучшению `первое_слово`, и это его ярлык:

```rust,ignore
fn первое_слово(s: &String) -> &str {
```

Более опытный пользователь Rustacean вместо этого написал бы ярлык, показанный в приложении 4.9, потому что это позволяет нам использовать одну и ту же способ (функцию) как для значений `&String`, так и для значений `&str`.

```rust,ignore
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-09/src/main.rs:here}}
```

<span class="caption">Приложение 4-9: Улучшение способы (функции) <code>первое_слово</code> используя вид данных строкового среза для свойства <code>s</code></span>

Если у нас есть отрывок строки, мы можем передать его напрямую. Если у нас есть `String`, мы можем передать часть `String` или ссылку на `String`. Эта гибкость использует преимущества *приведения deref*, способы (функции), которую мы рассмотрим в [разделе «Неявное приведение Deref со способами (функциями)».]<!-- ignore --> раздел Главы 15.

Определение способы (функции) для получения отрывка строки вместо ссылки на `String` делает наш API более общим и полезным без потери какой-либо возможности:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-09/src/main.rs:usage}}
```

### Другие срезы

Срезы строк, как вы можете себе представить, отличительны для строк. Но есть и более общий вид среза. Рассмотрим этот массив:

```rust
let a = [1, 2, 3, 4, 5];
```

Точно так же, как мы можем захотеть сослаться на часть строки, мы можем захотеть сослаться на часть массива. Мы бы сделали так:

```rust
let a = [1, 2, 3, 4, 5];

let срез = &a[1..3];

assert_eq!(срез, &[2, 3]);
```

Этот срез имеет вид данных `&[i32]`. Он работает так же, как и срезы строк, сохраняя ссылку на первая переменная и его длину. Вы будете использовать этот вид данных отрывка для всех видов данных других собраний. Мы подробно обсудим эти собрания, когда будем говорить о векторах в главе 8.

## Итоги

Подходы владения, заимствования и срезов обеспечивают безопасное управление памятью в приложениех на Ржавчине во время сборки. Язык Ржавчина даёт вам управление над использованием памяти так же, как и другие языки системного программирования, но то, что владелец данных самостоятельно очищает эти данные, когда переменная выходит за рамки, означает, что вам не нужно писать и отлаживать дополнительную рукопись, чтобы получить это управление.

Владение влияет на множество других частей и подходов языка Ржавчина. Мы будем говорить об этих подходах на протяжении оставшихся частей книги. Давайте перейдём к Главе 5 и рассмотрим объединение частей данных в стопки `struct`.


[Главе 13]: ch13-02-iterators.html
[Главе 6]: ch06-02-match.html#patterns-that-bind-to-values
[«Сохранение закодированного писания UTF-8 со строками»]: ch08-02-strings.html#storing-utf-8-encoded-text-with-strings
[разделе «Неявное приведение Deref с способами (функциями) и способами».]: ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods