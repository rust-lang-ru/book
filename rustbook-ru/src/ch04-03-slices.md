## Вид данных - Cрезы

*Срезы* позволяют ссылаться на непрерывную последовательность переменных в собрании, а не на всё собрание. Срез является своего рода ссылкой, поэтому он не имеет права владения.

Вот небольшая неполадка программирования: напишите функцию, которая принимает строку слов, разделённых пробелами, и возвращает первое слово, которое она находит в этой строке. Если функция не находит пробела в строке, вся строка должна состоять из одного слова, поэтому должна быть возвращена вся строка.

Давайте рассмотрим, как бы мы написали ярлык этой функции без использования срезов, чтобы понять неполадку, которую решат срезы:

```rust,ignore
fn first_word(s: &String) -> ?
```

Функция `first_word` имеет `&String` в качестве свойства. Мы не хотим владения, так что всё в порядке. Но что мы должны вернуть? На самом деле у нас нет способа говорить о *части* строки. Однако мы могли бы вернуть порядковый указатель конца слова, обозначенного пробелом. Давайте попробуем, как показано в Приложении 4-7.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:here}}
```

<span class="caption">Приложение 4-7: Функция <code>first_word</code>, возвращающая значение порядкового указателя байта в свойство <code>String</code></span>

Поскольку нам нужно просмотреть в `String` каждый знак и проверить, является ли значение пробелом, мы преобразуем нашу `String` в массив байтов с помощью способа `as_bytes`.

```rust,ignore
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:as_bytes}}
```

Далее, мы создаём <em>повторитель </em> по массиву байт используя способ `iter`:

```rust,ignore
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:iter}}
```

Мы обсудим повторители более подробно в [Главе 13]<!-- ignore -->. На данное мгновение знайте, что `iter` — это способ, который возвращает каждая переменная в собрании, а `enumerate` оборачивает итог `iter` и вместо этого возвращает каждая переменная как часть упорядоченного ряда. Первая переменная упорядоченного ряда, возвращаемый из `enumerate`, является порядковым указателем, а вторая переменная — ссылкой на переменную. Это немного удобнее, чем вычислять порядковый указатель самостоятельно.

Поскольку способ `enumerate` возвращает упорядоченный ряд, мы можем использовать образцы для разъединения этого упорядоченного ряда. Мы подробнее обсудим образцы в [Главе 6]<!-- ignore -->. В круговороте `for` мы указываем образец, имеющий `i` для порядкового указателя в упорядоченном ряде и `&item` для одного байта в упорядоченном ряде. Поскольку мы получаем ссылку на переменную из `.iter().enumerate()`, мы используем `&` в образце.

Внутри круговорота `for` мы ищем байт, представляющий пробел, используя правила написания байтовой записи. Если мы находим пробел, мы возвращаем положение. В противном случае мы возвращаем длину строки с помощью `s.len()`.

```rust,ignore
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:inside_for}}
```

Теперь у нас есть способ узнать порядковый указатель байта указывающего на конец первого слова в строке, но есть неполадка. Мы возвращаем сам `usize`, но это число имеет значение только в среде `&String`. Другими словами, поскольку это значение отдельное от `String`, то нет заверения, что оно все ещё будет действительным в будущем. Рассмотрим программу из приложения 4-8, которая использует функцию `first_word` приложения 4-7.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-08/src/main.rs:here}}
```

<span class="caption">Приложение 4-8: Сохранение итога вызова функции <code>first_word</code> и последующего изменения содержимого <code>String</code></span>

Данная программа собирается без ошибок и будет успешно работать, даже после того как мы воспользуемся переменной `word` после вызова `s.clear()`. Так как значение `word` совсем не связано с состоянием переменной `s`, то `word` сохраняет своё значение `5` без изменений. Мы бы могли воспользоваться значением `5` чтобы получить первое слово из переменной `s`, но это приведёт к ошибке, потому что содержимое `s` изменилось после того как мы сохранили `5` в переменной `word` (стало пустой строкой в вызове `s.clear()`).

Необходимость беспокоиться о том, что порядковый указатель в переменной `word` не согласуется с данными в переменной  `s` является утомительной и подверженной ошибкам! Управление этими порядковыми указателями становится ещё более хрупким, если мы напишем функцию `second_word`. Её ярлык мог бы выглядеть так:

```rust,ignore
fn second_word(s: &String) -> (usize, usize) {
```

Теперь мы отслеживаем начальный *и* конечный порядковый указатель, и у нас есть ещё больше значений, которые были рассчитаны на основе данных в определённом состоянии, но вообще не привязаны к этому состоянию. У нас есть три несвязанные переменные, которые необходимо согласовать.

К счастью в Ржавчине есть решение данных сбоев: строковые срезы.

### Строковые срезы

Строковый срез - это ссылка на часть строки `String` и он выглядит следующим образом:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-17-slice/src/main.rs:here}}
```

Вместо ссылки на всю `String` `hello` является ссылкой на часть `String`, указанную в дополнительном куске рукописи `[0..5]`. Мы создаём срезы, используя ряд в квадратных скобках, указав `[starting_index..ending_index]`, где `starting_index` — это первое положение, а`ending_index` конечный_порядковый указатель— это на единицу больше, чем последнее положение в срезе. Внутри вида данных среза хранится: начальное положение и длина среза, что соответствует `ending_index` - `starting_index`. Итак, в случае `let world = &s[6..11];`, `world` будет срезом, содержащим указатель на байт с порядковым указателем 6 `s` со значением длины `5`.

Рисунок 4-6 отображает это на рисунке.

 <img alt="world containing a pointer to the 6th byte of String s and a length 5" src="img/trpl04-06.svg" class="">

<span class="caption">Рисунок 4-6: Строковый срез ссылается на часть <code>String</code></span>

С правилами написания Ржавчины `..`, если вы хотите начать с порядкового указателя 0, вы можете отбросить значение перед двумя точками. Другими словами, они равнозначны:

```rust
let s = String::from("hello");

let slice = &s[0..2];
let slice = &s[..2];
```

Таким же образом, если ваш срез включает последний байт `String`, вы можете отбросить конечный номер. Это означает, что они равнозначны:

```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];
```

Вы также можете отбросить оба значения, чтобы получить часть всей строки. Итак, они равнозначны:

```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
```

>  Примечание. Порядковые указатели ряда срезов строк должны располагаться в допустимых границах знаков UTF-8. Если вы попытаетесь создать отрывок строки нарушая границы знака, в котором больше одного байта, ваша программа завершится с ошибкой. В целях введения срезов строк мы предполагаем, что в этом разделе используется только ASCII; более подробное обсуждение обработки UTF-8 находится в разделе [«Сохранение закодированного писания UTF-8 со строками»]<!-- ignore --> раздел Главы 8.
>

Давайте используем полученные сведения и перепишем способ `first_word` так, чтобы он возвращал срез. Для обозначения вида данных "срез строки" существует запись `&str`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-18-first-word-slice/src/main.rs:here}}
```

Мы получаем порядковый указатель конца слова так же, как в приложении 4.7, ища первое вхождение пробела. Когда мы находим пробел, мы возвращаем отрывок строки, используя начало строки и порядковый указатель пробела в качестве начального и конечного порядковых указателей.

Теперь, когда мы вызываем `first_word`, мы возвращаем одно значение, привязанное к основным данным. Значение состоит из ссылки на начальную точку среза и количества переменных в срезе.

Подобным образом можно переписать и второй способ `second_word`:

```rust,ignore
fn second_word(s: &String) -> &str {
```

Теперь у нас есть простой API, который гораздо сложнее испортить, потому что сборщик заверяет, что ссылки в `String` останутся действительными. Помните ошибку в программе в приложении 4-8, когда мы получили порядковый указатель до конца первого слова, но затем очистили строку, так что наш порядковый указатель стал недействительным? Эта рукопись была разумно неправильной, но не показывала немедленных ошибок. Неполадки проявятся позже, если мы попытаемся использовать порядковый указатель первого слова с пустой строкой. Срезы делают эту ошибку невозможной и сообщают нам о неполадке с нашей рукописью гораздо раньше. Так, использование исполнения способа `first_word` со срезом вернёт ошибку сборки:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-19-slice-error/src/main.rs:here}}
```

Ошибка сборки:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-19-slice-error/output.txt}}
```

Напомним из правил заимствования, что если у нас есть неизменяемая ссылка на что-то, мы не можем также взять изменяемую ссылку. Поскольку для `clear` необходимо обрезать `String`, необходимо получить изменяемую ссылку. `println!` после вызова `clear` использует ссылку в `word`, поэтому неизменяемая ссылка в это мгновение всё ещё должна быть действительной. Ржавчина запрещает одновременное существование изменяемой ссылки в виде`clear` и неизменяемой ссылки в `word`, и сборка завершается ошибкой. Ржавчина не только упростил использование нашего API, но и устранил целое семейство ошибок во время сборки!

<!-- Old heading. Do not remove or links may break. -->

<a id="string-literals-are-slices"></a>

#### Строковые записи - это срезы

Напомним, что мы говорили о строковых записях, хранящихся внутри двоичного файла. Теперь, когда мы знаем чем являются срезы, мы правильно понимаем что такое строковые записи:

```rust
let s = "Hello, world!";
```

Вид данных `s` здесь `&str`: это срез, указывающий на эту определенную точку двоичного файла. Вот почему строковые записи неизменяемы; `&str` — неизменяемая ссылка.

#### Строковые срезы как свойства

Знание того, что вы можете брать срезы записей и `String` значений, приводит нас к ещё одному улучшению `first_word`, и это его ярлык:

```rust,ignore
fn first_word(s: &String) -> &str {
```

Более опытный пользователь Rustacean вместо этого написал бы ярлык, показанный в приложении 4.9, потому что это позволяет нам использовать одну и ту же функцию как для значений `&String`, так и для значений `&str`.

```rust,ignore
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-09/src/main.rs:here}}
```

<span class="caption">Приложение 4-9: Улучшение функции <code>first_word</code> используя вид данных строкового среза для свойства <code>s</code></span>

Если у нас есть отрывок строки, мы можем передать его напрямую. Если у нас есть `String`, мы можем передать часть `String` или ссылку на `String`. Эта гибкость использует преимущества *приведения deref*, функции, которую мы рассмотрим в [разделе «Неявное приведение Deref с функциями и способами».]<!-- ignore --> раздел Главы 15.

Определение функции для получения отрывка строки вместо ссылки на `String` делает наш API более общим и полезным без потери какой-либо возможности:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-09/src/main.rs:usage}}
```

### Другие срезы

Срезы строк, как вы можете себе представить, отличительны для строк. Но есть и более общий вид среза. Рассмотрим этот массив:

```rust
let a = [1, 2, 3, 4, 5];
```

Точно так же, как мы можем захотеть сослаться на часть строки, мы можем захотеть сослаться на часть массива. Мы бы сделали так:

```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];

assert_eq!(slice, &[2, 3]);
```

Этот срез имеет вид данных `&[i32]`. Он работает так же, как и срезы строк, сохраняя ссылку на первая переменная и его длину. Вы будете использовать этот вид данных отрывка для всех видов данных других собраний. Мы подробно обсудим эти собрания, когда будем говорить о векторах в главе 8.

## Итоги

Подходы владения, заимствования и срезов обеспечивают безопасное управлению памятью в программах на Ржавчине во время сборки. Язык Ржавчина даёт вам управление над использованием памяти так же, как и другие языки системного программирования, но то, что владелец данных самостоятельно очищает эти данные, когда переменная выходит за рамки, означает, что вам не нужно писать и отлаживать дополнительную рукопись, чтобы получить это управление.

Владение влияет на множество других частей и подходов языка Ржавчина. Мы будем говорить об этих подходах на протяжении оставшихся частей книги. Давайте перейдём к Главе 5 и рассмотрим объединение частей данных в стопки `struct`.


[Главе 13]: ch13-02-iterators.html
[Главе 6]: ch06-02-match.html#patterns-that-bind-to-values
[«Сохранение закодированного писания UTF-8 со строками»]: ch08-02-strings.html#storing-utf-8-encoded-text-with-strings
[разделе «Неявное приведение Deref с функциями и способами».]: ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods