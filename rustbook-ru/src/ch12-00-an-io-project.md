# ящик с вводом/выводом (I/O): создание приложения с окном вывода

В этой главе вы примените многие знания, полученные ранее, а также познакомитесь с ещё неизученными API встроенной библиотеки. Мы создадим  приложение с окном вывода, которое будет взаимодействовать с файлом, обращениями с окном ввода / вывода, мы применим ряд подходов Ржавчины, с которыми вы уже знакомы.

Скорость, безопасность, сборка в один исполняемый файл и возможность сборки на разных устройствах и ОС делают Ржавчину наилучшим языком для создания исполняемых приложений с окнами ввода/вывода, мы создадим свое собственное исполняемое приложение в виде обычной утилиты поиска `grep`, что расшифровывается, как "вездесущеее средство поиска и вывода" (**g**lobally search a **r**egular **e**xpression and **p**rint). В простейшем случае `grep` используется для поиска в выбранном файле указанного содержимого. Для этого утилита `grep` получает путь до файла и содержимое в виде строки/строк в качестве переменных. Далее она считывает файл, находит и выводит строки, содержащие искомые.

Попутно мы покажем, как сделать так, чтобы наше приложение с окном вывода использовало возможности окна вызова, которые используются многими другими средствами с окнами ввода/вывода. Мы будем считывать значение переменной окружения, чтобы позволить пользователю настроить поведение нашего средства. Мы также будем выводить сообщения об ошибках в обычный поток ошибок ( `stderr` ) вместо принятого вывода ( `stdout` ), чтобы, к примеру, пользователь мог перенаправить успешный вывод в файл, в то время, как сообщения об ошибках останутся на экране.

Один из участников Ржавчины-сообщества, Andrew Gallant, уже создал полновозможное, очень быстрое подобие приложения `grep` и назвал его `ripgrep`. По сравнению с ним, наше исполнение будет довольно простым, но эта глава даст вам знания, которые нужны для понимания существующих исполняемых приложений, таких как <code>ripgrep</code>.

Наше исполняемое приложение  `grep` будет использовать ранее изученные подходы:

- Создание рукописи (используя то, что вы узнали о разделах в [ главе 7]<!--  -->)
- Использование векторов и строк (собрания, [глава 8]<!--  -->)
- Обработка ошибок ([Глава 9]<!--  -->)
- Использование сущностей и времени жизни там, где это необходимо ([глава 10]<!--  -->)
- Написание проверок ( [Глава 11]<!--  -->)

Мы также кратко представим замыкания, повторители и предметы сущности, которые будут объяснены подробно в главах [13]<!--  --> и [18]<!--  -->.


[ главе 7]: ch07-00-managing-growing-projects-with-packages-crates-and-modules.html
[глава 8]: ch08-00-common-collections.html
[Глава 9]: ch09-00-error-handling.html
[глава 10]: ch10-00-generics.html
[Глава 11]: ch11-00-testing.html
[13]: ch13-00-functional-features.html
[18]: ch18-00-oop.html