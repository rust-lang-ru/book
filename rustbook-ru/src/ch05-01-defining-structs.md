## Определение и объявление стопок

Стопки похожи на упорядоченные ряды, рассмотренные в разделе ["Упорядоченные ряды"]<!-- ignore -->, так как оба хранят несколько связанных значений. Как и упорядоченные ряды, части стопок могут быть разных видов данных. В отличие от упорядоченных рядов, в стопке необходимо именовать каждую часть данных для понимания смысла значений. Добавление этих имён обеспечивает большую гибкость стопок по сравнению с упорядоченнымм рядами: не нужно полагаться на порядок данных для указания значений образца данных или доступа к ним.

Для определения стопки указывается ключевое слово `struct` и её название. Название должно описывать значение частей данных, объединенных вместе. Далее, в узорчатых скобках для каждой новой части данных поочерёдно определяются имя части данных и её вид данных. Каждая пара <code>имя: вид данных</code> называется *полем*. Приложение 5-1 описывает стопку для хранения сведений об учётной записи пользователя:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-01/src/main.rs:here}}
```

<span class="caption">Приложение 5-1: Определение стопки <code>User</code></span>

После определения стопки можно создавать её *образец*, назначая определённое значение каждому полю с соответствующим видом данных. Чтобы создать образец данных, мы указываем имя стопки, затем добавляем узорчатые скобки и включаем в них пары `ключ: значение` (key: value), где ключами являются имена полей, а значениями являются данные, которые мы хотим сохранить в полях. Нет необходимости чётко следовать порядку объявления полей в описании стопки (но всё-таки желательно для удобства чтения). Другими словами, объявление стопки - это как образец данных нашего вида данных, в то время как образец данных стопки использует этот образец данных, заполняя его определёнными данными, для создания значений нашего вида данных. Например, можно объявить пользователя как в приложении 5-2:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-02/src/main.rs:here}}
```

<span class="caption">Приложение 5-2: Создание образца данных стопки <code>User</code></span>

Чтобы получить определенное значение из стопки, мы используем запись через точку. Например, чтобы получить доступ к адресу электронной почты этого пользователя, мы используем `user1.email`. Если образец данных является изменяемым, мы можем поменять значение, используя точечное наставление и присвоение к определенному полю. В Приложении 5-3 показано, как изменить значение в поле `email` изменяемого образца данных `User`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-03/src/main.rs:here}}
```

<span class="caption">Приложение 5-3: Изменение значения в поле <code>email</code> образца данных <code>User</code></span>

Стоит отметить, что весь образец данных стопки должен быть изменяемым; Ржавчина не позволяет помечать изменяемыми отдельные поля. Как и для любого другого выражения, мы можем использовать выражение создания стопки в качестве последнего выражения тела функции для неявного возврата нового образца.

На приложении 5-4 функция `build_user` возвращает образец данных `User` с указанным адресом и именем. Поле `active` получает значение `true`, а поле `sign_in_count` получает значение `1`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-04/src/main.rs:here}}
```

<span class="caption">Приложение 5-4: Функция <code>build_user</code>, которая принимает email и имя пользователя и возвращает образец данных <code>User</code></span>

Имеет смысл называть свойства функции теми же именами, что и поля стопки, но необходимость повторять `email` и `username` для названий полей и переменных несколько утомительна. Если стопка имеет много полей,  повторение каждого имени станет ещё более раздражающим. К счастью, есть удобное сокращение!

<!-- Old heading. Do not remove or links may break. -->

<a id="using-the-field-init-shorthand-when-variables-and-fields-have-the-same-name"></a>

### Использование сокращённого объявления поля

Так как имена входных свойств функции и полей стопки одинаковые в приложении 5-4, возможно использовать согласно правил написания *сокращённое объявление поля*, чтобы переписать `build_user` так, чтобы он работал точно также, но не содержал повторений для `username` и `email`, как в приложении 5-5.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-05/src/main.rs:here}}
```

<span class="caption">Приложение 5-5: Функция <code>build_user</code> использует сокращённое объявление полей, потому что её входные свойства <code>username</code> и <code>email</code> имеют одинаковые имена полей стопки</span>

Здесь происходит создание нового образца данных стопки `User`, которая имеет поле с именем `email`. Мы хотим установить поле стопки `email` значением входного свойства `email` функции `build_user`. Так как поле `email` и входное свойство функции `email` имеют одинаковое название, можно писать просто `email` вместо рукописи `email: email`.

### Создание образца данных стопки из образца данных другой стопки с помощью правил написания обновления стопки

Часто бывает полезно создать новый образец данных стопки, который включает большинство значений из другого образца, но некоторые из них изменяет. Это можно сделать с помощью *правил написания обновления стопки*.

Сначала в приложении 5-6 показано, как обычно создаётся новый образец данных `User` в `user2` без правил написания обновления. Мы задаём новое значение для `email`, но в остальном используем те же значения из `user1`, которые были заданы в приложении 5-2.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-06/src/main.rs:here}}
```

<span class="caption">Приложение 5-6: Создание нового образца данных <code>User</code> с использованием некоторых значений из образца данных <code>user1</code></span>

Используя правила написания обновления стопки, можно получить тот же итог, используя меньше рукописи как показано в приложении 5-7. Правила написания `..` указывают, что оставшиеся поля устанавливаются неявно и должны иметь значения из указанного образца данных.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-07/src/main.rs:here}}
```

<span class="caption">Приложение 5-7: Использование правил написания обновления стопки для установки нового значения <code>email</code> для образца данных <code>User</code>, но использование остальных значений из образца данных <code>user1</code></span>

Рукопись в приложении 5-7 также создаёт образец данных в `user2`, который имеет другое значение для `email`, но с тем же значением для полей `username`, `active` и `sign_in_count` из `user1`. Приказчик `..user1` должен стоять последним для указания на получение значений всех оставшихся полей из соответствующих полей в `user1`, но можно указать значения для любого количества полей в любом порядке, независимо от порядка полей в определении стопки.

Стоит отметить, что правила написания обновления стопки используют  знак равенства `=` как присваивание. Это связано с перемещением данных, как мы видели в разделе [«Взаимодействие переменных и данных с помощью перемещения»]<!-- ignore -->. В этом примере мы больше не можем использовать `user1` после создания `user2`, потому что `String` в поле `username` из `user1` было перемещено в `user2`. Если бы мы задали `user2` новые значения `String` для `email` и `username`, и таким образом, использовали только значения `active` и `sign_in_count` из `user1`, то `user1` всё ещё был бы действительным после создания `user2`. Оба вида  данных `active` и `sign_in_count` используют сущность `Copy`, поэтому они ведут себя так, как мы обсуждали в разделе [«Данные из обоймы: повторение»]<!-- ignore -->.

### Упорядоченные в ряд стопки: стопки без именованных полей для создания разных видов данных

Ржавчина также поддерживает стопки, похожие на упорядоченные ряды, которые называются *упорядоченные в ряд стопки*. Упорядоченные в ряд стопки обладают дополнительным смыслом, который даёт имя стопки, но при этом не имеют имён, связанных с их полями. Скорее, они просто хранят виды данных полей. Упорядоченные в ряд стопки полезны, когда вы хотите дать имя всему упорядоченному ряду и сделать упорядоченный ряд отличным от других упорядоченных рядов, и когда именование каждого поля, как в обычной стопке, было бы многословным или избыточным.

Чтобы определить упорядоченную в ряд стопку, начните с ключевого слова `struct` и имени стопки, за которым следуют виды данных в упорядоченном ряде. Например, здесь мы определяем и используем две упорядоченные в ряд стопки с именами `Color` и `Point`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/no-listing-01-tuple-structs/src/main.rs}}
```

Обратите внимание, что значения `black` и `origin` — это разные виды данных, потому что они являются образцами данных разных упорядоченных в ряд стопок. Каждая определяемая вами стопка имеет собственный вид данных, даже если поля внутри стопки могут быть одинаковые виды данных. Например, функция, принимающая свойство вида данных `Color`, не может принимать `Point` в качестве переменной, даже если оба вида данных состоят из трёх значений `i32`. В остальном образцы упорядоченных в ряд стопок похожи на упорядоченные ряды в том смысле, что вы можете разъединять их на отдельные части и использовать `.`, за которой следует порядковый указатель для доступа к отдельному значению.

### Единично-подобные стопки: стопки без полей

Также можно определять стопки, не имеющие полей! Они называются *единично-подобными стопками*, поскольку ведут себя подобно `()`, единичному виду данных, о котором мы говорили в разделе ["Упорядоченные ряды"](ch03-02-data-types.html#the-tuple-type)<!-- ignore -->. Единично-подобные стопки могут быть полезны, когда требуется использовать сущность для некоторого вида данных, но у вас нет данных, которые нужно хранить в самом виде данных. Мы обсудим сущности в главе 10. Вот пример объявления и создание образца данных единичной стопки с именем `AlwaysEqual`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/no-listing-04-unit-like-structs/src/main.rs}}
```

Чтобы определить `AlwaysEqual`, мы используем ключевое слово `struct`, желаемое имя, а затем точку с запятой. Нет необходимости в узорчатых или круглых скобках! Затем мы можем получить образец данных `AlwaysEqual` в переменной `subject` подобным образом: используя имя, которое мы определили, без узорчатых и круглых скобок. Представим, что в дальнейшем мы выполняем поведение для этого вида данных таким образом, что каждый образец данных `AlwaysEqual` всегда будет равен каждому образцу любого другого вида данных, возможно, с целью получения ожидаемого итога для проверки. Для выполнения такого поведения нам не нужны никакие данные! В главе 10 вы увидите, как определять сущности и использовать их для любого вида данных, включая единично-подобные стопки.

> ### Владение данными стопки
>
> В определении стопки `User` в приложении 5-1 мы использовали владеющий вид данных `String` вместо вида данных строковый срез `&str`. Это осознанный выбор, поскольку мы хотим, чтобы каждый образец данных этого стопки владел всеми своими данными и чтобы эти данные были действительны до тех пор, пока действительны все стопки.
>
> Стопки также могут хранить ссылки на данные, принадлежащие кому-то другому, но для этого необходимо использовать возможность Ржавчины *время жизни*, которую мы обсудим в главе 10. Время жизни заверяет, что данные, на которые ссылается стопки, будут действительны до тех пор, пока существует стопки. Допустим, если попытаться сохранить ссылку в стопке без указания времени жизни, как в следующем примере; это не сработает:
>
> <span class="filename">Файл: src/main.rs</span>
>
> <!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
>
> ```rust,ignore,does_not_compile
> struct User {
>     active: bool,
>     username: &str,
>     email: &str,
>     sign_in_count: u64,
> }
>
> fn main() {
>     let user1 = User {
>         active: true,
>         username: "someusername123",
>         email: "someone@example.com",
>         sign_in_count: 1,
>     };
> }
> ```
>
> Сборщик будет жаловаться на необходимость определения времени жизни ссылок:
>
> ```console
> $ cargo run
>    Compiling structs v0.1.0 (file:///projects/structs)
> error[E0106]: missing lifetime specifier
>  --> src/main.rs:3:15
>   |
> 3 |     username: &str,
>   |               ^ expected named lifetime parameter
>   |
> help: consider introducing a named lifetime parameter
>   |
> 1 ~ struct User<'a> {
> 2 |     active: bool,
> 3 ~     username: &'a str,
>   |
>
> error[E0106]: missing lifetime specifier
>  --> src/main.rs:4:12
>   |
> 4 |     email: &str,
>   |            ^ expected named lifetime parameter
>   |
> help: consider introducing a named lifetime parameter
>   |
> 1 ~ struct User<'a> {
> 2 |     active: bool,
> 3 |     username: &str,
> 4 ~     email: &'a str,
>   |
>
> For more information about this error, try `rustc --explain E0106`.
> error: could not compile `structs` due to 2 previous errors
> ```
>
> В главе 10 мы обсудим, как исправить эти ошибки, чтобы иметь возможность хранить ссылки в стопках, а пока мы исправим подобные ошибки, используя владеющие виды данных вроде `String` вместо ссылок `&str`.

<!-- manual-regeneration
for the error above
after running update-rustc.sh:
pbcopy < listings/ch05-using-structs-to-structure-related-data/no-listing-02-reference-in-struct/output.txt
paste above
add `> ` before every line -->


["Упорядоченные ряды"]: ch03-02-data-types.html#the-tuple-type
[«Взаимодействие переменных и данных с помощью перемещения»]: ch04-01-what-is-ownership.html#variables-and-data-interacting-with-move
[«Данные из обоймы: повторение»]: ch04-01-what-is-ownership.html#stack-only-data-copy