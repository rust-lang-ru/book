## Продвинутые сущности

Мы познакомились с сущностями в разделе ["Сущности: Определение общего поведения"](ch10-02-traits.html#traits-defining-shared-behavior)<!-- ignore --> в главе 10, но там мы не обсуждали более сложные подробности. Теперь, когда вы больше знаете о Ржавчина мы можем перейти к более подробному рассмотрению.

### Указание видов-исполнителей в определениях сущностей с сопряженными видами данных

*Сопряженные виды* связывают вид-исполнитель с сущностью таким образом, что определения способов сущности могут использовать эти виды-исполнители в своих ярлыках. Для именно выполнения сущности вместо вида-исполнителя указывается определенный вид, который будет использоваться. Таким образом, мы можем определить сущности, использующие некоторые виды, без необходимости точно знать, что это за виды, пока сущности не будут выполнены.

Мы назвали большинство продвинутых возможностей в этой главе редко востребованными. Сопряженные виды находятся где-то посередине: они используются реже чем возможности описанные в остальной части книги, но чаще чем многие другие возможности обсуждаемые в этой главе.

Одним из примеров сущности с сопряженным видом является сущность `Iterator` из встроенной библиотеки. Сопряженный вид называется `Item` и представляет вид значений, по которым повторяется вид, используюющий сущность `Iterator`. Определение сущности <code>Iterator</code> показано в приложении 19-12.

```rust,noplayground
{{#rustdoc_include ../listings/ch20-advanced-features/listing-19-12/src/lib.rs}}
```

<span class="caption">Приложение 19-12: Определение сущности <code>Iterator</code>, который имеет сопряженный вид <code>Item</code></span>

Вид данных `Item` является исполнителем и определение способа `next` показывает, что он будет возвращать значения вида данных `Option<Self::Item>`. Разработчики сущности `Iterator` определят определенный вид для `Item`, а способ `next` вернёт `Option` содержащий значение этого определенного вида данных.

Сопряженные виды могут показаться подходом похожей на обобщения, поскольку последние позволяют нам определять функцию, не указывая, какие виды она может обрабатывать. Чтобы изучить разницу между этими двумя подходами, мы рассмотрим использование сущности `Iterator` для вида данных с именем `Счётчик`, который указывает, что вид данных `Item` равен `u32`:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-22-iterator-on-counter/src/lib.rs:ch19}}
```

Эти правила написания весьма напоминает обобщённые виды. Так почему же сущность `Iterator` не определена обобщённым видом, как показано в приложении 19-13?

```rust,noplayground
{{#rustdoc_include ../listings/ch20-advanced-features/listing-19-13/src/lib.rs}}
```

<span class="caption">Приложение 19-13: Гипотетическое определение сущности <code>Iterator</code> используя обобщённые виды</span>

Разница в том, что при использовании обобщений, как показано в приложении 19-13, мы должны определять виды в каждой выполнения; потому что мы также можем использовать `Iterator<String> for Счётчик` или любого другого вида данных, мы могли бы иметь несколько выполнения `Iterator` для `Счётчик`. Другими словами, когда сущность имеет Обобщённое свойство, он может быть выполнен для вида данных несколько раз, каждый раз меняя определенные виды свойств обобщённого вида данных. Когда мы используем способ `next` у `Счётчик`, нам пришлось бы предоставить изложении вида данных, указывая какую использование `Iterator` мы хотим использовать.

С сопряженными видами данных не нужно определять виды, потому что мы не можем использовать сущность у вида данных несколько раз. В приложении 19-12 с определением, использующим сопряженные виды можно выбрать только один вид данных `Item`, потому что может быть только одно объявление `impl Iterator for Счётчик`. Нам не нужно указывать, что нужен повторитель значений вида данных `u32` везде, где мы вызываем `next` у `Счётчик`.

Сопряженные виды также становятся частью договора сущности: разработчики сущности должны предоставить вид, который заменит сопряженный исполнитель вида данных. Связанные виды часто имеют имя, описывающее то, как будет использоваться вид, и хорошим опытом является документирование связанного вида данных в пособии по API.

### Свойства обобщённого вида данных по умолчанию и перегрузка приказчиков

Когда мы используем свойства обобщённого вида данных, мы можем указать определенный вид по умолчанию для обобщённого вида данных. Это устраняет необходимость разработчикам указывать определенный вид, если работает вид по умолчанию. Вид по умолчанию указывается при объявлении обобщённого вида данных с помощью правил написания  `<PlaceholderType=ConcreteType>`.

Отличным примером, когда этот способ полезен, является *перегрузка приказчика* (operator overloading), когда вы настраиваете поведение приказчика (например, `+` ) для определённых случаев.

Ржавчина не позволяет создавать собственные приказчики или перегружать произвольные приказчики. Но можно перегрузить перечисленные действия и соответствующие им сущности из `std::ops` путём выполнения сущностей, связанных с этими приказчиками. Например, в приложении 19-14 мы перегружаем приказчик `+`, чтобы складывать два образца данных `Point`. Мы делаем это используя сущность `Add` для стопки `Point`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-19-14/src/main.rs}}
```

<span class="caption">Приложение 19-14: Использование сущности <code>Add</code> для перегрузки приказчика <code>+</code> для образцов <code>Point</code></span>

Способ `add` складывает значения `x` двух образцов `Point` и значения `y` у `Point` для создания нового образца данных `Point`. Сущность `Add` имеет сопряженный вид с именем `Output`, который определяет вид, возвращаемый из способа `add`.

Обобщённый вид по умолчанию в этой рукописи находится в сущности `Add` . Вот его определение:

```rust
trait Add<Rhs = Self> {
    type Output;

    fn add(self, rhs: Rhs) -> Self::Output;
}
```

Эта рукопись должна выглядеть знакомой: сущность с одним способом и сопряженным видом. Новые правила написания это `RHS=Self`. Такие правила написания называются *свойства вида данных по умолчанию* (default type parameters). Свойство обобщённого вида данных `RHS` (сокращённо “right hand side”) определяет вид свойства `rhs` в способе `add`. Если мы не укажем определенный вид для `RHS` при выполнения сущности `Add`, то видом для `RHS` по умолчанию будет `Self`, который будет видом для которого используется сущность `Add`.

Когда мы выполнили `Add` для стопки `Point`, мы использовали обычное значение для `RHS`, потому что хотели сложить два образца данных `Point`. Давайте посмотрим на пример выполнения сущности `Add`, где мы хотим пользовательский вид данных `RHS` вместо использования вида данных по умолчанию.

У нас есть две разные стопки `Millimeters` и `Meters`, хранящие значения в разных единицах измерения. Это тонкое обёртывание существующего вида данных в другой вид данных, известный как образец данных *newtype*, который мы более подробно опишем в разделе ["Образец данных Newtype для выполнение внешних сущностей у внешних видов данных"]<!-- ignore --> . Мы хотим добавить значения в миллиметрах к значениям в метрах и хотим иметь использование сущности `Add`, которая делает правильное преобразование единиц. Можно использовать <code>Add</code> для <code>Millimeters</code> с видом <code>Meters</code> в качестве `Rhs`, как показано в приложении 19-15.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch20-advanced-features/listing-19-15/src/lib.rs}}
```

<span class="caption">Приложение 19-15: Использование сущности <code>Add</code> для стопки  <code>Millimeters</code>, чтобы складывать <code>Millimeters</code> и <code>Meters</code></span>

Чтобы сложить `Millimeters` и `Meters`, мы указываем `impl Add<Meters>`, чтобы указать значение свойства вида данных `RHS` (Meters) вместо использования значения по умолчанию `Self` (Millimeters).

Свойства вида данных по умолчанию используются в двух основных случаях:

- Чтобы расширить вид без внесения изменений ломающих существующую рукопись
- Чтобы позволить пользовательское поведение в особых случаях, которые не нужны большинству пользователей

Сущность `Add` из встроенной библиотеки является примером второй цели: обычно вы складываете два одинаковых вида данных, но сущность `Add` позволяет сделать больше. Использование свойства вида данных по умолчанию в объявлении сущности `Add` означает, что не нужно указывать дополнительное свойство большую часть времени. Другими словами, большая часть рукописи выполнения не нужна, что делает использование сущности проще.

Первая цель похожа на вторую, но используется наоборот: если вы хотите добавить свойство вида данных к существующему сущности, можно дать ему значение по умолчанию, чтобы разрешить расширение возможности сущности без нарушения рукописи существующей выполнения.

### Полностью квалифицированный правила написания для устранения неоднозначности: вызов способов с одинаковым именем

В Ржавчине ничего не мешает сущности иметь способ с одинаковым именем, таким же как способ другого сущности и Ржавчина не мешает использовать оба таких сущности у одного вида данных. Также возможно использовать способ с таким же именем непосредственно у вида данных, такой как и способы у сущностей.

При вызове способов с одинаковыми именами в Ржавчине нужно указать, какой из трёх возможных вы хотите использовать. Рассмотрим рукопись в приложении 19-16, где мы определили два сущности: `Pilot` и `Wizard`, у обоих есть способ `fly`. Затем мы используем обе сущности у вида данных `Human` в котором уже выполнен способ с именем `fly`. Каждый способ `fly` делает что-то своё.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-19-16/src/main.rs:here}}
```

<span class="caption">Приложение 19-16: Два сущности определены со способом <code>fly</code> и выполнены у вида данных <code>Human</code>, а также способ <code>fly</code> выполнен непосредственно у <code>Human</code></span>

Когда мы вызываем `fly` у образца данных `Human`, то сборщик по умолчанию вызывает способ, который непосредственно выполнен для вида данных, как показано в приложении 19-17.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-19-17/src/main.rs:here}}
```

<span class="caption">Приложение 19-17: Вызов <code>fly</code> у образца данных <code>Human</code></span>

Запуск этой рукописи выведет `*waving arms furiously*` , показывая, что Ржавчина называется способ `fly` выполненный непосредственно у `Human`.

Чтобы вызвать способы `fly` у сущности `Pilot` или сущности `Wizard` нужно использовать более явные правила написания, указывая какой способ `fly` мы имеем в виду. Приложение 19-18 отображает такие правила написания.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-19-18/src/main.rs:here}}
```

<span class="caption">Приложение 19-18: Указание какой способа <code>fly</code> мы хотим вызвать</span>

Указание имени сущности перед именем способа проясняет сборщику Ржавчина, какую именно использование `fly` мы хотим вызвать. Мы могли бы также написать `Human::fly(&person)`, что равнозначно используемому нами `person.fly()` в приложении 19-18, но это писание немного длиннее, когда нужна неоднозначность.

Итог выполнения рукописи:

```console
{{#include ../listings/ch20-advanced-features/listing-19-18/output.txt}}
```

Поскольку способ `fly` принимает свойство `self`, если у нас было два *вида данных* оба использующих одну *сущность*, то Ржавчина может понять, какую использование сущности использовать в зависимости от вида данных `self`.

Однако, сопряженные функции, не являющиеся способами, не имеют свойства `self`. Когда существует несколько видов данных или сущностей, определяющих функции, не являющиеся способами, с одним и тем же именем функции, Ржавчина не всегда знает, какой вид вы имеете в виду, если только вы не используете *полные правила написания*. Например, в приложении 19-19 мы создаём сущность для приюта животных, который хочет назвать всех маленьких собак *Spot*. Мы создаём сущность `Animal` со связанной с ним функцией `baby_name`, не являющейся способом. Сущность `Animal` выполнен для стопки `Dog`, для которой мы также напрямую предоставляем сопряженную функцию `baby_name`, не являющуюся способом.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-19-19/src/main.rs}}
```

<span class="caption">Приложение 19-19: Сущность с сопряженной функцией и вид с сопряженной функцией с тем же именем, которая тоже использует сущность</span>

Мы выполнили рукопись для приюта для животных, который хочет назвать всех щенков именем Spot, в сопряженной функции `baby_name`, которая определена для `Dog`. Вид данных `Dog` также использует сущность `Animal`, который описывает свойства, которые есть у всех животных. Маленьких собак называют щенками, и это выражается в выполнении `Animal` у `Dog` в функции `baby_name` сопряженной с сущностью `Animal`.

В `main` мы вызываем функцию `Dog::baby_name`, которая вызывает сопряженную функцию определённую напрямую у `Dog`. Эта рукопись выводит следующее:

```console
{{#include ../listings/ch20-advanced-features/listing-19-19/output.txt}}
```

Этот вывод не является тем, что мы хотели бы получить. Мы хотим вызвать функцию `baby_name`, которая является частью сущности `Animal` выполненного у `Dog`, так чтобы рукопись выводил `A baby dog is called a puppy`. Средство указания имени сущности использованная в приложении 19-18 здесь не помогает; если мы изменим `main` рукопись как в приложении 19-20, мы получим ошибку сборки.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch20-advanced-features/listing-19-20/src/main.rs:here}}
```

<span class="caption">Приложение 19-20: Попытка вызвать функцию <code>baby_name</code> из сущности <code>Animal</code>, но Ржавчина не знает какую выполнение использовать</span>

Поскольку `Animal::baby_name` не имеет свойства `self`, и могут быть другие виды, использующие сущность `Animal`, Ржавчина не может понять, какую использование `Animal::baby_name` мы хотим использовать. Мы получим эту ошибку сборщика:

```console
{{#include ../listings/ch20-advanced-features/listing-19-20/output.txt}}
```

Чтобы устранить неоднозначность и сказать Ржавчине, что мы хотим использовать использование `Animal` для `Dog`, нужно использовать полные правила написания. Приложение 19-21 отображает, как использовать полные правила написания.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-19-21/src/main.rs:here}}
```

<span class="caption">Приложение 19-21: Использование полного правил написания для указания, что мы мы хотим вызвать функцию <code>baby_name</code> у сущности <code>Animal</code> выполненную в <code>Dog</code></span>

Мы указываем изложение вида данных в угловых скобках, которая указывает на то что мы хотим вызвать способ `baby_name` из сущности `Animal` выполненный в `Dog`, также указывая что мы хотим рассматривать вид данных `Dog` в качестве `Animal` для вызова этой функции. Эта рукопись теперь выведет то, что мы хотим:

```console
{{#include ../listings/ch20-advanced-features/listing-19-21/output.txt}}
```

В общем, полные правила написания определяется следующим образом:

```rust,ignore
<Type as Trait>::function(receiver_if_method, next_arg, ...);
```

Для сопряженных функций, которые не являются способами, будет отсутствовать `receiver` (предмет приёмника): будет только список переменных. Вы можете использовать полные правила написания везде, где вызываете функции или способы. Тем не менее, разрешается опустить любую часть этого правил написания, которую Ржавчина может понять из другой сведений в программе. Вам нужно использовать более подробный правила написания только в тех случаях, когда существует несколько выполнений, использующих одно и то же название, и Ржавчина нужно помочь определить, какую выполнение вы хотите вызвать.

### Использование супер сущностей для требования возможности одного сущности в рамках другого сущности

Иногда вы можете написать определение сущности, которое зависит от другого сущности: для вида данных, использующего первую сущность, вы хотите потребовать, чтобы этот вид также выполнил второй сущность. Вы должны сделать это, чтобы ваше определение сущности могло использовать связанные переменные второго сущности. Сущность, на которую опирается ваше определение сущности, называется *supertrait* вашего сущности.

Например, мы хотим создать сущность `OutlinePrint` со способом `outline_print`, который будет выводить значение обрамлённое звёздочками. Мы хотим чтобы стопка `Point`, использующая сущность встроенной библиотеки `Display`, отправила на вывод `(x, y)` при вызове `outline_print` у образца данных `Point`, который имеет значение `1` для `x` и значение `3` для `y`. Она должна вывести следующее:

```text
**********
*        *
* (1, 3) *
*        *
**********
```

В выполнении `outline_print` мы хотим использовать возможность сущности `Display`. Поэтому нам нужно указать, что сущность `OutlinePrint` будет работать только для видов данных, которые также используют `Display` и предоставляют возможность, которая нужна в `OutlinePrint`. Мы можем сделать это в объявлении сущности, указав `OutlinePrint: Display`. Этот способ похож на добавление ограничения в сущность. В приложении 19-22 показана использование сущности `OutlinePrint`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-19-22/src/main.rs:here}}
```

<span class="caption">Приложение 19-22: Использование сущности <code>OutlinePrint</code> которая требует возможности сущности <code>Display</code></span>

Поскольку мы указали, что сущность `OutlinePrint` требует сущности `Display`, мы можем использовать функцию `to_string`, которая самостоятельно выполнена для любого вида данных использующего `Display`. Если бы мы попытались использовать `to_string` не добавляя двоеточие и не указывая сущность `Display` после имени сущности, мы получили бы сообщение о том, что способ с именем `to_string` не был найден у вида данных `&Self` в текущей области видимости.

Давайте посмотрим что происходит, если мы пытаемся использовать сущность `OutlinePrint` для вида данных, который не использует `Display`, например стопка `Point`:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-02-impl-outlineprint-for-point/src/main.rs:here}}
```

Мы получаем сообщение о том, что требуется использование `Display`, но её нет:

```console
{{#include ../listings/ch20-advanced-features/no-listing-02-impl-outlineprint-for-point/output.txt}}
```

Чтобы исправить, мы используем `Display` у стопки `Point` и используем требуемое ограничение `OutlinePrint`, вот так:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-03-impl-display-for-point/src/main.rs:here}}
```

Тогда использование сущности `OutlinePrint` для стопки `Point` будет собрана успешно и мы можем вызвать `outline_print` у образца данных `Point` для отображения значения обрамлённое звёздочками.

### Образец данных Newtype для выполнение внешних сущностей у внешних видов данных

В разделе ["Использование сущности у вида данных"](ch10-02-traits.html#implementing-a-trait-on-a-type)<!-- ignore --> Главы 10, мы упоминали "правило сироты" (orphan rule), которое гласит, что разрешается использовать сущность у вида данных, если либо сущность, либо вид являются местными для нашего дополнения. Можно обойти это ограничение, используя *образец нового вида данных* (newtype pattern), который включает в себя создание нового вида данных в упорядоченной в ряд стопке. (Мы рассмотрели упорядоченные в ряд стопки  в разделе ["Использование стопок составных рядов без именованных полей для создания различных видов данных"]<!--  --> Главы 5.) Стопки составного ряда будет иметь одно поле и будет тонкой оболочкой для вида данных, к которому мы хотим использовать сущность. Тогда вид оболочки является местным для нашего дополнения и мы можем использовать сущность для местной обёртки. *Newtype* это понятие, который происходит от языка программирования Haskell. В нем нет ухудшения производительности времени выполнения при использовании этого образца данных и вид оболочки исключается во время сборки.

В качестве примера, мы хотим использовать сущность `Display` для вида данных `Vec<T>`, где "правило сироты" (orphan rule) не позволяет нам этого делать напрямую, потому что сущность `Display` и вид данных `Vec<T>` объявлены вне нашего дополнения. Мы можем сделать стопку `Wrapper`, которая содержит образец данных `Vec<T>`; тогда мы можем использовать `Display` у стопки `Wrapper` и использовать значение `Vec<T>` как показано в приложении 19-23.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-19-23/src/main.rs}}
```

<span class="caption">Приложение 19-23: Создание вида данных <code>Wrapper</code> <code>Vec&lt;String&gt;</code> для выполнения <code>Display</code></span>

Использование `Display` использует `self.0` для доступа к внутреннему `Vec<T>`, потому что `Wrapper` это стопка составного ряда, а `Vec<T>` это переменная с порядковым указателем 0 в составном ряде. Затем мы можем использовать полезные  возможности вида данных `Display` у `Wrapper`.

Недостатком использования этого средства является то, что `Wrapper` является новым видом данных, поэтому он не имеет возможных способов для значения, которое он держит в себе. Мы должны были бы использовать все способы для `Vec<T>` непосредственно во `Wrapper`, так чтобы эти способы делегировались внутреннему `self.0`, что позволило бы нам обращаться с `Wrapper` точно так же, как с `Vec<T>`. Если бы мы хотели, чтобы новый вид имел каждый способ имеющийся у внутреннего вида данных, используя сущность `Deref` (обсуждается в разделе <a data-md-type="raw_html" href="ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait">"Работа с умными указателями как с обычными ссылками с помощью `Deref` сущности"</a><!-- ignore --> Главы 15) у `Wrapper` для возвращения внутреннего вида данных, то это было бы решением. Если мы не хотим, чтобы вид данных `Wrapper` имел все способы внутреннего вида данных, например, для ограничения поведения вида данных `Wrapper`, то пришлось бы вручную использовать только те способы, которые нам нужны.

Этот образец newtype также полезен, даже когда сущности не задействованы. Давайте переключим внимание и рассмотрим некоторые продвинутые способы взаимодействия с системой видов данных Ржавчины.


["Образец данных Newtype для выполнение внешних сущностей у внешних видов данных"]: ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types
["Использование стопок составных рядов без именованных полей для создания различных видов данных"]: ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types