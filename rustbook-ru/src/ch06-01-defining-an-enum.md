## Определение перечисления

Там, где стопки дают вам возможность объединять связанные поля и данные, например `Rectangle` с его `width` и `height`, перечисления дают вам способ сказать, что значение является одним из возможных наборов значений. Например, мы можем захотеть сказать, что `Rectangle (Прямоугольник)`  — это одна из множества возможных фигур, в которую также входят `Circle (круг)` и `Triangle (треугольник)`. Для этого Ржавчина позволяет нам закодировать эти возможности в виде данных перечисления.

Давайте рассмотрим случай, который мы могли бы захотеть отразить в рукописи, и поймём, почему перечисления полезны и более уместны, чем стопки в этом случае. Допустим, нам нужно работать с IP-адресами. В настоящее время для обозначения IP-адресов используются два основных исполнения: четвёртое и шестое исполнение. Поскольку это единственно возможные исходы IP-адресов, с которыми может столкнуться наша программа, мы можем *перечислить* все возможные исходы, откуда перечисление и получило своё название.

Любой IP-адрес может быть либо четвёртым, либо шестым исполнением, но не обеими одновременно. Эта особенность IP-адресов делает вид данных enum подходящим, поскольку значение enum может представлять собой только один из его возможных исходов. Адреса как четвёртого, так и шестого исполнения по своей сути все равно являются IP-адресами, поэтому их следует рассматривать как один и тот же вид данных, когда в рукописи обрабатываются задачи, относящиеся к любому виду IP-адресов.

Можно выразить этот подход в рукописи, определив перечисление `IpAddrKind` и составив список возможных видов IP-адресов, `V4` и `V6`. Вот исходы перечислений:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-01-defining-enums/src/main.rs:def}}
```

`IpAddrKind` теперь является пользовательским видом данных, который мы можем использовать в другом месте нашей рукописи.

### Значения перечислений

Образцы каждого исхода перечисления `IpAddrKind` можно создать следующим образом:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-01-defining-enums/src/main.rs:instance}}
```

Обратите внимание, что исходы перечисления находятся в пространстве имён вместе с его определителем, а для их обособления мы используем двойное двоеточие. Это удобно тем, что теперь оба значения `IpAddrKind::V4` и `IpAddrKind::V6` относятся к одному виду: `IpAddrKind`. Затем мы можем, например, определить функцию, которая принимает любой из исходов `IpAddrKind`:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-01-defining-enums/src/main.rs:fn}}
```

Можно вызвать эту функцию с любым из исходов:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-01-defining-enums/src/main.rs:fn_call}}
```

Использование перечислений позволяет получить ещё больше преимуществ. Если подумать о нашем виде для IP-адреса, то выяснится, что на данное мгновение у нас нет возможности хранить собственно сам *IP-адрес*; мы будем знать только его *вид*. Учитывая, что недавно в главе 5 вы узнали о стопках, у вас может возникнуть соблазн решить эту неполадку с помощью стопок, как показано в приложении 6-1.

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-01/src/main.rs:here}}
```

<span class="caption">Приложение 6-1: Сохранение данных и <code>IpAddrKind</code> IP-адреса с использованием <code>struct</code></span>

Здесь мы определили стопку `IpAddr`, у которой есть два поля: `kind` вида данных `IpAddrKind` (перечисление, которое мы определили ранее) и `address` вида данных `String`. У нас есть два образца данных этой стопки. Первый - `home`, который является `IpAddrKind::V4` в качестве значения `kind` с соответствующим адресом `127.0.0.1`. Второй образец  данных - `loopback`. Он в качестве значения `kind` имеет другой исход `IpAddrKind`, `V6`, и с ним сопряжен адрес `::1`. Мы использовали виды данных стопка и перечисления для объединения значений `kind` и `address` вместе, таким образом вид адреса теперь сопряжен со значением.

Представление этого подхода с помощью перечисления в более кратком виде: вместо того, чтобы помещать перечисление в вид данных стопка, мы можем поместить данные непосредственно в любой из исходов перечисления. Это новое определение перечисления `IpAddr` гласит, что оба исхода `V4` и `V6` будут иметь соответствующие значения `String`:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-02-enum-with-data/src/main.rs:here}}
```

Мы прикрепляем данные к каждому исходу перечисления напрямую, поэтому нет необходимости в дополнительной стопке. Здесь также легче увидеть ещё одну особенность того, как работают перечисления: имя каждого исхода перечисления, который мы определяем, также становится функцией, которая создаёт образец перечисления. То есть `IpAddr::V4()` - это вызов функции, который принимает `String` и возвращает образец вида данных `IpAddr`. Мы самостоятельно получаем эту функцию-строитель, определяемую в итоге определения перечисления.

Ещё одно преимущество использования перечисления вместо стопки заключается в том, что каждый исход перечисления может иметь разное количество сопряженных данных представленных в разных видах. Исполнение 4 для IP адресов всегда будет содержать четыре цифровых составляющих, которые будут иметь значения между 0 и 255. При необходимости сохранить адреса вида данных `V4` как четыре значения вида данных `u8`, а также описать адреса вида данных `V6` как единственное значение вида данных  `String`, мы не смогли бы с помощью стопки. Перечисления решают эту задачу легко:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-03-variants-with-different-data/src/main.rs:here}}
```

Мы показали несколько различных способов определения стопок данных для хранения IP-адресов четвёртого и шестого исполнений. Однако, как оказалось, желание хранить IP-адреса и указывать их вид настолько распространено, что во встроенной библиотеке есть определение, которое мы можем использовать!<!-- ignore --> Давайте посмотрим, как обычная библиотека определяет `IpAddr`: в ней есть точно такое же перечисление с исходами, которое мы определили и использовали, но она помещает данные об адресе внутрь этих исходов в виде двух различных стопок, которые имеют различные определения для каждого из исходов:

```rust
struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
```

Эта рукопись отображает что мы можем добавлять любой вид данных в значение перечисления: строку, число, стопку и пр. Вы даже можете включить в перечисление другие перечисления! Обычные виды данных не очень сложны, хотя, возможно, могут быть очень сложными (вложенность данных может быть очень глубокой).

Обратите внимание, что хотя определение перечисления `IpAddr` есть во встроенной библиотеке, мы смогли объявлять и использовать своё собственное исполнение с подобным названием без каких-либо несоответствий, потому что мы не добавили определение встроенной библиотеки в область видимости рукописи. Подробнее об этом поговорим в Главе 7.

Рассмотрим другой пример перечисления в приложении 6-2: в этом примере каждая переменная перечисления имеет свой особый вид данных внутри:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-02/src/main.rs:here}}
```

<span class="caption">Приложение 6-2: Перечисление <code>Message</code>, в каждом из исходов которого хранятся разные количества и виды данных.</span>

Это перечисление имеет 4 составляющих:

- `Quit` - пустая переменная без сопряженных данных,
- `Move` имеет именованные поля, как и стопки.
- `Write` - переменная с единственной строкой вида данных `String`,
- `ChangeColor` - упорядоченный ряд из трёх значений вида данных `i32`.

Определение перечисления с исходами, такими как в приложении 6-2, похоже на определение значений различных видов данных внутри стопок, за исключением того, что перечисление не использует ключевое слово `struct` и все исходы объединены внутри вида данных `Message`. Следующие стопки могут содержать те же данные, что и предыдущие исходы перечислений:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-04-structs-similar-to-message-enum/src/main.rs:here}}
```

Но когда мы использовали различные стопки, каждая из которых имеет свои собственные виды данных, мы не могли легко определять функции, которые принимают любые виды сообщений, как это можно сделать с помощью перечисления вида данных `Message`, объявленного в приложении 6-2, который является единым видом данных.

Есть ещё одно сходство между перечислениями и стопками: так же, как мы можем определять способы для стопок с помощью `impl` раздела, мы можем определять и способы для перечисления. Вот пример способа с именем `call`, который мы могли бы определить в нашем перечислении `Message`:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-05-methods-on-enums/src/main.rs:here}}
```

В теле способа будет использоваться `self` для получения значение того предмета. у которого мы вызвали этот способ. В этом примере мы создали переменную `m`, содержащую значение `Message::Write(String::from("hello"))`, и именно это значение будет представлять `self` в теле способа `call` при выполнении `m.call()`.

Теперь посмотрим на другое наиболее часто используемое перечисление из встроенной библиотеки, которое является очень распространённым и полезным: `Option`.

### Перечисление `Option` и его преимущества перед Пустыми (Null)-значениями

В этом разделе рассматривается пример использования вида данных `Option`, ещё одного перечисления, определённого во встроенной библиотеке. Вид данных `Option` кодирует очень распространённую задумку, в котором значение может быть чем-то, а может быть ничем.

Например, если вы запросите первая переменная из непустого списка, вы получите значение. Если вы запросите первая переменная пустого списка, вы ничего не получите. Выражение этого подхода в понятиях системы видов означает, что сборщик может проверить, обработали ли вы все исходы, которые должны были обработать; эта возможность может предотвратить ошибки, которые чрезвычайно распространены в других языках программирования.

Устройство языка программирования часто рассматривается с точки зрения того, какие функции вы включаете в него, но те функции, которые вы исключаете, также важны. Например в Ржавчине нет таких возможностей как пустые (null) значения, однако она есть во многих других языках. *Пустое (Null) значение* - это значение, которое означает, что значения нет. В языках с возможностью определения пустых значений переменные всегда могут находиться в одном из двух состояний: *нет значения (пустота/null)* или *есть значение (не пустое/not-null)*.

В своём докладе 2009 года «Пустые ссылки: ошибка в миллиард долларов» Тони Хоар (Tony Hoare), изобретатель пустолты (null), сказал следующее:

> Я называю это своей ошибкой на миллиард долларов. В то время я разрабатывал первую целостную систему видов для ссылок на предметно-направленном языке. Моя цель состояла в том, чтобы обеспечить, что любое использование ссылок должно быть безусловно безопасным, с самостоятельной проверкой сборщиком. Но я не мог устоять перед соблазном вставить пустую ссылку просто потому, что это было так легко выполнить. Это привело к бесчисленным ошибкам, уязвимостям и системным сбоям, которые, вероятно, причинили боль и ущерб на миллиард долларов за последние сорок лет.

Неполадка с пустыми значениями заключается в том, что если вы попытаетесь использовать пустые значение в качестве не пустого  (not-null) значения, вы получите ошибку определённого рода. Поскольку свойство пустота (null) или не пустота (not-null) распространено повсеместно, сделать такую ошибку очень просто.

Тем не менее, подход, которую пустота пытается выразить, является полезным: пустое - это значение, которое в настоящее время по какой-то причине недействительно или отсутствует.

Неполадка на самом деле не в подходе, а в определенном исполнении. Таким образом, в Ржавчине нет пустых значений, поэтому принят подход в виде перечисления, которое принимает значения наличия  (not-null) или отсутствия (null) самого значения. Это вид данных перечисление `Option<T>` , и оно [определено встроенной библиотекой] <!-- ignore --> следующим образом:

```rust
enum Option<T> {
    None,
    Some(T),
}
```

Перечисление `Option<T>` настолько полезно, что оно даже включено во встроенный набор; вам не нужно явно вводить его в область видимости. Его исходы также включены во встроенный набор: вы можете использовать `Some` и `None` напрямую, без приставки `Option::`. При всём при этом, `Option<T>` является обычным перечислением, а `Some(T)` и `None` представляют собой его исходы.

`<T>` - это особенность Ржавчины, о которой мы ещё не говорили. Это свойство обобщённого вида данных, и мы рассмотрим его более подробно в главе 10. На данное мгновение всё, что вам нужно знать, это то, что `<T>` означает, что исход `Some` перечисления `Option` может содержать один отрывок любого вида данных, и что каждый определенный вид данных, который используется вместо `T` делает общий `Option<T>` другим видом данных. Вот несколько примеров использования `Option` для хранения числовых и строковых видов данных:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-06-option-examples/src/main.rs:here}}
```

Вид данных `some_number` - `Option<i32>`. Вид данных `some_char` - `Option<char>`, это другой вид данных. Ржавчина может вывести эти виды данных, потому что мы указали значение внутри исхода `Some`. Для `absent_number` Ржавчина требует, чтобы мы определяли общий вид данных для `Option` : сборщик не может вывести вид данных, который будет в `Some`, глядя только на значение `None`. Здесь мы сообщаем Ржавчине, что `absent_number` должен иметь вид данных `Option<i32>`.

Когда есть значение `Some`, мы знаем, что значение присутствует и содержится внутри `Some`. Когда есть значение `None`, это означает то же самое, что и пустота в некотором смысле: у нас нет действительного значения. Так почему наличие `Option<T>` лучше, чем пустота?

Вкратце, поскольку `Option<T>` и `T` (где `T` может быть любым видом данных) относятся к разным видам данных, сборщик не позволит нам использовать значение `Option<T>` даже если бы оно было определённо допустимым значением. Например, эта рукопись не будет собираться, потому что она пытается добавить `i8` к значению вида данных `Option<i8>`:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-07-cant-use-option-directly/src/main.rs:here}}
```

Если мы запустим эту рукопись, то получим такое сообщение об ошибке:

```console
{{#include ../listings/ch06-enums-and-pattern-matching/no-listing-07-cant-use-option-directly/output.txt}}
```

Сильно! В действительности, это сообщение об ошибке означает, что Ржавчина не понимает, как сложить `i8` и `Option<i8>`, потому что это разные виды данных. Когда у нас есть значение вида данных наподобие `i8`, сборщик заверяет, что у нас всегда есть допустимое значение вида данных. Мы можем уверенно продолжать работу, не проверяя его на пустоту перед использованием. Однако, когда у нас есть значение вида данных `Option<T>` (где `T` - это любое значение любого вида данных `T`, упакованное в `Option`, например значение вида данных `i8` или `String`), мы должны беспокоиться о том, что <em>значение</em> вида данных T возможно не имеет значения (является исходом `None`), и сборщик позаботится о том, чтобы мы обработали такой случай, прежде чем мы бы попытались использовать `None` значение.

Другими словами, вы должны преобразовать `Option<T>` в `T` прежде чем вы сможете выполнять действия с этим `T`. Как правило, это помогает выявить одну из наиболее распространённых неполадок с пустотой: предполагая, что что-то не равно пустоте, когда оно на самом деле равно пустоте.

Устранение риска ошибочного предположения касательно не-пустого значения помогает вам быть более уверенным в своей рукописи. Чтобы использовать переменную, значение которой может быть пустотой, вы должны явно описать вид данных этой переменной с помощью `Option<T>`. Затем, когда вы используете эту переменную, вы обязаны явно обрабатывать случай, когда значение равно пустоте. Везде, где значение переменной имеет вид данных, отличный от `Option<T>`, вы *можете* смело рассчитывать на то, что значение не равно пустоте. Это продуманное расчетное решение в Ржавчине ограничивающее распространение пустоты и увеличивающее безопасность рукописи на Ржавчине.

Итак, как же получить значение `T` из исхода `Some`, если у вас на руках есть только предмет `Option<T>`, и как можно его, вообще, использовать? Перечисление `Option<T>` имеет большое количество способов, применимых в различных случаях; вы можете ознакомиться с ними в [его пособии]<!-- ignore -->. Знакомство с способами перечисления `Option<T>` будет чрезвычайно полезным в вашем путешествии с Ржавчиной.

В общем случае, чтобы использовать значение `Option<T>`, нужна рукопись, которая будет обрабатывать все исходы перечисления `Option<T>`. Вам понадобится некоторая рукопись, которая будет работать только тогда, когда у вас есть значение `Some(T)`, и этой рукописи разрешено использовать внутри `T`. Также вам понадобится другая рукопись, которая будет работать, если у вас есть значение `None`, и у этой рукописи не будет доступного значения `T`. Выражение <code>match</code> — это устройство управления потоком выполнения программы, которое делает именно это при работе с перечислениями: оно запускает разные указания в зависимости от того, какой исход перечисления имеется, и это средство может использовать указания, находящиеся внутри совпавшего исхода.


[определено встроенной библиотекой]: ../std/option/enum.Option.html
[его пособии]: ../std/option/enum.Option.html