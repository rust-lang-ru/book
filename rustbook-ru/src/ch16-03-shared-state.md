## Многопоточное разделяемое состояние

Передача сообщений — прекрасный способ обработки одновременности, но не единственный. Другим способом может быть доступ нескольких потоков к одним и тем же общим данным. Рассмотрим ещё раз часть слогана из пособия по языку Go: «Не стоит передавать сведения с помощью разделяемой памяти».

Как бы выглядело общение, используя разделяемую память? Кроме того, почему знатоки передачи сообщений предостерегают от его использования?

В каком-то смысле протоки в любом языке программирования похожи на единоличное владение, потому что после передачи значения по протоку, вы больше не можете использовать отправленное значение. Многопоточно совместно используемая память подобна множественному владению: несколько потоков могут одновременно обращаться к одной и той же области памяти. Как вы видели в главе 15, где умные указатели сделали возможным множественное владение, данный добавляет сложность, потому что нужно управлять этими разными владельцами. Перечень видов данных Ржавчины и правила владения очень помогают в их правильном управлении. Для примера давайте рассмотрим взаимные исключение, один из наиболее распространённых случаев многопоточности для распределения памяти.

### Взаимные исключение предоставляют доступ к данным из одного потока (за раз)

*Mutex* - это сокращение от *взаимное исключение* (mutual exclusion), так как взаимное исключение позволяет только одному потоку получать доступ к некоторым данным в этот отрывок времени. Для того, чтобы получить доступ к данным в взаимном исключении, поток должен сначала подать звонок, что он хочет получить доступ, запрашивая *запрет* (lock) взаимного исключения. Запрет - это вид данных, являющаяся частью взаимного исключения, который отслеживает кто в настоящее время имеет выделенный доступ к данным. Поэтому взаимное исключение описывается как способ *защиты* данных, которые он хранит через устройство запрета.

Взаимные исключение трудные в использовании, потому что вы должны помнить два правила:

- Перед тем как попытаться получить доступ к данным, необходимо получить запрет.
- Когда вы закончили работу с данными, которые защищает взаимное исключение, вы должны снять запрет с данных, чтобы другие потоки могли получить запрет.

Для понимания взаимного исключения, представьте пример из жизни как объединённое обсуждение на встрече с одним громкоговорителем. Прежде чем участник спора сможет говорить, он должен спросить или сообщить, что он хочет использовать громкоговоритель. Когда он получает громкоговоритель, то может говорить столько, сколько хочет, а затем передаёт громкоговоритель следующему участнику, который попросит дать ему выступить. Если участник спора забудет освободить громкоговоритель, когда закончит с ним, то никто больше не сможет говорить. Если управление общим громкоговорителем идёт не правильно, то во время встречи не получится высказаться никому!

Правильное управление взаимными исключениями может быть невероятно сложным и именно поэтому многие люди с большим рвением относятся к протокам. Однако, благодаря перечню видов данных и правилам владения в Ржавчине, вы не можете использовать запрет и снятие запрета неправильным образом.

#### `Mutex<T>` API

Давайте рассмотрим пример использования взаимного исключения в приложении 16-12 без использования нескольких потоков:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-12/src/main.rs}}
```

<span class="caption">Приложение 16-12: Изучение API <code>Mutex&lt;T&gt;</code> для простоты в однопоточном среде</span>

Как и во многих других видах данных, мы создаём `Mutex<T>` с помощью сопутствующего способа `new`. Чтобы получить доступ к данным внутри взаимного исключения, мы используем способ `lock` для получения запрета. Этот вызов запрещает выполнение текущего потока, так что он не сможет выполнять никакие действия, до тех пор пока не наступит наша очередь получить запрет.

Вызов `lock` потерпит неудачу, если другой поток, удерживающий запрет, вызовет сбой. В таком случае никто не сможет получить запрет, поэтому мы предпочли использовать `unwrap` и заставить этот поток вызвать сбой, если мы окажемся в таком случае.

После получения запрета мы можем воспринимать возвращённое значение, названное в данном случае `num`, как изменяемую ссылку на содержащиеся внутри данные. Перечень видов данных заверяет, что мы получим запрет перед использованием значения в `m`. Вид данных `m` - `Mutex<i32>`, а не `i32`, поэтому мы *должны* вызвать `lock`, чтобы иметь возможность использовать значение <code>i32</code>. Мы не должны об этом забывать, тем более что в иных случаях перечень видов данных и не даст нам доступ к внутреннему значению `i32`.

Как вы наверное подозреваете, `Mutex<T>` является умным указателем. Точнее, вызов `lock` *возвращает* умный указатель, называемый `MutexGuard`, обёрнутый в `LockResult`, который мы обработали с помощью вызова `unwrap`. Умный указатель вида данных `MutexGuard` использует сущность `Deref` для указания на внутренние данные; умный указатель также имеет использование сущности `Drop`, самостоятельно снимающего запрет, когда `MutexGuard` выходит из области видимости, что происходит в конце внутренней области видимости. В итоге у нас нет риска забыть снять запрет и оставить взаимное исключение в запрещенном состоянии, препятствуя  его использованию другими потоками (снятие запрета происходит самостоятельно ).

После снятия запрета можно вывести значение взаимного исключения и увидеть, что мы смогли изменить внутреннее `i32` на 6.

#### Разделение `Mutex<T>` между множеством потоков

Теперь давайте попробуем с помощью `Mutex<T>` совместно использовать значение между несколькими потоками. Мы запускаем 10 потоков и каждый из них увеличивает значение счётчика на 1, поэтому счётчик изменяется от 0 до 10. Обратите внимание, что в следующих нескольких примерах будут ошибки сборщика и мы будем использовать эти ошибки, чтобы узнать больше об использовании вида данных `Mutex<T>` и как Ржавчина помогает нам правильно его использовать. Приложение 16-13 содержит наш начальный пример:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-13/src/main.rs}}
```

<span class="caption">Приложение 16-13: Десять потоков, увеличивающих счётчик, защищённый <code>Mutex&lt;T&gt;</code></span>

Мы создаём переменную `счётчик` для хранения `i32` значения внутри `Mutex<T>`, как мы это делали в приложении 16-12. Затем мы создаём 10 потоков, перебирая ряд чисел. Мы используем `thread::spawn` и передаём всем этим потокам одинаковое замыкание, которое передаёт счётчик в поток, запрашивает запрет на `Mutex<T>`, вызывая способ `lock`, а затем добавляет 1 к значению во взаимном исключении. Когда поток завершит выполнение своего замыкания, `num` выйдет из области видимости и освободит запрет на переменную `счётчик`, чтобы её мог получить другой поток.

В основном потоке мы собираем все указатели в переменную `владелец`. Затем, как мы это делали в приложении 16-2, вызываем `join` для каждого указателя, чтобы убедиться в завершении всех потоков. В это мгновение основной поток получит доступ к запрету и тоже выведет итог программы.

Сборщик явно указывает об допущенных ошибках. Давайте выясним почему!

```console
{{#include ../listings/ch16-fearless-concurrency/listing-16-13/output.txt}}
```

Сообщение об ошибке указывает, что значение `счётчик` было перемещёно в замыкание. Ржавчина говорит нам, что мы не можем передать <code>счётчик</code> во владение  нескольким потокам. Давайте исправим ошибку сборщика с помощью способа множественного владения, который мы обсуждали в главе 15.

#### Множественное владение между множеством потоков

В главе 15 мы давали значение нескольким владельцам, используя умный указатель `Rc<T>` для создания значения подсчитанных ссылок. Давайте сделаем то же самое здесь и посмотрим, что произойдёт. Мы завернём `Mutex<T>` в `Rc<T>` в приложении 16-14 и создадим двойника `Rc<T>` перед передачей владения в поток. Теперь, когда мы увидели ошибки, мы также вернёмся к использованию круговорота `for` и сохраним ключевое слово `move` у замыкания.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-14/src/main.rs}}
```

<span class="caption">Приложение 16-14: Попытка использования <code>Rc&lt;T&gt;</code>, чтобы позволить нескольким потокам владеть <code>Mutex&lt;T&gt;</code></span>

Ещё раз, мы собираем и получаем ... другие ошибки! Сборщик  учит нас.

```console
{{#include ../listings/ch16-fearless-concurrency/listing-16-14/output.txt}}
```

Ничего себе, это сообщение об ошибке очень многословно! Вот важная часть, на которой следует сосредоточиться:`` `Rc<Mutex<i32>>` cannot be sent between threads safely ``. Сборщик также сообщает нам причину:`` the trait `Send` is not implemented for `Rc<Mutex<i32>>` ``. Мы поговорим о `Send` в следующем разделе: это одна из сущностей, которая заверяет, что виды данных, которые мы используем с потоками, предназначены для использования в многопоточной рукописи.

К сожалению, `Rc<T>` небезопасен для совместного использования между потоками. Когда `Rc<T>` управляет счётчиком ссылок, он добавляется значение к счётчику для каждого вызова `clone` и вычитается значение из счётчика, когда каждое удвоенное значение удаляется при выходе из области видимости. Но он не использует простейшие многопоточности, чтобы обеспечить, что изменения в подсчёте не могут быть прерваны другим потоком. Это может привести к неправильным подсчётам - незначительным ошибкам, которые в свою очередь, могут привести к утечкам памяти или удалению значения до того, как мы отработали с ним. Нам нужен вид данных точно такой же как `Rc<T>`, но который позволяет изменять счётчик ссылок безопасно из разных потоков.

#### Неделимый (Атомарный) счётчик ссылок `Arc<T>`

К счастью, `Arc<T>` *является* видом, подобным виду данных `Rc<T>`, который безопасен для использования в случаях многопоточности. Буква *А* означает *атомарное* или *неделимое*, что означает вид данных с *неделимым подсчётом ссылок*. Atomics - это дополнительный вид данных простейших для многопоточности, который мы не будем здесь подробно описывать: дополнительные сведения смотрите в пособии встроенной библиотеки для <code>std::sync::atomic</code>. На данное мгновение вам просто нужно знать, что atomics работают как простые виды, но безопасны для совместного использования между потоками.

Вы можете спросить, почему все простые виды данных не являются неделимыми и почему обычные виды данных библиотек не предназначены для использования вместе с видом данных `Arc<T>` по умолчанию. Причина в том, что безопасность потоков сопровождается снижением производительности, которое вы хотите платить только тогда, когда вам это действительно нужно. Если вы просто выполняете действия со значениями в одном потоке, то Ваша рукопись может работать быстрее, если она не должна обеспечивать заверения предоставляемые atomics.

Давайте вернёмся к нашему примеру: виды данных `Arc<T>` и `Rc<T>` имеют одинаковый API, поэтому мы исправляем нашу программу, заменяя вид данных в строках `use`, вызове `new` и вызове `clone`. Рукопись в приложении 16-15, наконец собирается и запустится:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-15/src/main.rs}}
```

<span class="caption">Приложение 16-15: Использование вида данных <code>Arc&lt;T&gt;</code> для обёртывания <code>Mutex&lt;T&gt;</code>, теперь несколько потоков могут совместно владеть взаимным исключением</span>

Рукопись выведет следующее:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
Result: 10
```

Мы сделали это! Мы посчитали от 0 до 10, что может показаться не очень впечатляющим, но это позволило больше узнать про `Mutex<T>` и безопасность потоков. Вы также можете использовать устройство этой программы для выполнения более сложных действий, чем просто увеличение счётчика. Используя эту стратегию, вы можете разделить вычисления на независимые части, разделить эти части на потоки, а затем использовать `Mutex<T>`, чтобы каждый поток обновлял конечный итог своей частью рукописи.

Обратите внимание, что если вы используете простые числовые действия, то существуют виды данных более простые, чем `Mutex<T>`, которые предоставляет раздел [`std::sync::atomic` встроенной библиотеки]<!-- ignore -->. Эти виды данных обеспечивают безопасный, одновременный, неделимый доступ к простым видам данных. Мы решили использовать `Mutex<T>` с простым видом данных в этом примере, чтобы подробнее рассмотреть, как работает `Mutex<T>`.

### Сходства `RefCell<T>` / `Rc<T>` и `Mutex<T>` / `Arc<T>`

Вы могли заметить, что `счётчик` сам по себе не изменяемый (immutable), но мы можем получить изменяемую ссылку на значение внутри него; это означает, что `Mutex<T>` обеспечивает внутреннюю изменяемость, также как и семейство `Cell` видов. Мы использовали `RefCell<T>` в главе 15, чтобы получить возможность изменять содержимое внутри `Rc<T>`, теперь подобным образом мы используем `Mutex<T>` для изменения содержимого внутри `Arc<T>` .

Ещё одна подробность, на которую стоит обратить внимание: Ржавчина не может защитить вас от всевозможных разумных ошибок при использовании `Mutex<T>`. Вспомните в главе 15, что использование `Rc<T>` сопряжено с риском создания ссылочной замкнутости, где два значения `Rc<T>` ссылаются друг на друга, что приводит к утечкам памяти. Подобным образом, `Mutex<T>` сопряжён с риском создания *взаимных запретов* (deadlocks). Это происходит, когда действия необходимо запретить два средства и каждый из двух потоков получил один из запретов, заставляя оба потока ждать друг друга вечно. Если вам важна направление взаимных запретов, попробуйте создать программу Ржавчина, которая её содержит; затем исследуйте стратегии устранения взаимных запретов для взаимных исключений на любом языке и попробуйте использовать их в Ржавчине. Пособие встроенной библиотеки для `Mutex<T>` и `MutexGuard` предлагает полезные сведения.

Мы завершим эту главу, рассказав о сущностях `Send` и `Sync` и о том, как мы можем использовать их с пользовательскими видами данных.


[`std::sync::atomic` встроенной библиотеки]: ../std/sync/atomic/index.html