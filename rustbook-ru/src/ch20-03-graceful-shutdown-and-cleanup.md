## Мягкое завершение работы и очистка

Приложение 20-20 не согласованно отвечает на запросы с помощью использования объединения потоков, как мы и хотели. Мы получаем некоторые предупреждения про `workers`, `id` и поля `thread`, которые мы не используем напрямую, что напоминает нам о том, что мы не освобождаем все мощности. Когда мы используем менее элегантный способ остановки основного потока клавишной сочетанием <span class="keystroke">ctrl-c</span>, все остальные потоки также немедленно останавливаются, даже если они находятся в середине обработки запроса.

Далее, выполняем сущность  `Drop` для вызова `join` у каждого потока в объединении, чтобы они могли завершить запросы, над которыми они работают, перед закрытием. Затем мы выполняем способ сообщить потокам, что они должны перестать принимать новые запросы и завершить работу. Чтобы увидеть эту рукопись в действии, мы изменим наш отдельный вычислитель так, чтобы он принимал только два запроса, после чего правильно завершал работу объединения потоков.

### Использование сущности `Drop` для `ThreadPool`

Давайте начнём с выполнения `Drop` у нашего объединения потоков. Когда объединение удаляется, все наши потоки должны объединиться (join), чтобы убедиться, что они завершают свою работу. В приложении 20-22 показана первая попытка выполнения `Drop`, рукопись пока не будет работать.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch20-web-server/listing-20-22/src/lib.rs:here}}
```

<span class="caption">Приложение 20-22: Присоединение (Joining) каждого потока, когда объединение потоков выходит из области видимости</span>

Сначала мы пройдёмся по каждому `worker` из объединения потоков. Для этого мы используем `&mut` с `self`, потому что нам нужно иметь возможность изменять `worker`. Для каждого обработчика мы выводим сообщение о том, что он завершает работу, а затем вызываем `join` у потока этого обработчика. Для случаев, когда вызов `join` не удался, мы используем `unwrap`, чтобы заставить Ржавчину вызвать сбой и перейти в режим грубого завершения работы.

Ошибка получаемая при сборке этой рукописи:

```console
{{#include ../listings/ch20-web-server/listing-20-22/output.txt}}
```

Ошибка говорит нам, что мы не можем вызвать `join`, потому что у нас есть только изменяемое заимствование каждого `worker`, а `join` забирает во владение свой переменная. Чтобы решить эту неполадку, нам нужно извлечь поток из образца данных `Worker`, который владеет `thread`, чтобы `join` мог его использовать. Мы сделали это в приложении 17-15: теперь, когда `Worker` хранит в себе `Option<thread::JoinHandle<()>>`, мы можем воспользоваться способом `take` у `Option`, чтобы извлечь значение из исхода `Some`, тем самым оставляя на его месте `None`. Другими словами, в рабочем состоянии `Worker` будет использовать исход `Some` содержащий `thread`, а когда мы захотим завершить `Worker`, мы заменим `Some` на `None`, чтобы у `Worker` не было потока для работы.

Итак, мы хотим обновить объявление `Worker` следующим образом:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch20-web-server/no-listing-04-update-worker-definition/src/lib.rs:here}}
```

Теперь давайте опираться на сборщик, чтобы найти другие места, которые нужно изменить. Проверяя рукопись, мы получаем две ошибки:

```console
{{#include ../listings/ch20-web-server/no-listing-04-update-worker-definition/output.txt}}
```

Давайте обратимся ко второй ошибке, которая указывает на рукопись в конце `Worker::new`; нам нужно обернуть значение `thread` в исход `Some` при создании нового `Worker`. Внесите следующие изменения, чтобы исправить эту ошибку:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch20-web-server/no-listing-05-fix-worker-new/src/lib.rs:here}}
```

Первая ошибка находится в нашем выполнении `Drop`. Ранее мы упоминали, что намеревались вызвать `take` для свойства `Option`, чтобы забрать `thread` из этапа `worker`. Следующие изменения делают это:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,not_desired_behavior
{{#rustdoc_include ../listings/ch20-web-server/no-listing-06-fix-threadpool-drop/src/lib.rs:here}}
```

Как уже говорилось в главе 17, способ `take` у вида данных `Option` забирает значение из исхода `Some` и оставляет исход `None` в этом месте. Мы используем `if let`, чтобы разъединять `Some` и получить поток; затем вызываем `join` у потока. Если поток "работника" уже `None`, мы знаем, что этот "работник" уже очистил свой поток, поэтому в этом случае ничего не происходит.

### Тревожное оповещение потокам прекратить прослушивание получения задач

Теперь, после всех внесённых нами изменений, рукопись собирается без каких-либо предупреждений. Но плохая новость в том, что эта рукопись всё ещё не работает так, как мы этого хотим. Причина заключается в ходу мыслей замыканий, запускаемых потоками образцов Worker: в данный мгновение мы вызываем join, но это не приводит к завершению потоков, так как они находятся в бесконечном круговороте, ожидая новую задачу. Если мы попытаемся удалить ThreadPool в текущем выполнении drop, основной поток навсегда станет недоступным в ожидании завершения первого потока из объединения .

Чтобы решить эту неполадку, нам нужно будет изменить использование `drop` в `ThreadPool`, а затем внести изменения в круговорот `Worker` .

Во-первых, изменим использование `drop` `ThreadPool` таким образом, чтобы явно удалять `sender` перед тем, как начнём ожидать завершения потоков. В приложении 20-23 показаны изменения в `ThreadPool` для явного удаления `sender` . Мы используем ту же технику `Option` и `take`, что и с потоком, чтобы переместить `sender` из `ThreadPool`:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground,not_desired_behavior
{{#rustdoc_include ../listings/ch20-web-server/listing-20-23/src/lib.rs:here}}
```

<span class="caption">Приложение 20-23: Явное удаление <code>sender</code> перед ожиданием завершения рабочих потоков</span>

Удаление `sender` закрывает поток, что указывает на то, что сообщения больше не будут отправляться. Когда это произойдёт, все вызовы `recv`, выполняемые рабочими этапами в бесконечном круговороте, вернут ошибку. В приложении 20-24 мы меняем круговорот `Worker` для правильного выхода из него в этом случае, что означает, что потоки завершатся, когда использование `drop` `ThreadPool` вызовет для них `join`.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch20-web-server/listing-20-24/src/lib.rs:here}}
```

<span class="caption">Приложение 20-24: Явный выход из круговорота, когда <code>recv</code> возвращает ошибку</span>

Чтобы увидеть эту рукопись в действии, давайте изменим `main`, чтобы принимать только два запроса, прежде чем правильно завершить работу отдельного вычислителя как показано в приложении 20-25.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch20-web-server/listing-20-25/src/main.rs:here}}
```

<span class="caption">Рукопись 20-25. Выключение отдельного вычислителя после обслуживания двух запросов с помощью выхода из круговорота</span>

Вы бы не хотели, чтобы существующий сетевой-отдельный вычислитель отключался после обслуживания только двух запросов. Эта рукопись всего лишь отображает, что правильное завершение работы и освобождение мощностей находятся в рабочем состоянии.

Способ `take` определён в сущности `Iterator` и ограничивает повторение самое большее первыми двумя переменными. `ThreadPool` выйдет из области видимости в конце `main` и будет запущена его использование `drop`.

Запустите отдельный вычислитель с `cargo run` и сделайте три запроса. Третий запрос должен выдать ошибку и в окне вызова вы должны увидеть вывод, подобный следующему:

<!-- manual-regeneration
cd listings/ch20-web-server/listing-20-25
cargo run
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
third request will error because server will have shut down
copy output below
Can't automate because the output depends on making requests
-->

```console
$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Shutting down.
Shutting down worker 0
Worker 3 got a job; executing.
Worker 1 disconnected; shutting down.
Worker 2 disconnected; shutting down.
Worker 3 disconnected; shutting down.
Worker 0 disconnected; shutting down.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
```

Вы возможно увидите другой порядок рабочих потоков и выведенных сообщений. Мы можем увидеть, как эта рукопись работает по сообщениям: "работники" номер 0 и 3 получили первые два запроса. Отдельный вычислитель прекратил принимать соединения после второго подключения, а использование `Drop` для `ThreadPool` начинает выполняться ещё тогда, когда как работник 3 даже не приступил к выполнению своей работы. Удаление `sender` отключает все рабочие потоки от потока и просит их завершить работу. Каждый рабочий поток при отключении выводит сообщение, а затем объединение потоков вызывает `join`, чтобы дождаться, пока каждый из рабочих потоков завершится.

Обратите внимание на одну важную особенность этого определенного запуска: ThreadPool удалил `sender`, и прежде чем какой-либо из работников получил ошибку, мы попытались присоединить (join) рабочий поток с номером 0. Рабочий поток 0 ещё не получил ошибку от `recv`, поэтому основной поток стал недоступен, ожидания завершения потока работника 0. Тем временем, работник 3 получил задание, а затем каждый из рабочих потоков получил ошибку. Когда рабочий поток 0 завершился, основной поток ждал окончания завершения выполнения остальных рабочих потоков. В это мгновение все они вышли из своих круговоротов и остановились.

Примите поздравления! Теперь мы завершили дело; у нас есть основной сетевой-отдельный вычислитель, использующий объединение потоков для не согласованных ответов. Мы можем выполнить правильное завершение работы отдельного вычислителя, очистив все потоки в объединении.

Вот полная рукопись для справки:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch20-web-server/no-listing-07-final-code/src/main.rs}}
```

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch20-web-server/no-listing-07-final-code/src/lib.rs}}
```

Мы могли бы сделать ещё больше! Если вы хотите продолжить совершенствование этого дела, вот несколько мыслей:

- Добавьте больше пособия в `ThreadPool` и его открытые способы.
- Добавьте проверки для возможностей, исполняемого библиотекой.
- Замените вызовы `unwrap` на более устойчивую обработку ошибок.
- Используйте `ThreadPool` для выполнения некоторых других задач, помимо обслуживания сетевых-запросов.
- На [crates.io](https://crates.io/) найдите ящик для работы с объединениями потоков и на его основе выполните подобный сетевой-отдельный вычислитель. Затем сравните его API и надёжность с выполненным нами объединением потоков.

## Итоги

Отличная работа! Вы сделали это к концу книги! Мы хотим поблагодарить вас за то, что присоединились к нам в этом путешествии по языку Ржавчина. Теперь вы готовы выполнить свои собственные дела на Ржавчине и помочь с делами другим людям. Имейте в виду, что сообщество Ржавчина разработчиков довольно гостеприимно, они с удовольствием постараются помочь вам с любыми трудностями, с которыми вы можете столкнуться в своём путешествии по Ржавчине.
