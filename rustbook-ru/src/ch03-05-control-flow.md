## Круговороты

Возможности запуска некоторой рукописи в зависимости от некоторого условия, и замкнутого выполнения некоторой рукописи, являются основными элементами в большинстве языков программирования. Наиболее распространёнными устройствами, позволяющими управлять потоком выполнения рукописи Ржавчины являются выражения `if` и круговороты.

### Выражения `if`

Выражение `if` позволяет выполнять части рукописи в зависимости от условий. Вы задаёте условие, а затем указываете: "Если это условие выполняется, выполните этот раздел рукописи. Если условие не выполняется, не выполняйте этот раздел рукописи".

Для изучения выражения `if` создайте новое дело под названием *branches* в папке *projects*. В файл <em>src/main.rs</em> поместите следующую рукопись:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-26-if-true/src/main.rs}}
```

Условие начинается с ключевого слова `if`, за которым следует условное выражение. В данном случае условное выражение проверяет, имеет ли переменная `number` значение меньше 5. Сразу после условного выражения внутри узорчатых скобок мы помещаем раздел рукописи, которая будет выполняться, если итог равен `true`. Разделы рукописи, связанные с условными выражениями, иногда называют *ветками*, как и ветки в выражениях `match`, которые мы обсуждали в разделе ["Сравнение догадки с тайным числом"](ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number) Главы 2.

Это необязательно, но мы также можем использовать ключевое слово `else`, которое мы используем в данном примере, чтобы предоставить программе иной раздел выполнения рукописи, выполняющийся если итог вычисления будет ложным. Если не указать выражение `else` и условие будет ложным, программа просто пропустит раздел`if` и перейдёт к следующему отрывку рукописи.

Попробуйте запустить эту рукопись. Появится следующий итог:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-26-if-true/output.txt}}
```

Попробуйте изменить значение `number` на значение, которое делает условие `false` и посмотрите, что произойдёт:

```rust,ignore
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-27-if-false/src/main.rs:here}}
```

Запустите программу снова и посмотрите на вывод:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-27-if-false/output.txt}}
```

Также стоит отметить, что условие в этой рукописи *должно* быть разумного вида данных `bool`. Если условие не является `bool`, возникнет ошибка. Например, попробуйте запустить следующую рукопись:

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-28-if-condition-must-be-bool/src/main.rs}}
```

На этот раз условие `if` вычисляется в значение `3`, и Ржавчина выводит ошибку:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-28-if-condition-must-be-bool/output.txt}}
```

Ошибка говорит, что Ржавчина ожидала вид данных `bool`, но получила значение целочисленного вида данных. В отличии от других языков вроде Ruby и JavaScript, Ржавчина не будет пытаться самостоятельно преобразовывать <em>неразумные</em> виды данных в разумные. Необходимо явно и всегда использовать `if` с разумным видом данных в качестве условия. Если нужно, чтобы раздел рукописи `if` запускался только, когда число не равно `0`, то, например, мы можем изменить выражение `if` на следующее:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-29-if-not-equal-0/src/main.rs}}
```

Будет выведена следующая строка `number was something other than zero`.

#### Обработка нескольких условий с помощью `else if`

Можно использовать несколько условий, сочетая `if` и `else` в выражении `else if`. Например:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-30-else-if/src/main.rs}}
```

У этой программы есть четыре возможных пути выполнения. После её запуска вы должны увидеть следующий итог:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-30-else-if/output.txt}}
```

Во время выполнения этой программы по очереди проверяется каждое выражение `if` и выполняются указания в первом разделе, для которого условие `true`. Заметьте, что хотя 6 делится на 2, мы не видим ни вывода `number is divisible by 2`, ни писания `number is not divisible by 4, 3, or 2` из раздела `else`. Так происходит потому, что Ржавчина выполняет указания в разделе только для первого истинного условия, а обнаружив его, даже не проверяет остальные.

Использование множества выражений `else if` приводит к загромождению рукописи, поэтому при наличии более чем одного выражения, возможно, стоит провести переработку рукописи. В главе 6 описано мощное средство ветвления Ржавчины для таких случаев, называемое `match`.

#### Использование `if` в указании `let`

Поскольку `if` является выражением, его можно использовать в правой части указания `let` для присвоения итога переменной, как в приложении 3-2.

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/listing-03-02/src/main.rs}}
```

<span class="caption">Приложение 3-2: Присвоение итога выражения <code>if</code> переменной</span>

Переменная `number` будет привязана к значению, которое является итогом выражения `if`. Запустим рукопись и посмотрим, что происходит:

```console
{{#include ../listings/ch03-common-programming-concepts/listing-03-02/output.txt}}
```

Вспомните, что разделы рукописи вычисляются последним выражением в них, а числа сами по себе также являются выражениями. В данном случае, значение всего выражения `if` зависит от того, какой раздел выполняется. При этом значения, которые могут быть итогами каждой из ветвей `if`, должны быть одного вида данных. В Приложении 3-2, итогами обеих ветвей `if` и `else` являются целочисленный вид данных `i32`. Если виды данных не совпадают, как в следующем примере, мы получим ошибку:

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-31-arms-must-return-same-type/src/main.rs}}
```

При попытке сборки этой рукописи, мы получим ошибку. Ветви `if` и `else` представляют несовместимые виды данных значений, и Ржавчина точно указывает, где искать неполадку в программе:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-31-arms-must-return-same-type/output.txt}}
```

Выражение в разделе `if` вычисляется как целочисленное, а выражение в разделе `else` вычисляется как строка. Это не сработает, потому что переменные должны иметь один вид данных, а Ржавчина должна знать во время сборки, какого вида данных переменная `number`. Зная вид данных `number`, сборщик может убедиться, что вид данных действителен везде, где мы используем `number`. Ржавчина не смогла бы этого сделать, если бы вид данных `number` определялся только во время выполнения. Сборщик усложнился бы и давал бы меньше заверений в отношении рукописи, если бы ему приходилось отслеживать несколько предполагаемых видов данных для любой переменной.

### Повторное выполнение рукописи с помощью круговоротов

Часто бывает полезно выполнить раздел рукописи более одного раза. Для этой задачи Ржавчина предоставляет несколько круговоротов, которые позволяют выполнить раздел рукописи  до конца, а затем сразу же вернуться в начало. Для опытов с круговоротами давайте создадим новое дело под названием *loops*.

В Ржавчине есть три вида круговоротов: `loop`, `while` и `for`. Давайте попробуем каждый из них.

#### Повторение выполнения рукописи с помощью `loop`

Ключевое слово `loop` говорит Ржавчине выполнять раздел рукописи снова и снова до бесконечности или пока не будет явно приказано остановиться.

В качестве примера, измените рукопись файла *src/main.rs* в папке дела *loops* на рукопись ниже:

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-32-loop/src/main.rs}}
```

Когда запустим эту программу, увидим, как `again!` выводится снова и снова, пока не остановить программу вручную. Большинство окон вызовов поддерживают сочетание клавиш <span class="keystroke">ctrl-c</span> для прерывания программы, которая застряла в непрерывном круговороте. Попробуйте:

<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-32-loop
cargo run
CTRL-C
-->

```console
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
```

Знак `^C` обозначает место, где было нажато <span class="keystroke">ctrl-c </span>. В зависимости от того, где находилась рукопись в круговороте в мгновение получения звонка от прерывания, вы можете увидеть или не увидеть слово `again!`, выведенное после `^C`.

К счастью, Ржавчина также предоставляет способ выйти из круговорота с помощью приказа. Ключевое слово `break` нужно поместить в круговорот, чтобы указать программе, когда следует прекратить выполнение круговорота. Напоминаем, мы делали так в игре "Угадайка" в разделе ["Выход после правильной догадки"](ch02-00-guessing-game-tutorial.html#quitting-after-a-correct-guess)<!-- ignore --> Главы 2, чтобы выйти из программы, когда пользователь выиграл игру, угадав правильное число.

Мы также использовали `continue` в игре "Угадайка", которое указывает программе в круговороте пропустить всю оставшуюся рукопись в данном повторении круговорота и перейти к следующему повторению.

#### Возвращение значений из круговоротов

Одно из применений `loop` - это повторение действия, которое может закончиться неудачей, например, проверка успешности выполнения потоком своего задания. Также может понадобиться передать из круговорота итог этого действия в остальную часть рукописи. Для этого можно добавить возвращаемое значение после выражения `break`, которое используется для остановки круговорота. Это значение будет возвращено из круговорота, и его можно будет использовать, как показано здесь:

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-33-return-value-from-loop/src/main.rs}}
```

Перед круговоротом мы объявляем переменную с именем `counter` и объявим её значением `0`. Затем мы объявляем переменную с именем `result` для хранения значения, возвращаемого из круговорота. На каждом повторении круговорота мы добавляем `1` к переменной `counter`, а затем проверяем, равняется ли `10` переменная `counter`. Когда это происходит, мы используем ключевое слово `break` со значением `counter * 2`. После круговорота мы ставим точку с запятой для завершения указания, присваивающей значение `result`. Наконец, мы выводим значение в `result`, равное в данном случае 20.

#### Метки круговоротов для устранения неоднозначности между несколькими круговоротами

Если у вас есть круговороты внутри круговоротов, `break` и `continue` применяются к самому внутреннему круговороту в этой цепочке. При желании вы можете создать *метку круговорота*, которую вы затем сможете использовать с `break` или `continue` для указания, что эти ключевые слова применяются к помеченному круговороту, а не к самому внутреннему круговороту. Метки круговорота должны начинаться с одинарной кавычки. Вот пример с двумя вложенными круговоротами:

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-32-5-loop-labels/src/main.rs}}
```

Внешний круговорот имеет метку `'counting_up`, и он будет считать от 0 до 2. Внутренний круговорот без метки ведёт обратный отсчёт от 10 до 9. Первый `break`, который не содержит метку, выйдет только из внутреннего круговорота. Указание `break 'counting_up;` завершит внешний круговорот. Эта рукопись выведет:

```console
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-32-5-loop-labels/output.txt}}
```

#### Круговороты с условием `while`

В программе часто требуется проверить состояние условия в круговороте. Пока условие истинно, круговорот выполняется. Когда условие перестаёт быть истинным, программа вызывает `break`, останавливая круговорот. Такое поведение можно выполнить с помощью сочетания `loop`, `if`, `else` и `break`. При желании попробуйте сделать это в программе. Это настолько распространённый образец, что в Ржавчине имеется встроенный круговорот `while`. В приложении 3-3 мы используем `while`, чтобы выполнить три круговорота программы, производя каждый раз обратный отсчёт, а затем, после завершения круговорота, выводим                                                                                                                                                                                                                                                                                                            сообщение и выходим.

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/listing-03-03/src/main.rs}}
```

<span class="caption">Приложение 3-3: Использование круговорота <code>while</code> для выполнения рукописи, пока условие истинно</span>

В данном исполнении круговорота while возможно существенно сократить размер рукописи, который потребовался бы при использовании круговоротов `loop`, `if`, `else` и `break`, и оно более понятно. Пока условие вычисляется в `true`, рукопись выполняется; в противном случае происходит выход из круговорота.

#### Круговорот по переменным собрания с помощью `for`<a id="looping-through-a-collection-with-for"></a>

Для перебора переменных собрания, например, массива, можно использовать круговорот `while`. Например, круговорот в приложении 3-4 выводит каждая переменная массива `a`.

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/listing-03-04/src/main.rs}}
```

<span class="caption">Приложение 3-4: Перебор каждой переменной собрания с помощью круговорота <code>while</code></span>

Эта рукопись использует перебор переменных массива. Он начинается с порядкового указателя `0`, а затем замкнуто выполняется, пока не достигнет последнего порядкового указателя в массиве (то есть, когда `index < 5` уже не является истиной). Выполнение этой рукописи выведет каждая переменная массива:

```console
{{#include ../listings/ch03-common-programming-concepts/listing-03-04/output.txt}}
```

Все пять значений массива появляются в окне вызова, как и ожидалось. Поскольку `index` в какое-то мгновение достигнет значения `5`, круговорот прекратит выполнение перед попыткой извлечь шестое значение из массива.

Однако такой подход чреват ошибками; мы можем вызвать сбой в программе, если значение порядкового указателя или условие проверки неверны. Например, если изменить определение массива `a` на четыре элемента, но забыть обновить условие на `while index < 4`, рукопись вызовет сбой. Также это медленно, поскольку сборщик добавляет в рукопись вычисление значения времени выполнения для обеспечения проверки нахождения порядкового указателя в границах массива на каждом повторении круговорота.

В качестве более краткого иного решения можно использовать круговорот `for` и выполнять некоторую рукопись для каждой переменной собрания. Круговорот `for` может выглядеть как рукопись в приложении 3-5.

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/listing-03-05/src/main.rs}}
```

<span class="caption">Приложение 3-5: Перебор каждой переменной собрания с помощью круговорота <code>for</code></span>

При выполнении этой рукописи мы увидим тот же итог, что и в приложении 3-4. Что важнее, теперь мы повысили безопасность рукописи и устранили вероятность ошибок, которые могут возникнуть в итоге выхода за пределы массива или недостаточно далёкого перехода и пропуска некоторых переменных.

При использовании круговорота `for` не нужно помнить о внесении изменений в другую рукопись, в случае изменения количества значений в массиве, как это было бы со способом, использованным в приложении 3-4.

Безопасность и краткость круговоротов `for` делают их наиболее часто используемым круговоротом в Ржавчине. Даже в случаях необходимости выполнения некоторой рукописи определённое количество раз, как в примере обратного отсчёта, в котором использовался круговорот `while` из Приложения 3-3, большинство Rustaceans использовали бы круговорот `for`. Для этого можно использовать `Range`, предоставляемый встроенной библиотекой, который порождает последовательность всех чисел, начиная с первого числа и заканчивая вторым числом, но не включая его (т.е. `(1..4)` равнозначно `[1, 2, 3]` или в общем случае `(start..end)` равнозначно `[start, start+1, start+2, ... , end-2, end-1]` - прим.переводчика).

Вот как будет выглядеть обратный отсчёт с использованием круговорота `for` и другого способа, о котором мы ещё не говорили, `rev`, для разворота ряда:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-34-for-range/src/main.rs}}
```

Данная рукопись выглядит лучше, не так ли?

## Итоги

Вы справились! Это была большая глава: вы узнали о переменных, одиночных и составных видах данных, функциях, примечаниях, выражениях `if` и круговоротах! Для опытов работы со средствами, обсуждаемыми в этой главе, попробуйте создать программы для выполнения следующих действий:

- Преобразование температур между значениями по Фаренгейту к Цельсию.
- Порождение n-го числа Фибоначчи.
- Выведите писание рождественской песни "Двенадцать дней Рождества", воспользовавшись повторами в песне.

Когда вы будете готовы двигаться дальше, мы поговорим о подходах в Ржавчине, которые *не существуют* обычно в других языках программирования: владение.
