## Исправимые ошибки с `Result`

Многие ошибки являются не настолько критичными, чтобы останавливать выполнение программы. Иногда, когда в функции происходит сбой, необходима просто правильная интерпретация и обработка ошибки. К примеру, при попытке открыть файл может произойти ошибка из-за отсутствия файла. Вы, возможно, захотите исправить ситуацию и создать новый файл вместо остановки программы.

Вспомните раздел ["Обработка потенциального сбоя с помощью типа `Result`"]<!-- ignore --> главы 2: мы использовали там перечисление `Result`, имеющее два варианта, `Ok` и `Err` для обработки сбоев. Само перечисление определено следующим образом:

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

Типы `T` и `E` являются параметрами обобщённого типа: мы обсудим обобщённые типы более подробно в Главе 10. Все что вам нужно знать прямо сейчас - это то, что `T` представляет тип значения, которое будет возвращено в случае успеха внутри варианта `Ok`, а `E` представляет тип ошибки, которая будет возвращена при сбое внутри варианта `Err`. Так как тип `Result` имеет эти типовые параметры (generic type parameters), мы можем использовать тип `Result` и его методы, которые определены в стандартной библиотеке, в ситуациях, когда тип успешного значения и значения ошибки, которые мы хотим вернуть, отличаются.

Давайте вызовем функцию, которая возвращает значение `Result`, потому что может потерпеть неудачу. В листинге 9-3 мы пытаемся открыть файл.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-03/src/main.rs}}
```

<span class="caption">Листинг 9-3: Открытие файла</span>

Откуда мы знаем, что `File::open` возвращает `Result`? Мы могли бы посмотреть [документацию по API стандартной библиотеки ](../std/index.html) <!--  --> или мы могли бы спросить компилятор! Если мы припишем переменной `f` тип, *отличный* от возвращаемого типа функции, а затем попытаемся скомпилировать код, компилятор скажет нам, что типы не совпадают. Сообщение об ошибке подскажет нам, каким *должен быть* тип `f`. Давайте попробуем! Мы знаем, что возвращаемый тип `File::open` не является типом `u32`, поэтому давайте изменим выражение `let f` на следующее:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-02-ask-compiler-for-type/src/main.rs:here}}
```

Попытка компиляции выводит сообщение:

```console
{{#include ../listings/ch09-error-handling/no-listing-02-ask-compiler-for-type/output.txt}}
```

Ошибка говорит нам о том, что возвращаемым типом функции `File::open` является `Result<T, E>`. Типовой параметр `T` здесь равен типу успешного выполнения, `std::fs::File`, то есть дескриптору файла. Тип `E`, используемый в значении ошибки, равен `std::io::Error`.

Этот возвращаемый тип означает, что вызов `File::open` может завершиться успешно и вернуть дескриптор файла, с помощью которого можно читать из файла или писать в него. Вызов функции также может завершиться ошибкой: например, файла может не существовать или у нас может не быть прав на доступ к нему. Функция `File::open` должна иметь способ сообщить нам, был ли её вызов успешен или потерпел неудачу и одновременно возвратить либо дескриптор файла либо информацию об ошибке. Эта информация - именно то, что возвращает перечисление `Result`.

Когда вызов `File::open` успешен, значение в переменной `f` будет экземпляром `Ok`, внутри которого содержится дескриптор файла. Если вызов не успешный, значением переменной `f` будет экземпляр `Err`, который содержит больше информации о том, какая ошибка произошла.

Необходимо дописать в код листинга 9-3 выполнение разных действий в зависимости от значения, которое вернёт вызов `File::open`. Листинг 9-4 показывает один из способов обработки `Result` - пользуясь базовым инструментом языка, таким как выражение `match`, рассмотренным в Главе 6.

<span class="filename">Файл: src/main.rs</span>

```rust,should_panic
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-04/src/main.rs}}
```

<span class="caption">Листинг 9-4: Использование выражения <code>match</code> для обработки возвращаемых вариантов типа <code>Result</code></span>

Обратите внимание, что также как перечисление `Option`, перечисление `Result` и его варианты, входят в область видимости благодаря авто-импорту (prelude), поэтому не нужно указывать `Result::` перед использованием вариантов `Ok` и `Err` в ветках выражения `match`.

Здесь мы говорим Rust, что когда результат - это `Ok`, то надо вернуть внутреннее значение `file` из варианта `Ok`, и затем мы присваиваем это значение дескриптора файла переменной `f`. После `match` мы можем использовать дескриптор файла для чтения или записи.

Другая ветвь `match` обрабатывает случай, где мы получаем значение `Err` после вызова `File::open`. В этом примере мы решили вызвать макрос `panic!`. Если в нашей текущей директории нет файла с именем *hello.txt* и мы выполним этот код, то мы увидим следующее сообщение от макроса `panic!`:

```console
{{#include ../listings/ch09-error-handling/listing-09-04/output.txt}}
```

Как обычно, данное сообщение точно говорит, что пошло не так.

### Обработка различных ошибок с помощью match

Код в листинге 9-4 будет вызывать `panic!` независимо от того, почему вызов `File::open` не удался. Мы бы хотели предпринять различные действия для разных причин сбоя. Если открытие `File::open` не удалось из-за отсутствия файла, мы хотим создать файл и вернуть его дескриптор. Если вызов `File::open` не удался по любой другой причине (например, потому что у нас не было прав на открытие файла), то мы хотим вызвать `panic!` как у нас сделано в листинге 9-4. Посмотрите листинг 9-5, в котором мы добавили дополнительное внутреннее выражение `match`.

<span class="filename">Файл: src/main.rs</span>

<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->

```rust,ignore
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-05/src/main.rs}}
```

<span class="caption">Листинг 9-5: Обработка различных ошибок разными способами</span>

Типом значения возвращаемого функцией `File::open` внутри `Err` варианта является `io::Error`, структура из стандартной библиотеки. Данная структура имеет метод `kind`, который можно вызвать для получения значения `io::ErrorKind`. Перечисление `io::ErrorKind` из стандартной библиотеки имеет варианты, представляющие различные типы ошибок, которые могут появиться при выполнении операций в `io` (крейте который занимается проблемами ввода/вывода данных). Вариант, который мы хотим использовать, это `ErrorKind::NotFound`. Он даёт информацию, о том, что файл который мы пытаемся открыть ещё не существует. Итак, во второй строке мы вызываем сопоставление шаблона с переменной `f` и попадаем в ветку с обработкой ошибки, но также у нас есть внутренняя проверка для сопоставления `error.kind()` ошибки.

Условие, которое мы хотим проверить во внутреннем `match`, заключается в том, является ли значение, возвращаемое `error.kind()`, вариантом `NotFound` перечисления `ErrorKind`. Если это так, мы пытаемся создать файл с помощью функции `File::create`. Однако, поскольку вызов `File::create` тоже может завершиться ошибкой, нам нужна обработка ещё одной ошибки, теперь уже во внутреннем выражении `match`. Заметьте: если файл не может быть создан, выводится другое, специализированное сообщение об ошибке. Вторая же ветка внешнего `match` (который обрабатывает вызов `error.kind()`), остаётся той же самой - в итоге программа паникует при любой ошибке, кроме ошибки отсутствия файла.

> ### Альтернативы использованию `match` с `Result<T, E>`
>
> Как много `match`! Выражение `match` является очень полезным, но в то же время довольно примитивным. 
> В главе 13 вы узнаете о замыканиях (closures), которые используются во многих методах типа `Result<T, E>`. 
> Эти методы помогают быть более лаконичными, чем использование `match` при работе со значениями `Result<T, E>` в вашем коде.
>
> Например, вот другой способ написать ту же логику, что показана в Листинге
> 9-5, но с использованием замыканий и метода `unwrap_or_else`:
>
> <!-- НЕВОЗМОЖНО ИЗВЛЕЧЬ, СМ. https://github.com/rust-lang/mdBook/issues/1127 -->
>
> ```rust,ignore
> use std::fs::File;
> use std::io::ErrorKind;
>
> fn main() {
>     let f = File::open("hello.txt").unwrap_or_else(|error| {
>         if error.kind() == ErrorKind::NotFound {
>             File::create("hello.txt").unwrap_or_else(|error| {
>                 panic!("Problem creating the file: {:?}", error);
>             })
>         } else {
>             panic!("Problem opening the file: {:?}", error);
>         }
>     });
> }
> ```
>
> Хотя этот код ведёт себя так же, что и в листинге 9-5, он не содержит
> никаких выражений `match` и его легче читать. Вернитесь к этому примеру
> после прочтения главы 13 и поищите метод `unwrap_or_else` в
> документации по стандартной библиотеке. Многие другие из этих методов могут очистить огромные
> вложенные выражения `match`, когда вы имеете дело с ошибками.

### Сокращённые способы обработки ошибок `unwrap` и `expect`

Использование `match` работает достаточно хорошо, но может быть довольно многословным и не всегда хорошо передаёт смысл. Тип `Result<T, E>` имеет множество вспомогательных методов определенных для выполнения различных, более специфических задач. Метод `unwrap` - это метод быстрого доступа, реализованный так же, как и выражение `match`, которое мы написали в Листинг 9-4. Если значение `Result` является вариантом `Ok`, `unwrap` возвращает значение внутри `Ok`. Если `Result` - вариант `Err`, то `unwrap` вызовет для нас макрос `panic!`. Вот пример `unwrap` в действии:

<span class="filename">Файл: src/main.rs</span>

```rust,should_panic
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-04-unwrap/src/main.rs}}
```

Если мы запустим этот код при отсутствии файла *hello.txt* , то увидим сообщение об ошибке из вызова `panic!` метода `unwrap` :

```text
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: "No such file or directory" } }',
src/libcore/result.rs:906:4
```

Другой метод, похожий на `unwrap`, это `expect`, позволяющий выбрать сообщение об ошибке для макроса `panic!`. Использование `expect` вместо `unwrap` с предоставлением хорошего сообщения об ошибке выражает ваше намерение и делает более простым отслеживание источника паники. Синтаксис метода `expect` выглядит так:

<span class="filename">Файл: src/main.rs</span>

```rust,should_panic
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-05-expect/src/main.rs}}
```

Мы используем `expect` таким же образом, как и `unwrap`: чтобы вернуть дескриптор файла или вызвать макрос `panic!`. Сообщением об ошибке, которое `expect` передаст в `panic!`, будет параметр функции `expect`, а не значение по умолчанию, используемое `unwrap`. Вот как оно выглядит:

```text
thread 'main' panicked at 'Failed to open hello.txt: Error { repr: Os { code:
2, message: "No such file or directory" } }', src/libcore/result.rs:906:4
```

Так как сообщение об ошибке начинается с нашего пользовательского текста: `Failed to open hello.txt`, то потом будет проще найти из какого места в коде данное сообщение приходит. Если использовать `unwrap` во множестве мест, то придётся потратить время для выяснения какой именно вызов `unwrap` вызывает "панику", так как все вызовы  <code>unwrap</code> генерируют одинаковое сообщение.

### Проброс ошибок

Когда вы пишете функцию, реализация которой вызывает что-то, что может завершиться ошибкой, вместо обработки ошибки в этой функции, вы можете вернуть ошибку в вызывающий код, чтобы он мог решить, что с ней делать. Такой приём известен как *распространение ошибки, propagating the error*. Благодаря нему мы даём больше контроля вызывающему коду, где может быть больше информации или логики, которая диктует, как ошибка должна обрабатываться, чем было бы в месте появления этой ошибки.

Например, код программы 9-6 читает имя пользователя из файла. Если файл не существует или не может быть прочтён, то функция возвращает ошибку в код, который вызвал данную функцию:

<span class="filename">Файл: src/main.rs</span>

<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->

```rust
{{#include ../listings/ch09-error-handling/listing-09-06/src/main.rs:here}}
```

<span class="caption">Листинг 9-6: Функция, которая возвращает ошибки в вызывающий код, используя оператор <code>match</code></span>

Данную функцию можно записать гораздо короче. Чтобы больше проникнуться обработкой ошибок, мы сначала сделаем многое самостоятельно, а в конце покажем более короткий способ. Давайте сначала рассмотрим тип возвращаемого значения: `Result<String, io::Error>`. Здесь есть возвращаемое значение функции типа `Result<T, E>` где шаблонный параметр `T` был заполнен конкретным типом `String` и шаблонный параметр `E` был заполнен конкретным типом `io::Error`. Если эта функция выполнится успешно, будет возвращено `Ok`, содержащее значение типа `String` - имя пользователя прочитанное функцией из файла. Если же при чтении файла будут какие-либо проблемы, то вызываемый код получит значение `Err` с экземпляром `io::Error`, в котором содержится больше информации об ошибке. Мы выбрали `io::Error` в качестве возвращаемого значения функции, потому что обе операции, которые мы вызываем внутри этой функции, возвращают этот тип ошибки: функция `File::open` и метод `read_to_string`.

Тело функции начинается с вызова `File::open`. Затем мы обрабатываем значение `Result` возвращённое с помощью `match` аналогично коду `match` листинга 9-4, но вместо вызова `panic!` для случая `Err` делаем ранний возврат из данной функции и передаём ошибку из `File::open` обратно в вызывающий код, как ошибку уже текущей функции. Если `File::open` выполнится успешно, мы сохраняем дескриптор файла в переменной `f` и выполнение продолжается далее.

Затем мы создаём новую `String` в переменной `s` и вызываем метод `read_to_string` у дескриптора файла в переменной `f`, чтобы считать содержимое файла в переменную `s`. Метод `read_to_string` также возвращает `Result`, потому что он может потерпеть неудачу, даже если `File::open` пройдёт успешно. Таким образом, нам нужно ещё одно выражение `match`, чтобы справиться с этим `Result`: если `read_to_string` выполнится успешно, то наша функция завершится успешно и мы вернём имя пользователя из файла, которое сейчас находится в `s`, завёрнутым в `Ok`. Если вызов `read_to_string` не успешен, мы возвращаем значение ошибки так же, как мы вернули значение ошибки в `match`, обработавшем возвращаемое значение `File::open`. Тем не менее, нам не нужно явно писать `return`, потому что это последнее выражение в функции.

Код, вызывающий данный код, будет обрабатывать либо значение `Ok`, содержащее имя пользователя, либо значение `Err`, содержащее `io::Error`. Мы не знаем, что будет делать вызывающий код с этими значениями. Если вызывающий код получает значение `Err`, он может вызвать `panic!` и завершить программу, использовать имя пользователя по умолчанию, или например, попытается получить имя пользователя из какого-то другого места. У нас недостаточно информации о том, чего пытается достичь вызывающий код, поэтому мы пробрасываем всю информацию об успехе или ошибке наверх для её правильной обработки.

Такая схема распространения ошибок настолько распространена в Rust, что Rust предоставляет оператор вопросительный знак `?` для простоты.

#### Сокращение для проброса ошибок: оператор `?`

Код программы 9-6 показывает реализацию функции `read_username_from_file`, функционал которой аналогичен коду программы 9-5, но реализация использует оператор `?` :

<span class="filename">Файл: src/main.rs</span>

<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->

```rust
{{#include ../listings/ch09-error-handling/listing-09-07/src/main.rs:here}}
```

<span class="caption">Листинг 9-7: Функция, которая возвращает ошибки в вызывающий код, используя оператор <code>?</code></span>

Оператор `?`, помещаемый после значения типа `Result`, работает почти таким же образом, как выражение `match`, которое мы определили для обработки значений типа `Result` в листинге 9-6. Если значение `Result` равно `Ok`, значение внутри `Ok` будет возвращено из этого выражения и программа продолжит выполнение. Если значение является `Err`, то `Err` будет возвращено из всей функции, как если бы мы использовали ключевое слово `return`, таким образом ошибка передаётся в вызывающий код.

Имеется разница между тем, что делает выражение `match` листинга 9-6 и оператор `?`. Ошибочные значения при выполнении методов с оператором `?` возвращаются через функцию `from`, определённую в типаже `From` стандартной библиотеки. Данный типаж используется для конвертирования ошибок одного типа в ошибки другого типа. Когда оператор `?` вызывает функцию `from`, то полученный тип ошибки конвертируется в тип ошибки, который определён для возврата в текущей функции. Это удобно, когда функция возвращает один тип ошибки для представления всех возможных вариантов, из-за которых она может не завершиться успешно, даже если части кода функции могут не выполниться по разным причинам. Если каждый тип ошибки реализует функцию `from` определяя, как конвертировать себя в возвращаемый тип ошибки, то оператор `?` позаботится об этой конвертации автоматически.

В коде примера 9-7 оператор `?` в конце вызова функции `File::open` возвращает значения содержимого `Ok` в переменную `f`. Если же в при работе этой функции произошла ошибка, оператор `?` произведёт ранний возврат из функции со значением `Err`. То же касается `?` на конце вызова `read_to_string`.

Использование оператора `?` позволят уменьшить количество строк кода и сделать реализацию проще. Написанный в предыдущем примере код можно<br>сделать ещё короче с помощью сокращения промежуточных переменных и конвейерного вызова нескольких методов подряд, как показано в листинге 9-8:

<span class="filename">Файл: src/main.rs</span>

<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->

```rust
{{#include ../listings/ch09-error-handling/listing-09-08/src/main.rs:here}}
```

<span class="caption">Листинг 9-8. Цепочка вызовов методов после оператора <code>?</code></span>

Мы перенесли в начало функции создание новой переменной `s` типа `String`; эта часть не изменилась. Вместо создания переменной `f` мы добавили вызов `read_to_string` непосредственно к результату `File::open("hello.txt")?`, У нас ещё есть `?` в конце вызова `read_to_string`, и мы по-прежнему возвращаем значение `Ok`, содержащее имя пользователя в `s` когда оба метода: `File::open` и `read_to_string` успешны, а не возвращают ошибки. Функциональность снова такая же, как в листинге 9-6 и листинге 9-7; это просто другой, более эргономичный способ решения той же задачи.

Продолжая рассматривать разные способы записи данной функции, листинг 9-9 показывает способ сделать её ещё короче.

<span class="filename">Файл: src/main.rs</span>

<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->

```rust
{{#include ../listings/ch09-error-handling/listing-09-09/src/main.rs:here}}
```

<span class="caption">Листинг 9-9: Использование <code>fs::read_to_string</code> вместо открытия и чтения файла</span>

Чтение файла в строку довольно распространённая операция, так что Rust предоставляет удобную функцию `fs::read_to_string`, которая открывает файл, создаёт новую `String`, читает содержимое файла, размещает его в `String` и возвращает её. Конечно, использование функции `fs::read_to_string` не даёт возможности объяснить обработку всех ошибок, поэтому мы сначала изучили длинный способ.

#### Где можно использовать оператор `?`

Оператор `?` может использоваться только в функциях, возвращаемый тип которых совместим со значением, для которого используется оператор `?`. Это происходит потому, что оператор `?` предназначен для раннего возврата значения из функции, точно так же, как выражение `match`, которое мы определили в листинге 9-6. В листинге 9-6 выражение `match` использовало значение `Result`, а оператор раннего возврата возвращал значение `Err(e)` значение. Возвращаемый тип функции должен быть `Result`, чтобы он был совместим с этим `return`.

Давайте посмотрим в листинге 9-10, какую ошибку мы получим, если используем оператор `?` в функции `main` с возвращаемым типом, несовместимым с типом значения для которого мы используем `?`::

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-10/src/main.rs}}
```

<span class="caption">Листинг 9-10: При попытке использовать `?` в функции `main`, которая возвращает `()`, код не компилируется</span>

Этот код открывает файл, что может привести к ошибке. Оператор `?` следует сразу за значением `Result`, возвращаемым `File::open`, но у самой функции `main` возвращаемый тип `()`, а не `Result`. Когда мы попробуем скомпилировать этот код, то получим следующее сообщение об ошибке:

```console
{{#include ../listings/ch09-error-handling/listing-09-10/output.txt}}
```

Эта ошибка указывает на то, что оператор `?` разрешено использовать только в функции, которая возвращает `Result`, `Option` или другой тип, который реализует `FromResidual`. Чтобы исправить ошибку, у вас есть два варианта. Первый вариант - изменить возвращаемый тип вашей функции, чтобы он был совместим со значением, для которого вы используете оператор `?`, если у вас нет ограничений, препятствующих этому. Второй заключается в использовании `match` или одного из методов `Result<T, E>` для обработки `Result<T, E>` любым подходящим способом.

В сообщении об ошибке также упоминается, что `?` можно использовать и со значениями `Option<T>`. Как и в случае использования `?` с `Result`, вы можете использовать `?` с `Option` только в функции, которая возвращает значение `Option`. Поведение оператора `?` при вызове на `Option<T>` аналогично его поведению при вызове на `Result<T, E>`: если значение равно `None`, то `None` тут же будет возвращено из функции. Если значение равно `Some`, то значение внутри `Some` будет результирующим значением выражения и функция продолжится. В листинге 9-11 приведен пример функции, которая находит последний символ первой строки в заданном тексте:

```rust
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-11/src/main.rs:here}}
```

<span class="caption">Листинг 9-11: Использование оператора `?` с `Option<T>`</span>


Эта функция возвращает `Option<char>`, потому что может быть там находится символ, но также возможно, что его нет. Этот код принимает аргумент аргумент строковый фрагмент `text` и вызывает его метод `lines`, который возвращает итератор по строкам в тексте. Поскольку эта функция хочет просмотреть первую строку, она вызывает `next` на итераторе, чтобы получить первое значение из итератора. Если `text` - пустая строка, то вызов `next` вернет `None`, и в этом случае мы используем `?`, чтобы остановить и вернуть `None` от `last_char_of_first_line`. Если `text` не является пустой строкой, `next` будет возвращает значение `Some`, содержащее строковый фрагмент первой строки в `text`.

Символ `?` извлекает фрагмент строки, и мы можем вызвать `chars` для этого фрагмента строки. чтобы получить итератор символов. Нас интересует последний символ в первой строке, поэтому мы вызываем `last`, чтобы вернуть последний элемент в итераторе. Это `Option`, потому что возможно, что первая строка пустая. например, если `text` начинается с пустой строки, но имеет символы на в других строках, как в `"\nhi"`. Однако, если в первой строке есть последний символ, он будет возвращен в варианте `Some`. Оператор `?` в середине дает нам лаконичный способ выразить эту логику, позволяя реализовать функцию в одной строке. Если бы мы не могли использовать оператор `?` в `Option`, нам пришлось бы пришлось бы реализовать эту логику, используя больше вызовов методов или выражение `match`.
    
Обратите внимание, что вы можете использовать оператор `?` на `Result` в функции, которая возвращает `Result`, и вы можете использовать оператор `?` на `Option` в функции, которая возвращает `Option`, но вы не можете смешивать и сочетать их. Оператор `?` не будет автоматически преобразовывать `Result` в `Option` или наоборот; в этих случаях, вы можете использовать такие методы, как метод `ok` для `Result` или метод `ok_or` для `Option` для явного преобразования.

До сих пор все функции `main`, которые мы использовали, возвращали `()`. Функция `main` особенная, потому что она является точкой входа и выхода исполняемых программ, и существуют ограничения на то, каким может быть ее возвращаемый тип, чтобы программы вели себя так, как ожидается.

К счастью, `main` может также возвращать `Result<(), E>`. Листинг 9-12 содержит код из листинга 9-10, но мы изменили тип возврата `main` на `Result<(), Box<dyn Error>> и добавили возвращаемое значение `Ok(())` в конец. Теперь этот код успешно скомпилируется:
    
```rust,ignore
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-12/src/main.rs}}
```

<span class="caption">Листинг 9-12: Изменив возвращаемое значение в `main` на `Result<(), E>`, можно использовать оператор `?` для значений `Result`.</span>

Тип `Box<dyn Error>` является *объектом-типажом*, о котором мы поговорим в разделе ["Использование типаж объектов, которые допускают значения различных типов"][объекты-характеристики]<!-- ignore --> в главе 17. Пока что вы можете считать `Box<dyn Error>` "любым видом ошибки". Использование `?` для `Result` в функции `main` с типом ошибки `Box<dyn Error>` разрешено, поскольку это позволяет вернуть любое значение `Err` раньше времени.

Когда функция `main` возвращает `Result<(), E>`: выполнение программы завершится со значением `0`, если `main` вернет `Ok(())`; завершится с ненулевым значением, если `main` вернёт значение `Err`. Исполняемые программы, написанные на языке C, возвращают целые числа при выходе - программы, которые завершаются успешно, возвращают целое число `0`, а программы завершившиеся ошибкой возвращают любое целое число, отличное от `0`. Rust также возвращает целые числа от исполняемых программ, чтобы быть совместимым с этим соглашением.

Функция `main` может возвращать любые типы, реализующие типаж [`std::process::Termination`][прекращение]<!-- ignore -->. На момент написания этой статьи, характеристика `Termination` является нестабильной, доступной только в Nightly версии Rust, поэтому, пока, вы не cможете реализовать её для своих типов в Stable Rust, но, возможно, когда-нибудь вы это сделаете!

Теперь, когда мы обсудили детали вызова `panic!` или возврата `Result`, давайте вернемся к вопросу того, как решить, что из них уместнее использовать в тех или иных случаях.

["Обработка потенциального сбоя с помощью типа `Result`"]: ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type
[объекты-характеристики]: ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
[прекращение]: ../std/process/trait.Termination.html
