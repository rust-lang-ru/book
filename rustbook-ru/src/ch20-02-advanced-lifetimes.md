## Расширенные измененители времени жизни (МВЖ) (Lifetimes)

В главе 10 мы изучили как определять ссылку с помощью МВЖ для
помощи сборщику понять какие взаимосвязи существуют между данными. В этом разделе мы рассмотрим ещё не освященные возможности МВЖ:  *подвиды*, *границы* и *предметы-сущности*.

### Подвиды

Представьте, что мы хотим использовать письменный оценщик (parser). Для этого необходимо создать стопку, образцы которой будут хранить ссылки на строку, которую мы рассматриваем. Назовём эту стопку `Context`. Мы создадим оценщик, который будет рассматривать эту строку и возвращать значение успеха или неудачи. Оценщику необходимо заимствовать строку для оценки. Выполнение может быть похожа на рукопись
19-12, который не собирается, т.к. мы не указали МВЖ:

```rust,ignore
struct Context(&str);

struct Parser {
    context: &Context,
}

impl Parser {
    fn parse(&self) -> Result<(), &str> {
        Err(&self.context.0[1..])
    }
}
```

<span class="caption">рукопись 19-12: определение стопки `Context`, которая содержит
строковый срез. Стопка `Parser` содержит ссылку на образец данных `Context`. Способ
`parse` всегда возвращает ошибку со ссылкой на строковый срез</span>

Для простоты функция `parse`  возвращается `Result<(), &str>`. Поэтому мы ничего
не делаем для успешной работы и при ошибке возвращаем часть строки, которая не смогла
быть обработана. Существующие функции такого рода должны содержать больше сведений.

Как же записать МВЖ для строкового среза в `Context` и ссылку в `Parser`? Очевидным
решением является использование МВЖ везде:

```rust
struct Context<'a>(&'a str);

struct Parser<'a> {
    context: &'a Context<'a>,
}

impl<'a> Parser<'a> {
    fn parse(&self) -> Result<(), &str> {
        Err(&self.context.0[1..])
    }
}
```

<span class="caption">рукопись 19-13: определение ссылок в `Context` и `Parser`</span>

Эта рукопись собирается. Следующая рукопись (19-14) объявляет функцию, которая получает входное свойство `Context` и использует `Parser` для оценки писания.

```rust,ignore
fn parse_context(context: Context) -> Result<(), &str> {
    Parser { context: &context }.parse()
}
```

<span class="caption">Listing 19-14: попытка добавить функцию `parse_context`,
которая получает `Context` и использует `Parser`</span>

При попытке сборки мы получаем две хорошо описанные ошибки:

```text
error: borrowed value does not live long enough
  --> <anon>:16:5
   |
16 |     Parser { context: &context }.parse()
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ does not live long enough
17 | }
   | - temporary value only lives until here
   |
note: borrowed value must be valid for the anonymous lifetime #1 defined on the
body at 15:55...
  --> <anon>:15:56
   |
15 |   fn parse_context(context: Context) -> Result<(), &str> {
   |  ________________________________________________________^
16 | |     Parser { context: &context }.parse()
17 | | }
   | |_^

error: `context` does not live long enough
  --> <anon>:16:24
   |
16 |     Parser { context: &context }.parse()
   |                        ^^^^^^^ does not live long enough
17 | }
   | - borrowed value only lives until here
   |
note: borrowed value must be valid for the anonymous lifetime #1 defined on the
body at 15:55...
  --> <anon>:15:56
   |
15 |   fn parse_context(context: Context) -> Result<(), &str> {
   |  ________________________________________________________^
16 | |     Parser { context: &context }.parse()
17 | | }
   | |_^
```

Эти ошибки говорят, что время жизни `Parser`, который мы создаём и свойства способа
заканчивается после завершения работы функции. Но они должны продолжать жить далее.

Т.е. `Parser` и `context` должны пережить ( *outlive* ) завершение функции и
быть действительными после.

Давайте рассмотрим определение функции `parse` в 19-13 снова. Обратим внимание на
ярлык способа:

```rust,ignore
    fn parse(&self) -> Result<(), &str> {
```

Напомним, что при использовании ПВЖ описание должно иметь вид:

```rust,ignore
    fn parse<'a>(&'a self) -> Result<(), &'a str> {
```

Неполадка этой функции в том, что время жизни образца данных `Parser` заканчивается после
завершения функции и время жизни свойства также.

Необходимо описать время жизни таким образом, чтобы срез в `Context` и ссылка в
`Parser` имели бы разные времена жизни и возвращаемое значение было связано с временем
жизни среза.

Мы можем попытаться дать `Parser` и `Context` различные свойства времени жизни.
К сожалению, это решение не решит полностью неполадку, но это всё же правильный путь
на пути к решению:

```rust,ignore
struct Context<'s>(&'s str);

struct Parser<'c, 's> {
    context: &'c Context<'s>,
}

impl<'c, 's> Parser<'c, 's> {
    fn parse(&self) -> Result<(), &'s str> {
        Err(&self.context.0[1..])
    }
}

fn parse_context(context: Context) -> Result<(), &str> {
    Parser { context: &context }.parse()
}
```

<span class="caption">рукопись 19-15: определение различных переменных времени жизни</span>


We’ve annotated the lifetimes of the references in all the same places that we
annotated them in Listing 19-13, but used different parameters depending on
whether the reference goes with the string slice or with `Context`. We’ve also
added an annotation to the string slice part of the return value of `parse` to
indicate that it goes with the lifetime of the string slice in `Context`.

Here’s the error we get now:

```text
error[E0491]: in type `&'c Context<'s>`, reference has a longer lifetime than the data it references
 --> src/main.rs:4:5
  |
4 |     context: &'c Context<'s>,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
note: the pointer is valid for the lifetime 'c as defined on the struct at 3:0
 --> src/main.rs:3:1
  |
3 | / struct Parser<'c, 's> {
4 | |     context: &'c Context<'s>,
5 | | }
  | |_^
note: but the referenced data is only valid for the lifetime 's as defined on the struct at 3:0
 --> src/main.rs:3:1
  |
3 | / struct Parser<'c, 's> {
4 | |     context: &'c Context<'s>,
5 | | }
  | |_^
```

Ржавчина не знает как связаны между собой `'c` и `'s`. Для того, чтобы
обеспечить, что ссылочные данные в `Context` со временем жизни `'s` допустимы,
необходимо установить ограничение, чтобы сборщик знал, что они живут дольше,
чем ссылка на `Context` со временем жизни `'c`. Если время жизни `'s` не длиннее `'c`,
то ссылка на `Context` может быть не правильна.


Что приводит нас к основной части этого раздела: В Ржавчине есть рычаг под названием *lifetime subtyping*, который является средством, чтобы указать, что одно свойство времени жизни живо по крайней мере, пока живо другое свойство. В угловых скобках, где мы объявляем свойства времени жизни, мы можем объявить продолжительность жизни `'a` как обычно, и объявить свойство времени жизни
`'b`, который живет по крайней мере до тех пор, пока существует `'a`.
Свойство времени жизни `'b` записывается с правилами написания `'b`: `'a`.

Для того, чтобы сообщить сборщику, что время жизни `'s` будет не меньше времени жизни `'c`, мы изменим описание стопки следующим образом:

```rust
# struct Context<'a>(&'a str);
#
struct Parser<'c, 's: 'c> {
    context: &'c Context<'s>,
}
```

Теперь всё в порядке. Такие особенности применяются не часто, но всё же бывают.

### Границы времени жизни переменных

В главе 10 мы обсуждали как использовать времена жизни в сущностях обобщенных видов данных.
Мы можем также добавить свойства времени жизни как ограничения в обобщенные виды.
Например, рассмотрим вид, который является оболочкой для ссылок. Вспомним вид
`RefCell<T>` из Главы 15: он имеет способы `borrow` и `borrow_mut`, которые возвращают
`Ref` и `RefMut`. Это определение стопки `Ref` без переменной времени жизни:

```rust,ignore
struct Ref<'a, T>(&'a T);
```

<span class="caption">рукопись 19-16: определение стопки-оболочки для ссылки на обобщенный
вид данных без переменной времени жизни</span>

Без связи обобщенного свойства и переменной времени жизни мы получим ошибку, т.к.
сборщик не знает как долго вид данных `T` будет существовать:

```text
error[E0309]: the parameter type `T` may not live long enough
 --> <anon>:1:19
  |
1 | struct Ref<'a, T>(&'a T);
  |                   ^^^^^^
  |
  = help: consider adding an explicit lifetime bound `T: 'a`...
note: ...so that the reference type `&'a T` does not outlive the data it points at
 --> <anon>:1:19
  |
1 | struct Ref<'a, T>(&'a T);
  |                   ^^^^^^
```

Т.к. `T` может быть любым видом, `T` сам может быть ссылкой или видом содержащим
ссылки. Поэтому сборщик не может определить время жизни `T`.

Для решения этой задачи в Ржавчине есть подсказка:

```text
consider adding an explicit lifetime bound `T: 'a` so that the reference type
`&'a T` does not outlive the data it points at.
```

Рукопись 19-17 отображает выполнение данного совета:

```rust
struct Ref<'a, T: 'a>(&'a T);
```

<span class="caption">рукопись 19-17: добавления ограничения времени жизни для `T`</span>

Мы можем решить эту задачу и другим способом. В рукописи 19-18 отображена
работа со постоянными переменными. Это означает, что если `T` содержит какую-либо
ссылку, она должна иметь `'static` время жизни:

```rust
struct StaticRef<T: 'static>(&'static T);
```

<span class="caption">рукопись 19-18: добавление `'static` время жизни для `T` для
введения ограничения `T`</span>

Виды без каких-либо ссылок считаются видами данных со постоянном временем жизни `T: 'static`.
Время жизни `'static` означает, что ссылка должна жить до тех пор, пока программа не завершит свою работу,
вид, который не содержит ссылок соответствует этим условиям, так как в собранной программе нет ссылок.
Подумайте об этом так: если borrow checker обеспокоен ссылками, живущими достаточно долго, тогда нет существующего
различия между видом, который не содержит ссылок и видами данных, ссылки на которые живут вечно.
Оба они одинаковы для целей определения того, имеет ли ссылка более короткое время жизни, чем то, на что она ссылаться.

### Переменные времени жизни предметов-сущностей

В главе 17 вы изучали предметы-сущности. Они применяются при изменяемом управлении.
Но мы ещё не обсуждали случай использования переменных времени жизни в таких стопках. Рассмотрим такой пример. В рукописи 19-19 у нас есть сущность `Foo` и стопка `Bar`, которая содержит ссылку (и, следовательно, имеет переменную времени жизни:

```rust
trait Foo { }

struct Bar<'a> {
    x: &'a i32,
}

impl<'a> Foo for Bar<'a> { }

let num = 5;

let obj = Box::new(Bar { x: &num }) as Box<Foo>;
```

<span class="caption">рукопись 19-19: использование вида данных, который имеет переменную времени
жизни</span>

Эта рукопись собирается без ошибок. Это происходит потому, что существуют правила между сущностями предметов и переменными времени жизни:

* по умолчанию ПВЖ для сущностей-предметов `'static`.
* если мы имеем `&'a X` or `&'a mut X`, то по умолчанию `'a`.
* если мы имеем один `T: 'a`, то по умолчанию  `'a`.
* если мы имеем множество `T: 'a` видов данных, то время жизни на до указывать явным образом.

В случае явного указания времени жизни сущностей-предметов, например `Box<Foo>`,
Правила написания будет следующий `Box<Foo + 'a>` или `Box<Foo + 'static>`.

Далее, мы рассмотрим расширенные возможности связанные с сущностями.
