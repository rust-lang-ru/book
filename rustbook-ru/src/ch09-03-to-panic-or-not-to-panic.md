## `panic!` или не `panic!`

Итак, как принимается решение о том, когда следует вызывать `panic!`, а когда вернуть `Result`? При сбое рукопись не имеет возможности восстановить своё выполнение. Можно было бы вызывать `panic!` для любого ошибочной случая, независимо от того, имеется ли способ восстановления или нет, но с другой стороны, вы принимаете решение от имени вызывающего вас рукописи, что случай необратима. Когда вы возвращаете значение `Result`, вы делегируете принятие решения вызывающей рукописи. Вызывающая рукопись может попытаться выполнить восстановление способом, который подходит в данной случае, или же он может решить, что из ошибки в  `Err` нельзя восстановиться и вызовет `panic!`, превратив вашу исправимую ошибку в неисправимую. Поэтому возвращение `Result` является хорошим выбором по умолчанию для функции, которая может дать сбой.

В таких случай как примеры, протовиды и проверки, более уместно писать рукопись, которая вызывает сбой вместо возвращения `Result`. Давайте рассмотрим почему, а затем мы обсудим случаи, в которых сборщик не может доказать, что ошибка невозможна, но вы, как человек, можете это сделать. Глава будет заканчиваться некоторыми общими руководящими принципами о том, как решить, стоит ли вызвать сбой в рукописи библиотеки.

### Примеры, создание опытного образца и проверки

Когда вы пишете пример, отображающий некоторую подход, наличие хорошего рукописи обработки ошибок может сделать пример менее понятным. Понятно, что в примерах вызов способа `unwrap`, который может привести к сбою, является лишь обозначением способа обработки ошибок в приложении, который может отличаться в зависимости от того, что делает остальная часть рукописи.

Точно так же способы `unwrap` и `expect` являются очень удобными при создании протовида, прежде чем вы будете готовы решить, как обрабатывать ошибки. Они оставляют чёткие отступы в рукописи до того времени, когда вы будете готовы сделать программу более надёжной.

Если в проверке происходит сбой при вызове способа, то вы бы хотели, чтобы весь проверка не прошёл, даже если этот способ не является проверяемой возможностью. Поскольку вызов `panic!` это способ, которым проверка помечается как провалившийся, использование `unwrap` или `expect` - именно то, что нужно.

### Случаи, в которых у вас больше сведений, чем у сборщика

Также было бы целесообразно вызывать `unwrap` или `expect` когда у вас есть какая-то другая ход мыслей, который заверяет, что `Result` будет иметь значение `Ok`, но вашу ход мыслей не понимает сборщик. У вас по-прежнему будет значение `Result` которое нужно обработать: любое действие, которое вы вызываете, все ещё имеет возможность неудачи в целом, хотя это разумно невозможно в вашем именно случае. Если, проверяя рукопись вручную, вы можете убедиться, что никогда не будет исход с `Err`, то вполне допустимо вызывать `unwrap`, а ещё лучше задокументировать причину, по которой, по вашему мнению, у вас никогда не будет исхода `Err` в писании `expect`. Вот пример:

```rust
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-08-unwrap-that-cant-fail/src/main.rs:here}}
```

Мы создаём образец данных `IpAddr`, рассмотривая жёстко заданную строку. Можно увидеть, что `127.0.0.1` является действительным IP-адресом, поэтому здесь допустимо использование `expect`. Однако наличие жёстко задан
ной допустимой строки не меняет вид данных возвращаемого значения способа `parse`: мы все ещё получаем значение `Result` и сборщик все также заставляет нас обращаться с `Result`так, будто возможен исход `Err`, потому что сборщик недостаточно умён, чтобы увидеть, что эта строка всегда действительный IP-адрес. Если строка IP-адреса пришла от пользователя, то она не является жёстко запрограммированной в программе и, следовательно, *может* привести к ошибке, мы определённо хотели бы обработать `Result` более надёжным способом. Упоминание предположения о том, что этот IP-адрес жёстко задан, побудит нас изменить `expect` для лучшей обработки ошибок, если в будущем нам потребуется вместо этого получить IP-адрес из какого-либо другого источника.

### Руководство по обработке ошибок

Желательно, чтобы рукопись вызвал сбой, если он может оказаться в неправильном состоянии. В этой среде *неправильное состояние* это когда некоторое допущение, заверение, договор или неизменная величина были нарушены. Например, когда недопустимые, противоречивые или пропущенные значения передаются в вашу рукопись - дополнительно один или несколько пунктов из следующего перечисленного в списке:

- Неправильное состояние — это что-то неожиданное, отличается от того, что может происходить время от времени, например, когда пользователь вводит данные в неправильном виде данных.
- Ваша рукопись после этой точки должна полагаться на то, что она не находится в неправильном состоянии, вместо проверок наличия сбоев на каждом этапе.
- Нет хорошего способа закодировать данную сведения в видах данных, которые вы используете. Мы рассмотрим пример того, что мы имеем в виду в разделе [“Кодирование состояний и поведения на основе видов данных”]<!-- ignore --> Главы 17.

Если кто-то вызывает вашу рукопись и передаёт значения, которые не имеют смысла, лучше всего вернуть ошибку, если вы это можете, чтобы пользователь библиотеки мог решить, что он хочет делать в этом случае. Однако в тех случаях, когда продолжение выполнения программы может быть небезопасным или вредным, лучшим выбором будет вызов `panic!` и оповещение пользователя, использующего вашу библиотеку, об ошибке в его рукописи, чтобы он мог исправить её во время разработки. Подобно `panic!` подходит, если вы вызываете внешний, неподвластную вам рукопись, и она возвращает недопустимое состояние, которое вы не можете исправить.

Однако, когда ожидается сбой, лучше вернуть `Result`, чем использовать вызов `panic!`.  В качестве примера можно привести связанный оценщик, которому передали неправильно созданные данные, или HTTP-запрос, возвращающий значение указывающий на то, что вы достигли ограничения на частоту запросов. В этих случаях возврат `Result` означает, что ошибка является ожидаемой и вызывающая рукопись должна решить, как её обрабатывать.

Когда ваша рукопись выполняет действие, которое может подвергнуть пользователя риску, если она вызывается с использованием недопустимых значений, ваша рукопись должна сначала проверить допустимость значений и вызвать сбой, если значения недопустимы. Так советуется делать в основном из соображений безопасности: попытка оперировать неправильными данными может привести к уязвимостям. Это основная причина, по которой обычная библиотека будет вызывать `panic!`, если попытаться получить доступ к памяти вне границ массива: доступ к памяти, не относящейся к текущему виду данных, является известной неполадкой безопасности. Функции часто имеют договоры: их поведение обеспечивается, только если входные данные отвечают определённым требованиям. Сбой при нарушении договора имеет смысл, потому что это всегда указывает на изъян со стороны вызывающей рукописи, и это не ошибка, которую вы хотели бы, чтобы вызывающая рукопись явно обрабатывала. На самом деле, нет разумного способа для восстановления вызывающего рукопись; программисты, вызывающие вашу рукопись, должны исправить свою рукопись. Договоры для функции, особенно когда нарушение вызывает сбой, следует описать в пособии по API функции.

Тем не менее, наличие множества проверок ошибок во всех ваших функциях было бы многословным и раздражительным. К счастью, можно использовать систему видов данных Ржавчине (следовательно и проверку видов данных сборщиком), чтобы она сделала множество проверок вместо вас. Если ваша функция имеет определённый вид данных в качестве свойства, вы можете продолжить работу с ходом мыслей рукописи зная, что сборщик уже обеспечил правильное значение. Например, если используется обычный вид данных, а не вид данных `Option`, то ваша программа ожидает наличие *чего-то* вместо *ничего*. Ваша рукопись не должна будет обрабатывать оба исхода `Some` и `None`: она будет иметь только один исход для определённого значения. Рукопись, пытающиаяся ничего не передавать в функцию, не будет даже собираться, поэтому ваша функция не должна проверять такой случай во время выполнения. Другой пример - это использование целого вида данных без знака, такого как вид `u32`, который заверяет, что свойство никогда не будет отрицательным.

### Создание пользовательских видов данных для проверки

Давайте разовьём мысль использования системы видов данных Ржавчине чтобы убедиться, что у нас есть правильное значение, и рассмотрим создание пользовательского вида данных для проверки. Вспомним игру угадывания числа из Главы 2, в которой особую рукопись просила пользователя угадать число между 1 и 100. Мы никогда не проверяли, что предположение пользователя лежит между этими числами, перед сравнением предположения с загаданным нами числом; мы только проверяли, что оно положительно. В этом случае последствия были не очень страшными: наши сообщения «Слишком много» или «Слишком мало», выводимые в окно вывода, все равно были правильными. Но было бы лучше подталкивать пользователя к правильным догадкам и иметь различное поведение для случаев, когда пользователь предлагает число за пределами ряда, и когда пользователь вводит, например, буквы вместо цифр.

Один из способов добиться этого - пытаться разобрать введённое значение как вид данных `i32`, а не как вид `u32`, чтобы разрешить возможно отрицательные числа, а затем добавить проверку для нахождение числа в ряде, например, так:

```rust,ignore
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-09-guess-out-of-range/src/main.rs:here}}
```

Условное выражение `if` проверяет, находится ли наше значение вне ряда, сообщает пользователю о неполадке и вызывает `continue`, чтобы начать следующую повторение круговорота и попросить ввести другое число. После выражения `if` мы можем продолжить сравнение значения `guess` с загаданным числом, зная, что `guess` лежит в ряде от 1 до 100.

Однако это не наилучшее решение: если бы было чрезвычайно важно, чтобы программа работала только со значениями от 1 до 100, существовало бы много функций, требующих этого, то такая проверка в каждой функции была бы утомительной (и могла бы отрицательно повлиять на производительность).

Вместо этого можно создать новый вид данных и поместить проверки в функцию создания образца этого вида данных, не повторяя их везде. Таким образом, функции могут использовать новый вид данных в своих ярлыках и быть уверены в значениях, которые им передают. Приложение 9-13 показывает один из способов, как определить вид данных `Guess`, чтобы образец данных `Guess` создавался только при условии, что функция `new` получает значение от 1 до 100.

<!-- Deliberately not using rustdoc_include here; the `main` function in the
file requires the `rand` crate. We do want to include it for reader
experimentation purposes, but don't want to include it for rustdoc testing
purposes. -->

```rust
{{#include ../listings/ch09-error-handling/listing-09-13/src/main.rs:here}}
```

<span class="caption">Приложение 9-13: Вид данных <code>Guess</code>, который будет создавать образцы только для значений от 1 до 100</span>

Сначала мы определяем вид данных с именем `Guess`, которая имеет поле с именем `value` вида данных `i32`, в котором будет храниться число.

Затем мы выполняем сопряженную функцию `new`, создающую образцы значений вида данных `Guess`. Функция `new`  имеет одно свойство `value` вида данных `i32`, и возвращает `Guess`. Рукопись в теле функции `new` проверяет, что значение `value` находится между 1 и 100. Если `value` не проходит эту проверку, мы вызываем `panic!`, которая оповестит программиста, написавшего вызывающую рукопись, что в его рукописи есть ошибка, которую необходимо исправить, поскольку попытка создания `Guess` со значением `value` вне заданного ряда нарушает договор, на который полагается `Guess::new`. Условия, в которых `Guess::new` вызывает сбой, должны быть описаны в пособии к API; мы рассмотрим соглашения о пособия, указывающие на возможность появления `panic!` в пособии API, которую вы создадите в Главе 14. Если `value` проходит проверку, мы создаём новый образец данных `Guess`, у которого значение поля  `value` равно значению свойства `value`, и возвращаем `Guess`.

Затем мы выполняем способ с названием `value`, который заимствует `self`, не имеет других свойств, и возвращает значение вида данных `i32`. Этот способ иногда называют *извлекатель* (getter), потому что его цель состоит в том, чтобы извлечь данные из полей стопки и вернуть их. Этот открытый способ является необходимым, поскольку поле `value` стопки `Guess`  является закрытым. Важно, чтобы поле `value` было закрытым, чтобы рукопись, использующая вид данных `Guess`, не могла устанавливать `value` напрямую: рукопись снаружи раздела *должна* использовать функцию `Guess::new` для создания образца данных `Guess`, таким образом обеспечивая, что у `Guess` нет возможности получить `value`, не проверенное условиями в функции `Guess::new`.

Функция, которая принимает или возвращает только числа от 1 до 100, может объявить в своей ярлыке, что она принимает или возвращает вид данных `Guess`, вместо `i32`, таким образом не будет необходимости делать дополнительные проверки в теле такой функции.

## Итоги

Функции обработки ошибок в Ржавчине призваны помочь написанию более надёжного рукописи. Макрос `panic!` указывает , что ваша программа находится в состоянии, которое она не может обработать, и позволяет сказать этапу чтобы он прекратил своё выполнение, вместо попытки продолжить выполнение с неправильными или неверными значениями. Перечисление `Result` использует систему видов Ржавчине, чтобы сообщить, что действия могут завершиться неудачей, и Ваша рукопись могла восстановиться. Можно использовать способ `Result`, чтобы сообщить вызывающей рукописи, что она должна обрабатывать вероятный успех или вероятную неудачу. Использование `panic!` и `Result` правильным образом сделает вашу рукопись более надёжной перед лицом неизбежных неполадок.

Теперь, когда вы увидели полезные способы использования  обобщённых видов данных `Option` и `Result` во встроенной библиотеке, мы поговорим о том, как работают обобщённые виды и как вы можете использовать их в своей рукописи.


[“Кодирование состояний и поведения на основе видов”]: ch17-03-oo-design-patterns.html#encoding-states-and-behavior-as-types