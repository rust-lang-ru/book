## Ссылочные замыкания могут приводить к утечке памяти

Заверения безопасности памяти в Ржавчине затрудняют, но не делают невозможным случайное выделение памяти, которое никогда не очищается (известное как *утечка памяти* ). Полное предотвращение утечек памяти не является одной из заверений Ржавчина, а это означает, что утечки памяти безопасны в Ржавчине. Мы видим, что Ржавчина допускает утечку памяти с помощью `Rc<T>` и `RefCell<T>`: можно создавать ссылки, в которых переменные ссылаются друг на друга в круговороте. Это создаёт утечки памяти, потому что счётчик ссылок каждой переменной в круговороте никогда не достигнет 0, а значения никогда не будут удалены.

### Создание ссылочного замыкания

Давайте посмотрим, как может произойти случай ссылочного замыкания и как её предотвратить, начиная с определения перечисления `List` и способа `tail` в приложении 15-25:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-25/src/main.rs}}
```

<span class="caption">Приложение 15-25: Объявление cons list, который содержит <code>RefCell&lt;T&gt;</code>, чтобы мы могли изменять то, на что ссылается образец данных <code>Cons</code></span>

Мы используем другую вариацию определения `List` из приложения 15-5. Вторая переменная в  исходе `Cons` теперь `RefCell<Rc<List>>`, что означает, что вместо возможности менять значение `i32`, как мы делали в приложении 15-24, мы хотим менять значение `List`, на которое указывает исход `Cons`. Мы также добавляем способ `tail`, чтобы нам было удобно обращаться ко второй переменной, если у нас есть исход `Cons`.

В приложении 15-26 мы добавляем `main` функцию, которая использует определения приложения 15-25. Эта рукопись создаёт список в переменной `a` и список `b`, который указывает на список `a`. Затем он изменяет список внутри `a` так, чтобы он указывал на `b`, создавая ссылочное замыкание. В рукописи есть  указания `println!`, чтобы показать значения счётчиков ссылок в различных точках этого этапа.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-26/src/main.rs:here}}
```

<span class="caption">Приложение 15-26: Создание ссылочного круговорота из двух значений <code>List</code>, указывающих друг на друга</span>

Мы создаём образец данных `Rc<List>` содержащий значение `List` в переменной `a` с начальным списком `5, Nil`. Затем мы создаём образец данных `Rc<List>` содержащий другое значение `List` в переменной `b`, которое содержит значение 10 и указывает на список в `a`.

Мы меняем `a` так, чтобы он указывал на `b` вместо `Nil`, создавая замкнутость. Мы делаем это с помощью способа `tail`, чтобы получить ссылку на `RefCell<Rc<List>>` из переменной `a`, которую мы помещаем в переменную `link`. Затем мы используем способ `borrow_mut` из вида данных `RefCell<Rc<List>>`, чтобы изменить внутреннее значение вида данных `Rc<List>`, содержащего начальное значение `Nil` на значение вида данных `Rc<List>` взятое из переменной `b`.

Когда мы запускаем эту рукопись, оставив последний `println!` с примечаниями в данный мгновение, мы получим вывод:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-26/output.txt}}
```

Количество ссылок на образцы `Rc<List>` как в `a`, так и в `b` равно 2 после того, как мы заменили список в `a` на ссылку на `b`. В конце `main` Ржавчина уничтожает переменную `b`, что уменьшает количество ссылок на `Rc<List>` из `b` с 2 до 1. Память, которую `Rc<List>` занимает в куче, не будет освобождена в это мгновение, потому что количество ссылок на неё равно 1, а не 0. Затем Ржавчина удаляет `a`, что уменьшает количество ссылок образца данных `Rc<List>` в `a` с 2 до 1. Память этого образца данных также не может быть освобождена, поскольку другой образец данных `Rc<List>` по-прежнему ссылается на него. Таким образом, память, выделенная для списка не будет освобождена никогда. Чтобы наглядно представить этот круговорот ссылок, мы создали рисунок на рисунке 15-4.

<img src="img/trpl15-04.svg" class="center" alt="Reference cycle of lists">

<span class="caption">Рисунок 15-4: Ссылочный круговорот списков <code>a</code> и <code>b</code>, указывающих друг на друга</span>

Если вы удалите последний примечание с `println!` и запустите программу, Ржавчина будет пытаться выводить замкнутость в `a`, указывающей на `b`, указывающей на `a` и так далее, пока не переполниться обойма.

По сравнению с существующей программой, последствия создания круговорота ссылок в этом примере не так страшны: сразу после создания круговорота ссылок программа завершается. Однако если более сложная программа выделит много памяти в круговороте и будет удерживать её в течение длительного времени, программа будет потреблять больше памяти, чем ей нужно, и может перенапрячь систему, что приведёт к исчерпанию доступной памяти.

Вызвать образование ссылочной замкнутости не просто, но и не невозможно. Если у вас есть значения `RefCell<T>` которые содержат значения `Rc<T>` или подобные вложенные сочетания видов данных с внутренней изменчивостью и подсчётом ссылок, вы должны убедиться, что вы не создаёте замкнутость; Вы не можете полагаться на то, что Ржавчина их обнаружит. Создание ссылочной замкнутости являлось бы разумной ошибкой в программе, для которой вы должны использовать самостоятельно е проверки, проверку рукописи и другие опытов разработки программного обеспечения для её уменьшения.

Другое решение для избежания ссылочной замкнутости - это пепересоздание ваших стопок данных, чтобы некоторые ссылки выражали владение, а другие - отсутствие владения. В итоге можно иметь круговороты, построенные на некоторых отношениях владения и некоторые не основанные на отношениях владения, тогда только отношения владения влияют на то, можно ли удалить значение. В приложении 15-25 мы всегда хотим, чтобы исходы `Cons` владели своим списком, поэтому пепересоздание вида данных невозможно. Давайте рассмотрим пример с использованием графов, состоящих из родительских и дочерних узлов, чтобы увидеть, когда отношения владения не являются подходящим способом предотвращения ссылочной замкнутости.

### Предотвращение ссылочной замкнутости: замена умного указателя `Rc<T>` на `Weak<T>`

До сих пор мы выясняли, что вызов `Rc::clone` увеличивает `strong_count` образца данных `Rc<T>`, а образец данных `Rc<T>` удаляется, только если его `strong_count` равен 0. Вы также можете создать *слабую ссылку* на значение внутри образца данных `Rc<T>`, вызвав `Rc::downgrade` и передав ссылку на `Rc<T>`. Сильные ссылки - это то с помощью чего вы можете поделиться владением образца данных `Rc<T>`. Слабые ссылки не отражают связи владения, и их подсчёт не влияет на то, когда образец данных `Rc<T>` будет очищен. Они не приведут к ссылочному круговороту, потому что любой круговорот, включающий несколько слабых ссылок, будет разорван, как только количество сильных ссылок для задействованных значений станет равным 0.

Когда вы вызываете `Rc::downgrade`, вы получаете умный указатель вида данных `Weak<T>`. Вместо того чтобы увеличить `strong_count` в образце `Rc<T>` на 1, вызов `Rc::downgrade` увеличивает `weak_count` на 1. Вид данных `Rc<T>` использует `weak_count` для отслеживания количества существующих ссылок `Weak<T>`, подобно `strong_count`. Разница в том, что `weak_count` не должен быть равен 0, чтобы образец данных `Rc<T>` мог быть удалён.

Поскольку значение, на которое ссылается `Weak<T>` могло быть удалено, то необходимо убедиться, что это значение все ещё существует, чтобы сделать что-либо со значением на которое указывает `Weak<T>`. Делайте это вызывая способ `upgrade` у образца вида данных `Weak<T>`, который вернёт `Option<Rc<T>>`. Вы получите итог `Some`, если значение `Rc<T>` ещё не было удалено и итог `None`, если значение `Rc<T>` было удалено. Поскольку `upgrade` возвращает вид данных `Option<T>`, Ржавчина обеспечит обработку обоих случаев `Some` и `None` и не будет неправильного указателя.

В качестве примера, вместо того чтобы использовать список, чья переменная или способ знает только о следующей переменной или способе, мы создадим дерево, чьи переменные знают о своих дочерних и родительских переменных или способах *и*.

#### Создание древовидного устройства данных: `Node` с дочерними узлами

Для начала мы построим дерево с узлами, которые знают о своих дочерних узлах. Мы создадим вид данных с именем `Node`, который будет содержать собственное значение с видом данных `i32`, а также ссылки на его дочерние значения `Node`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-27/src/main.rs:here}}
```

Мы хотим, чтобы `Node` владел своими дочерними узлами и мы хотим поделиться этим владением с переменными так, чтобы мы могли напрямую обращаться к каждому `Node` в дереве. Для этого мы определяем внутренние переменные вида данных `Vec<T>` как значения вида данных `Rc<Node>`. Мы также хотим изменять те узлы, которые являются дочерними по отношению к другому узлу, поэтому у нас есть вид данных `RefCell<T>` в поле `children` оборачивающий вид данных `Vec<Rc<Node>>`.

Далее мы будем использовать наше определение вида данных и создадим один образец данных `Node` с именем `leaf` со значением 3 и без дочерних переменных, а другой образец с именем `branch` со значением 5 и `leaf` в качестве одного из его дочерних переменных, как показано в приложении 15-27:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-27/src/main.rs:there}}
```

<span class="caption">Приложение 15-27: Создание узла <code>leaf</code> без дочерних переменных и узла <code>branch</code> с <code>leaf</code> в качестве одного из дочерних переменных</span>

Мы удвоим  содержимое `Rc<Node>` из переменной  `leaf` и сохраняем его в переменной `branch`, что означает, что `Node` в  `leaf` теперь имеет двух владельцев: `leaf` и `branch`. Мы можем получить доступ из `branch` к `leaf` через обращение `branch.children`, но нет способа добраться из  `leaf` к `branch`. Причина в том, что `leaf` не имеет ссылки на `branch` и не знает, что они связаны. Мы хотим, чтобы `leaf` знал, что `branch` является его родителем. Мы сделаем это далее.

#### Добавление ссылки от ребёнка к его родителю

Для того, чтобы дочерний узел знал о своём родительском узле нужно добавить поле `parent` в наше определение стопки `Node`. Неполадка в том, чтобы решить, каким должен быть вид данных `parent`. Мы знаем, что он не может содержать `Rc<T>`, потому что это создаст ссылочную замкнутость с `leaf.parent` указывающей на `branch` и `branch.children`, указывающей на `leaf`, что приведёт к тому, что их значения `strong_count` никогда не будут равны 0.

Подумаем об этих отношениях по-другому, родительский узел должен владеть своими потомками: если родительский узел удаляется, его дочерние узлы также должны быть удалены. Однако дочерний элемент не должен владеть своим родителем: если мы удаляем дочерний узел то родительский элемент все равно должен существовать. Это случай для использования слабых ссылок!

Поэтому вместо `Rc<T>` мы сделаем так, чтобы поле `parent` использовало вид данных `Weak<T>`, а именно `RefCell<Weak<Node>>`. Теперь наше определение стопки `Node` выглядит так:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-28/src/main.rs:here}}
```

Узел сможет ссылаться на свой родительский узел, но не владеет своим родителем. В приложении 15-28 мы обновляем `main` на использование нового определения так, чтобы у узла `leaf` был бы способ ссылаться на его родительский узел `branch`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-28/src/main.rs:there}}
```

<span class="caption">Приложение 15-28: Узел <code>leaf</code> со слабой ссылкой на его родительский узел <code>branch</code></span>

Создание узла `leaf` выглядит подобно примеру из Приложения 15-27, за исключением поля `parent`: `leaf` изначально не имеет родителя, поэтому мы создаём новый, пустой образец ссылки `Weak<Node>`.

На этом этапе, когда мы пытаемся получить ссылку на родительский узел у узла `leaf` с помощью способа `upgrade`, мы получаем значение `None`. Мы видим это в выводе первой указания `println!`:

```text
leaf parent = None
```

Когда мы создаём узел `branch` у него также будет новая ссылка вида данных `Weak<Node>` в поле `parent`, потому что узел `branch` не имеет своего родительского узла. У нас все ещё есть `leaf` как один из потомков узла `branch`. Когда мы получили образец данных `Node` в переменной `branch`, мы можем изменить переменную `leaf` чтобы дать ей `Weak<Node>` ссылку на её родителя. Мы используем способ `borrow_mut` у вида данных `RefCell<Weak<Node>>` поля `parent` у `leaf`, а затем используем функцию `Rc::downgrade` для создания `Weak<Node>` ссылки на `branch` из `Rc<Node>` в `branch`.

Когда мы снова выведем родителя `leaf` то в этот раз мы получим исход `Some` содержащий `branch`, теперь `leaf` может получить доступ к своему родителю! Когда мы выводим `leaf`, мы также избегаем круговорота, который в конечном итоге заканчивался переполнением обоймы, как в приложении 15-26; ссылки вида данных `Weak<Node>`  выводятся как `(Weak)`:

```text
leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
```

Отсутствие бесконечного вывода означает, что эта рукопись не создала ссылочной замкнутости. Мы также можем сказать это, посмотрев на значения, которые мы получаем при вызове `Rc::strong_count` и `Rc::weak_count`.

#### Отображение изменений в `strong_count` и `weak_count`

Давайте посмотрим, как изменяются значения `strong_count` и `weak_count` образцов вида данных `Rc<Node>` с помощью создания новой внутренней области видимости и передавая создания образца данных `branch` в эту область. Таким образом можно увидеть, что происходит, когда `branch` создаётся и затем удаляется при выходе из области видимости. Изменения показаны в приложении 15-29:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-29/src/main.rs:here}}
```

<span class="caption">Приложение 15-29: Создание <code>branch</code> во внутренней области видимости и подсчёт сильных и слабых ссылок</span>

После того, как `leaf` создан его `Rc<Node>` имеет значения strong count равное 1 и weak count равное 0. Во внутренней области мы создаём `branch` и связываем её с `leaf`, после чего при выводе значений счётчиков `Rc<Node>` в `branch` они будет иметь strong count 1 и weak count 1 (для `leaf.parent` указывающего на `branch` с `Weak<Node>` ). Когда мы выведем счётчики из `leaf`, мы увидим, что они будут иметь strong count 2, потому что `branch` теперь имеет двойник `Rc<Node>` переменной `leaf` хранящийся в `branch.children`, но все равно будет иметь weak count 0.

Когда заканчивается внутренняя область видимости,  `branch` выходит из области видимости и strong count `Rc<Node>` уменьшается до 0, поэтому его `Node` удаляется. Weak count 1 из `leaf.parent` не имеет никакого отношения к тому, был ли `Node` удалён, поэтому не будет никаких утечек памяти!

Если мы попытаемся получить доступ к родителю переменной `leaf` после окончания области видимости, мы снова получим значение `None`. В конце программы `Rc<Node>` внутри `leaf` имеет strong count 1 и weak count 0 потому что переменная `leaf` снова является единственной ссылкой на `Rc<Node>`.

весь ход мыслей, который управляет счётчиками и сбросом их значений, встроена внутри `Rc<T>` и `Weak<T>` и их выполнений сущности `Drop`. Указав, что отношение из дочернего к родительской переменной должно быть ссылкой вида данных  `Weak<T>` в определении `Node`, делает возможным иметь родительские узлы, указывающие на дочерние узлы и наоборот, не создавая ссылочной замкнутости и утечек памяти.

## Итоги

В этой главе рассказано как использовать умные указатели для обеспечения различных заверений и соглашений по сравнению с обычными ссылками, которые Ржавчина использует по умолчанию. Вид данных `Box<T>` имеет известный размер и указывает на данные размещённые в куче. Вид данных `Rc<T>` отслеживает количество ссылок на данные в куче, поэтому данные могут иметь несколько владельцев. Вид данных `RefCell<T>` с его внутренней изменяемостью предоставляет вид, который можно использовать при необходимости неизменного вида данных, но необходимости изменить внутреннее значение этого вида данных; он также обеспечивает соблюдение правил заимствования во время выполнения, а не во время сборки.

Мы обсудили также сущности `Deref` и `Drop`, которые обеспечивают большую возможность умных указателей. Мы исследовали ссылочную замкнутость, которая может вызывать утечки памяти и как это предотвратить с помощью способа `Weak<T>`.

Если эта глава вызвала у вас влечение и вы хотите использовать свои собственные умные указатели, обратитесь к ["The Rustonomicon"](https://doc.rust-lang.org/nomicon/index.html) за более полезной сведениями.

Далее мы поговорим о одновременности в Ржавчине Вы даже узнаете о нескольких новых умных указателях.


