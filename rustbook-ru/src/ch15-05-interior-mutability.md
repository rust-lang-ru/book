## `RefCell<T>` и образец данных внутренней изменяемости

*Внутренняя изменяемость* - это образец разработки Ржавчина, который позволяет вам изменять данные даже при наличии неизменяемых ссылок на эти данные; обычно такое действие запрещено правилами заимствования. Для изменения данных образец использует `unsafe` рукопись внутри вида данных, чтобы обойти обычные правила Ржавчины управляющие изменчивостью и заимствование. Небезопасная (unsafe) рукопись даёт понять сборщику, что мы самостоятельно следим за соблюдением этих правил, а не полагаемся на то, что сборщик будет делать это для нас; подробнее о небезопасной рукописи мы поговорим в главе 19.

Мы можем использовать виды данных, в которых применяется образец внутренней изменяемости, только если мы можем обеспечить, что правила заимствования будут соблюдаться во время выполнения, несмотря на то, что сборщик не сможет этого обеспечить. В этом случае `небезопасный` рукопись оборачивается безопасным API, и внешне вид остаётся неизменяемым.

Давайте изучим данную подход с помощью способа данных `RefCell<T>`, который использует этот образец.

### Применение правил заимствования во время выполнения с помощью `RefCell<T>`

В отличие от `Rc<T>` вид данных `RefCell<T>` предоставляет единоличное владение данными, которые он содержит. В чем же отличие вида данных `RefCell<T>` от `Box<T>`? Давайте вспомним правила заимствования из Главы 4:

- В этот подход времени вы можете иметь *либо* одну изменяемую ссылку либо сколько угодно неизменяемых ссылок (но не оба вида ссылок одновременно).
- Ссылки всегда должны быть действительными.

С помощью ссылок и вида данных `Box<T>` неизменные величины правил заимствования применяются на этапе сборки. С помощью `RefCell<T>` они применяются *во время работы приложения*. Если вы нарушите эти правила, работая с ссылками, то будет ошибка сборки. Если вы работаете с `RefCell<T>` и нарушите эти правила, то приложение вызовет сбой и завершится.

Преимущества проверки правил заимствования во время сборки заключаются в том, что ошибки будут обнаруживаться раньше - ещё в этапе разработки, а производительность во время выполнения не пострадает, поскольку весь оценка завершена заранее. По этим причинам проверка правил заимствования во время сборки является лучшим выбором в большинстве случаев, и именно поэтому она используется в Ржавчине по умолчанию.

Преимущество проверки правил заимствования во время выполнения заключается в том, что определённые задумки, безопасные для памяти, разрешаются там, где они были бы запрещены проверкой во время сборки. Постоянной оценка, как и сборщик Ржавчины по своей сути устоявшийся. Некоторые свойства рукописи невозможно обнаружить, рассмотривая рукопись: самый известный пример - неполадка остановки, которая выходит за рамки этой книги, но является важной темой для исследования.

Поскольку некоторый оценка невозможен, то если сборщик Ржавчины не может быть уверен, что рукопись соответствует правилам владения, он может отклонить правильную программу; таким образом он является консервативным. Если Ржавчина приняла неправильную программу, то пользователи не смогут доверять заверениям, которые даёт Ржавчина. Однако, если Ржавчина отклонит правильную программу, то разработчик ПО будет испытывать неудобства, но ничего катастрофического не произойдёт. Вид данных `RefCell<T>` полезен, когда вы уверены, что Ваша рукопись соответствует правилам заимствования, но сборщик не может понять и обеспечить этого.

Подобно виду данных `Rc<T>`, вид `RefCell<T>` предназначен только для использования в однопоточных задумках и выдаст ошибку времени сборки, если вы попытаетесь использовать его в многопоточной среде. Мы поговорим о том, как получить возможность `RefCell<T>` во многопоточной программе в главе 16.

Вот список причин выбора видов данных `Box<T>`, `Rc<T>` или `RefCell<T>`:

- Вид данных `Rc<T>` разрешает множественное владение одними и теми же данными; виды данных `Box<T>` и `RefCell<T>` разрешают иметь единственных владельцев.
- Вид данных `Box<T>` разрешает неизменяемые или изменяемые владения, проверенные при сборке; вид данных `Rc<T>` разрешает только неизменяемые владения, проверенные при сборке; вид данных `RefCell<T>` разрешает неизменяемые или изменяемые владения, проверенные во время выполнения.
- Поскольку `RefCell<T>` разрешает изменяемые заимствования, проверенные во время выполнения, можно изменять значение внутри `RefCell<T>` даже если `RefCell<T>` является неизменным.

Изменение значения внутри неизменного значения является образцом *внутренней изменяемости* (interior mutability). Давайте посмотрим на случай, в котором внутренняя изменяемость полезна и рассмотрим, как это возможно.

### Внутренняя изменяемость: изменяемое заимствование неизменяемого значения

Следствием правил заимствования является то, что когда у вас есть неизменяемое значение, вы не можете заимствовать его с изменением. Например, эта рукопись не будет собираться:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/no-listing-01-cant-borrow-immutable-as-mutable/src/main.rs}}
```

Если вы попытаетесь собрать эту рукопись, вы получите следующую ошибку:

```console
{{#include ../listings/ch15-smart-pointers/no-listing-01-cant-borrow-immutable-as-mutable/output.txt}}
```

Однако бывают случаи, в которых было бы полезно, чтобы предмет мог изменять себя при помощи своих способов, но казался неизменным для прочего рукописи. Рукопись вне способов этого предмета не должна иметь возможности изменять его содержимое. Использование `RefCell<T>` - один из способов получить возможность внутренней изменяемости, но при этом `RefCell<T>` не позволяет полностью обойти правила заимствования: средство проверки правил заимствования в сборщике позволяет эту внутреннюю изменчивость, однако правила заимствования проверяются во время выполнения. Если вы нарушите правила, то вместо ошибки сборки вы получите `panic!`.

Давайте разберём опытный пример, в котором мы можем использовать `RefCell<T>` для изменения неизменяемого значения и посмотрим, почему это полезно.

#### Исход использования внутренней изменяемости: мок предметы

Иногда во время проверки разработчик ПО использует один вид данных вместо другого для того, чтобы проверить определённое поведение и убедиться, что оно выполнено правильно. Такой вид данных-заместитель называется *проверочным повторителем*. Воспринимайте его как «каскадёра» в кинематографе, когда повторитель  заменяет актёра для выполнения определённой сложной сцены. Проверочные повторители заменяют другие виды данных при выполнении проверок. *Инсценировочные (mock) предметы* — это особый вид данных проверочных повторителей, которые сохраняют данные происходящих во время проверки действий тем самым позволяя вам убедиться впоследствии, что все действия были выполнены правильно.

В Ржавчине нет предметов в том же смысле, в каком они есть в других языках и в Ржавчине нет возможности мок предметов, встроенных во встроенную библиотеку, как в некоторых других языках. Однако вы определённо можете создать устройство, которое будет служить тем же целям, что и мок предмет.

Вот задумка, которую мы будем проверять: мы создадим библиотеку, которая отслеживает значение по отношению к заранее определённому наивысшему значению и отправляет сообщения в зависимости от того, насколько текущее значение находится близко к такому наивысшему значению. Эта библиотека может использоваться, например, для отслеживания квоты количества вызовов API пользователя, которые ему разрешено делать.

Наша библиотека будет предоставлять только функции отслеживания того, насколько близко к наивысшему значению находится значение и какие сообщения должны быть внутри в это мгновение. Ожидается, что приложения, использующие нашу библиотеку, предоставят рычаг для отправки сообщений: приложение может поместить сообщение в приложение, отправить электронное письмо, отправить письменное сообщение или что-то ещё. Библиотеке не нужно знать эту подробность. Все что ему нужно - это что-то, что использует сущность, который мы предоставим с названием `Messenger`. Приложение 15-20 показывает рукопись библиотеки:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-20/src/lib.rs}}
```

<span class="caption">Приложение 15-20: Библиотека для отслеживания степени приближения того или иного значения к наиболее допустимой величине и предупреждения, в случае если значение достигает определённого уровня</span>

Одна важная часть этой рукописи состоит в том, что сущность `Messenger` имеет один способ `send`, принимающий переменными неизменяемую ссылку на `self` и писание сообщения. Он является внешней оболочкой, который должен иметь наш мок предмет. Другой важной частью является то, что мы хотим проверить поведение способа `set_value` у вида данных `LimitTracker`. Мы можем изменить значение, которое передаём свойством `value`, но `set_value` ничего не возвращает и нет основания, чтобы мы могли бы проверить утверждения о выполнении способа. Мы хотим иметь возможность  сказать, что если мы создаём `LimitTracker` с чем-то, что использует сущность `Messenger` и с определённым значением для `max`, то когда мы передаём разные числа в переменной `value` образец self.messenger отправляет соответствующие сообщения.

Нам нужен мок предмет, который вместо отправки электронного письма или письменного сообщения будет отслеживать сообщения, которые были ему поручены для отправки через `send`. Мы можем создать новый образец мок предмета. создать `LimitTracker` с использованием мок предмет для него, вызвать способ `set_value` у образца данных `LimitTracker`, а затем проверить, что мок предмет имеет ожидаемое сообщение. В приложении 15-21 показана попытка использовать мок предмет, чтобы сделать именно то что хотим, но оценщик заимствований не разрешит такую рукопись:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-21/src/lib.rs:here}}
```

<span class="caption">Приложение 15-21: Попытка выполнить <code>MockMessenger</code>, которая не была принята рычагом проверки заимствований</span>

Эта проверочная рукопись определяет стопку `MockMessenger`, в которой есть поле `sent_messages` со значениями вида данных `Vec` из `String` для отслеживания сообщений, которые поручены стопке для отправки. Мы также определяем сопряженную функцию `new`, чтобы было удобно создавать новые образцы `MockMessenger`, которые создаются с пустым списком сообщений. Затем мы используем сущность `Messenger` для вида данных `MockMessenger`, чтобы передать `MockMessenger` в `LimitTracker`. В ярлыке способа `send` мы принимаем сообщение для передачи в качестве свойства и сохраняем его в `MockMessenger` внутри списка `sent_messages`.

В этом проверке мы проверяем, что происходит, когда `LimitTracker` сказано установить `value` в значение, превышающее 75 процентов от значения `max`. Сначала мы создаём новый `MockMessenger`, который будет иметь пустой список сообщений. Затем мы создаём новый `LimitTracker` и передаём ему ссылку на новый `MockMessenger` и `max` значение равное 100. Мы вызываем способ `set_value` у `LimitTracker` со значением 80, что составляет более 75 процентов от 100. Затем мы с помощью утверждения проверяем, что `MockMessenger` должен содержать одно сообщение из списка внутренних сообщений.

Однако с этим проверкой есть одна неполадка, показанная ниже:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-21/output.txt}}
```

Мы не можем изменять `MockMessenger` для отслеживания сообщений, потому что способ `send` принимает неизменяемую ссылку на `self`. Мы также не можем принять предложение из писания ошибки, чтобы использовать `&mut self`, потому что тогда ярлык `send` не будет соответствовать ярлыке в определении сущности `Messenger` (не стесняйтесь попробовать и посмотреть, какое сообщение об ошибке получите вы).

Это случай, в котором внутренняя изменяемость может помочь! Мы сохраним `sent_messages` внутри вида данных `RefCell<T>`, а затем в способе `send` сообщение сможет изменить список `sent_messages` для хранения сообщений, которые мы видели. Приложение 15-22 показывает, как это выглядит:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-22/src/lib.rs:here}}
```

<span class="caption">Приложение 15-22: Использование <code>RefCell&lt;T&gt;</code> для изменения внутреннего значения, в то время как внешнее значение считается неизменяемым</span>

Поле `sent_messages` теперь имеет вид данных `RefCell<Vec<String>>` вместо `Vec<String>`. В функции `new` мы создаём новый образец данных `RefCell<Vec<String>>` для пустого вектора.

Для выполнения способа `send` первое свойство по-прежнему является неизменяемым для заимствования `self`, которое соответствует определению сущности. Мы вызываем `borrow_mut` для `RefCell<Vec<String>>` в `self.sent_messages`, чтобы получить изменяемую ссылку на значение внутри `RefCell<Vec<String>>`, которое является вектором. Затем мы можем вызвать `push` у изменяемой ссылки на вектор, чтобы отслеживать сообщения, отправленные во время проверки.

Последнее изменение, которое мы должны сделать, заключается в утверждении для проверки: чтобы увидеть, сколько переменных находится во внутреннем векторе, мы вызываем способ `borrow` у `RefCell<Vec<String>>`, чтобы получить неизменяемую ссылку на внутренний вектор сообщений.

Теперь, когда вы увидели как использовать `RefCell<T>`, давайте изучим как он работает!

#### Отслеживание заимствований во время выполнения с помощью `RefCell<T>`

При создании неизменных и изменяемых ссылок мы используем правила написания `&` и `&mut` соответственно. У вида данных `RefCell<T>`, мы используем способы `borrow` и `borrow_mut`, которые являются частью безопасного API, который принадлежит `RefCell<T>`. Способ `borrow` возвращает вид умного указателя `Ref<T>`, способ `borrow_mut` возвращает вид умного указателя `RefMut<T>`. Оба вида данных используют сущность `Deref`, поэтому мы можем рассматривать их как обычные ссылки.

Вид данных `RefCell<T>` отслеживает сколько умных указателей `Ref<T>` и `RefMut<T>` действительо в данное время. Каждый раз, когда мы вызываем `borrow`, вид данных `RefCell<T>` увеличивает количество действующих заимствований. Когда значение `Ref<T>` выходит из области видимости, то количество неизменяемых заимствований уменьшается на единицу. Как и с правилами заимствования во время сборки, `RefCell<T>` позволяет иметь много неизменяемых заимствований или одно изменяемое заимствование в этот подход времени.

Если попытаться нарушить эти правила, то вместо получения ошибки сборщика, как это было бы со ссылками, использование `RefCell<T>` будет вызывать сбой во время выполнения. В приложении 15-23 показана изменение выполнения `send` из приложения 15-22. Мы намеренно пытаемся создать два изменяемых заимствования действующих для одной и той же области видимости, чтобы показать как `RefCell<T>` не позволяет нам делать так во время выполнения.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,panics
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-23/src/lib.rs:here}}
```

<span class="caption">Приложение 15-23: Создание двух изменяемых ссылок в одной области видимости, чтобы убедиться, что <code>RefCell&lt;T&gt;</code> вызовет сбой</span>

Мы создаём переменную `one_borrow` для умного указателя `RefMut<T>` возвращаемого из способа `borrow_mut`. Затем мы создаём другое изменяемое заимствование таким же образом в переменной `two_borrow`. Это создаёт две изменяемые ссылки в одной области видимости, что недопустимо. Когда мы запускаем проверки для нашей библиотеки, рукопись в приложении 15-23 собирается без ошибок, но проверка завершится неудачно:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-23/output.txt}}
```

Обратите внимание, что рукопись вызвал сбой с сообщением `already borrowed: BorrowMutError`. Вот так вид данных `RefCell<T>` обрабатывает нарушения правил заимствования во время выполнения.

Решение отлавливать ошибки заимствования во время выполнения, а не во время сборки, как мы сделали здесь, означает, что вы возможно будете находить ошибки в своей рукописи на более поздних этапах разработки: возможно, не раньше, чем Ваша рукопись будет развернута в рабочем окружении. Кроме того, Ваша рукопись будет иметь небольшие потери производительности в этапе работы, поскольку заимствования будут отслеживаться во время выполнения, а не во время сборки. Однако использование `RefCell<T>` позволяет написать предмет-имитатор, который способен изменять себя, чтобы сохранять сведения о тех значениях, которые он получал, пока вы использовали его в среде, где разрешены только неизменяемые значения. Вы можете использовать `RefCell<T>`, несмотря на его недостатки, чтобы получить больше возможности, чем дают обычные ссылки.

### Наличие нескольких владельцев изменяемых данных путём объединения видов данных `Rc<T>` и `RefCell<T>`

Обычный способ использования `RefCell<T>` заключается в его сочетании с видом данных `Rc<T>`. Напомним, что вид данных `Rc<T>` позволяет иметь нескольких владельцев некоторых данных, но даёт только неизменяемый доступ к этим данным. Если у вас есть `Rc<T>`, который внутри содержит вид данных `RefCell<T>`, вы можете получить значение, которое может иметь несколько владельцев *и* которое можно изменять!

Например, вспомните пример cons списка приложения 15-18, где мы использовали `Rc<T>`, чтобы несколько списков могли совместно владеть другим списком. Поскольку `Rc<T>` содержит только неизменяемые значения, мы не можем изменить ни одно из значений в списке после того, как мы их создали. Давайте добавим вид данных `RefCell<T>`, чтобы получить возможность изменять значения в списках. В приложении 15-24 показано использование `RefCell<T>` в определении `Cons` так, что мы можем изменить значение хранящееся во всех списках:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-24/src/main.rs}}
```

<span class="caption">Приложение 15-24: Использование <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> для создания <code>Список</code>, который мы можем изменять</span>

Мы создаём значение, которое является образцом `Rc<RefCell<i32>>` и сохраняем его в переменной с именем `value`, чтобы получить к ней прямой доступ позже. Затем мы создаём `Список` в переменной `a` с исходом `Cons`, который содержит `value`. Нам нужно вызвать удваивание `value`, так как обе переменные `a` и `value` владеют внутренним значением `5`, а не передают владение из `value` в переменную `a` или не выполняют заимствование с помощью `a` переменной `value`.

Мы оборачиваем список у переменной `a` в вид данных `Rc<T>`, поэтому при создании списков в переменные `b` и `c` они оба могут ссылаться на `a`, что мы и сделали в приложении 15-18.

После создания списков `a`, `b` и `c` мы хотим добавить 10 к значению в `value`. Для этого вызовем `borrow_mut` у `value`, которые используют функцию самостоятельного разыменования, о которой мы говорили в главе 5 (см. раздел ["Где находится приказчик `->`?"]<!-- ignore -->) во внутреннее значение `RefCell<T>`. Способ `borrow_mut` возвращает умный указатель `RefMut<T>`, и мы используя приказчик разыменования, изменяем внутреннее значение.

Когда мы выводим `a`, `b` и `c` то видим, что все они имеют изменённое значение равное 15, а не 5:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-24/output.txt}}
```

Это средство довольно изящно! Используя `RefCell<T>`, мы получаем внешне неизменяемое значение `Список`. Но мы можем использовать способы `RefCell<T>`, которые предоставляют доступ к его внутренностям, чтобы мы могли изменять наши данные, когда это необходимо. Проверка правил заимствования во время выполнения защищает нас от гонок данных, и иногда стоит немного пожертвовать производительностью ради такой гибкости наших стопок данных. Обратите внимание, что `RefCell<T>` не работает для многопоточного рукописи! `Mutex<T>` - это thread-safe исполнение `RefCell<T>`, а `Mutex<T>` мы обсудим в главе 16.


["Где находится приказчик `->`?"]: ch05-03-method-syntax.html#wheres-the---operator