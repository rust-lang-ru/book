## Обобщённые виды данных

Мы используем обобщённые виды данных для объявления функций или стопок, которые затем можно использовать с различными определенными видами данных. Давайте сначала посмотрим, как объявлять функции, стопки, перечисления и способы, используя обобщённые виды данных. Затем мы обсудим, как обобщённые виды данных влияют на производительность рукописи.

### В объявлении функций

Когда мы объявляем функцию с обобщёнными видами данных, мы размещаем обобщённые виды данных в ярлыке функции, где мы обычно указываем входные виды данных переменных и возвращаемого значения. Использование обобщённых видов данных позволяет сократить рукопись и предоставить большую возможность при вызове нашей функции, предотвращая повторы рукописи.

Рассмотрим пример с функцией `наибольшее`. Приложение 10-4 показывает две функции, каждая из которых находит самое большое значение в срезе своего вида данных. Позже мы объединим их в одну функцию, использующую обобщённые виды данных.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-04/src/main.rs:here}}
```

<span class="caption">Приложение 10-4: Две функции, отличающиеся только именем и видом обрабатываемых данных</span>

Функция `наибольший_i32` уже встречалась нам: мы извлекли её из приложения 10-3, когда решили уменьшить рукопись — она находит наибольшее значение среди среза `[..]` вида данных `i32`. Функция `наибольший_знак` находит самое большое значение  среди среза `[..]` вида данных `char`. Тело у этих функций одинаковое, поэтому давайте сократим нашу рукопись, используя обобщённый вид данных `T` и его возможности, поместив всё в одну функцию.

В новой объявляемой функции нам нужно указать в ярлыке функции изложение обобщённого вида данных `T` — так же, как мы это делаем во всех остальных функциях. Можно использовать любой определитель для имени свойства вида данных, но мы будем использовать `T`, потому что согласно правил Ржавчины, изложение вида данных  должно быть коротким (обычно длиной в один знак), а объявление составных видов данных в Ржавчине производится по правилу отсутствия знаков разделения между словами (таких как пробел, `-` `_` и т.д.) и заглавной буквы в начале каждого слова, например `СтопкаЗнаков` или `СтопкаЦелыхЧисел` согласно английскому правилу - UpperCamelCase. Сокращение слова «вид» («type») до одной буквы `T` является самым распространёнными выбором большинства разработчиков ПО, использующих язык Ржавчина.

Когда мы используем переменную в теле функции, мы должны изложить данную переменную в ярлыке функции, чтобы сборщик знал, её вид данных и имя. Подобно когда мы используем переменную в теле функции, мы должны объявить раньше в самом ярлыке функции, прежде чем мы её используем. Чтобы ввести обобщённую функцию `наибольшее`, необходимо указать особый признаки (треугольных скобки `<>`) при объявлении самой функции после её имени перед изложением видов данных `fn наибольшее<T>`, полный пример ниже:

```rust,ignore
fn наибольшее<T>(список: &[T]) -> &T {
```

Объявление читается так: функция `наибольшее` является обобщённой по виду данных `T`. Эта функция имеет одну переменную с именем `список`, который является ссылкой на срез значений вида данных `T`. Функция `наибольшее` возвращает ссылку на этот же вид данных `T`.

Приложение 10-5 определена функции `наибольшее` с использованием обобщённого вида данных в её ярлыке. Указано как мы можем вызвать функцию со ссылкой на срез вида данных `i32` или `char`. Данная рукопись имеет ошибки и не может быть собрана, к концу раздела мы внесём необходимые правки.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-05/src/main.rs}}
```

<span class="caption">Приложение 10-5: Функция <code>наибольшее</code>, использующая обобщённый вид данных. В настоящее время не доведена до работоспособного состояния</span>

При попытке собрать рукопись в исполняемое приложение, мы получим следующую ошибку:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-05/output.txt}}
```

В подсказке указана *сущность* `std::cmp::PartialOrd`. Мы поговорим про сущности в следующем разделе. Сейчас ошибка в функции `наибольшее` указывает, что функция не будет работать для всех возможных видов данных `T`. Так как мы хотим сравнивать значения вида данных `T` в теле функции, мы можем использовать только те виды данных, для которых применима сущность `std::cmp::PartialOrd`. Если можно упорядочить вид данных — значит, можно и производить сравнения. Чтобы можно было задействовать возможность сравнения, обычная библиотека использует сущность `std::cmp::PartialOrd`, которую вы можете использовать для определенных видов данных (смотрите ["Приложение В"] для получения больше сведений про данную сущность). Исправляя ошибку по совету сборщика, ограничим вид данных `T` теми видами данных, которые поддерживают сущность `PartialOrd`, и тогда пример успешно  собирается, так как обычная библиотека использует `PartialOrd` как для вида данных `i32`, так и для вида данных `char`.

### Изложение стопки `Struct`

Мы также можем объявить виды данных в изложении обобщённых `T` для одного или сразу нескольких полей. Для этого требуется после имени функции указать `<T>`. Приложение 10-6 показывает, как определить вид данных `Point<T>`, чтобы хранить поля координат `x` и `y` любого вида данных.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-06/src/main.rs}}
```

<span class="caption">Приложение 10-6: Стопка <code>Point</code>, содержащая поля <code>x</code> и <code>y</code> обобщенного вида данных <code>T</code></span>

Правила написания использования обобщённых видов данных для стопки такие же как и для функций. Сначала мы объявляем использование обобщенного вида данных `<T>`. Затем мы можем использовать обобщённые виды данных в изложении видов данных стопки в тех местах.

Так как мы используем только один обобщённый вид данных для определения стопки `Point<T>`, это изложение означает, что стопка `Point<T>` является обобщённой с видом данных `T`, и <em>оба</em> поля `x` и `y` используют один и тот же вид данных, каким бы он не являлся. Если мы попробуем создать образец данных - стопку `Point<T>` с двумя переменными, содержащие значения разных видов данных, как показано в приложении 10-7, будет ошибка и отказ в сборке.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-07/src/main.rs}}
```

<span class="caption">Приложение 10-7: Поля <code>x</code> и <code>y</code> должны быть одного вида данных, так как они имеют один и тот же обобщённый вид данных <code>T</code></span>

В этом примере, когда мы присваиваем целочисленное значение 5 переменной `x` , мы сообщаем сборщику, что обобщённый вид данных `T` будет целым числом для этого образца данных `Point<T>`. Затем, когда мы указываем значение 4.0 (имеющее вид данных, отличный от целого числа) для `y`, который по нашему определению должен иметь тот же вид данных, что и `x`, мы получим ошибку несоответствия видов данных:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-07/output.txt}}
```

Чтобы правильно объявить стопку `Point`, где обе переменной `x` и `y` являются обобщёнными, но различными видами данных, можно объявлять использование обобщённого вида данных несколько раз. Например, в приложении 10-8 изложение стопки `Point` выполнено таким образом, чтобы оно использовало обобщённые виды данных `T` и `U`, где `x` имеет вид данных `T` а `y` имеет вид данных `U`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-08/src/main.rs}}
```

<span class="caption">Приложение 10-8: Стопка <code>Point&lt;T, U&gt;</code> обобщена для двух видов данных, так что <code>x</code> и <code>y</code> могут быть значениями разных видов данных</span>

Теперь разрешено использовать разные виды данных для стопки `Point`! При создании стопки в `fn main()` можно использовать сколь угодно много обобщённых видов данных, но если делать это в большом количестве, рукопись будет тяжело читать. Если в вашей рукописи требуется много обобщённых видов данных, возможно, стоит разбить её на более мелкие части.

### Изложение перечислений `enum`

Как и стопки, перечисления также могут хранить обобщённые виды данных в своих исходах. Давайте ещё раз посмотрим на перечисление `Option<T>`, предоставленное встроенной библиотекой, которое мы использовали в главе 6:

```rust
enum Option<T> {
    Some(T),
    None,
}
```

Это изложение теперь должно быть вам более понятно. Как видите,  перечисление `Option<T>` является обобщённым по виду данных `T` и имеет два исхода: исход `Some`, который содержит одно значение вида данных `T`, и исход `None`, который не содержит никакого значения. Используя перечисление `Option<T>`, можно выразить абстрактный подход необязательного значения — и так как `Option<T>` является обобщённым, можно использовать эту абстракцию независимо от того, каким будет вид данных необязательного значения.

Перечисления также могут использовать несколько обобщённых видов данных. Изложение перечисления `Result`, которое мы упоминали в главе 9, является примером такого использования:

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

Перечисление `Result` имеет два обобщённых вида данных: `T` и `E` — и два исхода:  `Ok`, который содержит вид данных `T`, и `Err`, содержащий вид данных `E`. С таким изложением удобно использовать перечисление `Result` везде, где действия могут быть выполнены успешно (возвращая значение вида данных `T`) или неуспешно (возвращая ошибку вида данных `E`). Это то, что мы делали при открытии файла в приложении 9-3, где `T` заполнялось видом `std::fs::File`, если файл был открыт успешно, либо `E` заполнялось видом  `std::io::Error`, если при открытии файла возникали какие-либо сбои.

Если вы встречаете в рукописи случаи, когда несколько определений стопок или перечислений отличаются только видами данных , содержащихся в них значений, вы можете устранить повторение, используя обобщённые виды данных.

### Возможности и способы для стопок `Struct`

Мы можем использовать сущности для стопок и перечислений (как мы делали в главе 5) и в изложении этих способов также использовать обобщённые виды данных. В приложении 10-9 стопка `Point<T>`, которую мы определили в приложении 10-6, имеет встроенную функцию `fn x`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-09/src/main.rs}}
```

<span class="caption">Приложение 10-9: Использование способа с именем <code>x</code> у стопки <code>Point&lt;T&gt;</code>, которая будет возвращать ссылку на поле <code>x</code> вида данных <code>T</code></span>

Здесь мы определили способ с именем `x` у стопки `Point<T>`, который возвращает ссылку на данные в поле `x`.

Обратите внимание, что мы должны объявить `T` сразу после `impl` .  В этом случае мы можем использовать `T` для указания на то, что выполняем способ для вида данных `Point<T>`. Объявив `T` гибким видом данных сразу после `impl` , Ржавчина может определить, что вид данных в угловых скобках в `Point` является гибким, а не определенным видом данных. Мы могли бы выбрать другое имя для этого обобщённого свойства, отличное от имени, использованного в определении стопки, но обычно используют одно и то же имя. Способы, написанные внутри раздела `impl` , который использует обобщённый вид данных, будут определены для любого образца вида данных, независимо от того, какой определенный вид данных в конечном итоге будет подставлен вместо этого обобщённого.

Мы можем также указать ограничения, какие обобщённые виды данных разрешено использовать при определении способов. Например, мы могли бы использовать способы только для образцов вида данных `Point<f32>`, а не для образцов `Point<T>`, в которых используется произвольный обобщённый вид данных. В приложении 10-10 мы используем определенный вид данных `f32`, что означает, что мы не определяем никакие виды данных после `impl`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-10/src/main.rs:here}}
```

<span class="caption">Приложение 10-10: Раздел<code>impl</code>, который применяется только к стопке, имеющей определенный вид данных для свойства обобщённого вида данных <code>T</code></span>

Эта рукопись означает, что вид данных `Point<f32>` будет иметь способ с именем `distance_from_origin`, а другие образцы `Point<T>`, где `T` имеет вид данных, отличный от `f32`, не будут иметь этого способа. Способ вычисляет, насколько далеко наша точка находится от точки с координатами (0.0, 0.0), и использует математические действия, доступные только для видов данных с плавающей точкой.

Свойства обобщённого вида данных, которые мы используем в определении стопки, не всегда совпадают с подобиями, использующимися в ярлыках способов этой стопки. Чтобы пример был более очевидным, в приложении 10-11 используются обобщённые виды `X1` и `Y1` для определения стопки `Point` и виды `X2` `Y2` для ярлыки способа `mixup`. Способ создаёт новый образец данных стопки `Point`, где значение `x` берётся из `self` `Point` (имеющей вид данных `X1`), а значение `y` - из переданного стопки `Point` (где эта переменная имеет вид данных `Y2`).

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-11/src/main.rs}}
```

<span class="caption">Приложение 10-11: Способ, использующий обобщённые виды данных, отличающиеся от видов, используемых в определении стопки</span>

В функции `main` мы определили вид данных `Point`, который имеет вид данных `i32` для `x` (со значением `5` ) и вид данных `f64` для `y` (со значением `10.4`). Переменная `p2` является видом данных `Point`, которая имеет строковый срез для `x` (со значением `«Hello»`) и `char` для `y` (со значением `c`). Вызов `mixup` на `p1` с переменной `p2` создаст для нас образец данных стопки `p3`, который будет иметь вид данных `i32` для `x` (потому что `x` взят из `p1`). Переменная `p3` будет иметь вид данных `char`  для  `y` (потому что `y` взят из `p2`). Вызов макроса `println! ` выведет `p3.x = 5, p3.y = c`.

Цель этого примера — отобразить случай, в котором некоторые обобщённые свойства объявлены с помощью `impl`, а некоторые объявлены в определении способа. Здесь обобщённые свойства `X1` и `Y1` объявляются после `impl`, потому что они относятся к определению стопки. Обобщённые свойства `X2` и `Y2` объявляются после `fn mixup`, так как они относятся только к способу.

### Производительность рукописи, использующего обобщённые виды данных

Вы могли бы задаться вопросом, возникают ли какие-нибудь дополнительные издержки при использовании свойств обобщённого вида данных. Хорошая новость в том, что при использовании обобщённых видов данных ваша приложение работает ничуть ни медленнее, чем если бы она работала с использованием определенных видов данных.

В Ржавчине это достигается во время сборки при помощи мономорфизации рукописи, использующего обобщённые виды данных. *Мономорфизация* — это этап превращения обобщённого рукописи в определенный рукопись путём подстановки определенных видов данных, использующихся при сборке. В этом этапе сборщик выполняет шаги, противоположные тем, которые мы использовали для создания обобщённой функции в приложении 10-5: он просматривает все места, где вызывается обобщённый рукопись, и порождает рукопись для определенных видов, использовавшихся для вызова в обобщённом.

Давайте посмотрим, как это работает при использовании перечисления `Option<T>` из встроенной библиотеки:

```rust
let integer = Some(5);
let float = Some(5.0);
```

Когда Ржавчина собирает эту рукопись, она использует мономорфизацию. Во время этого этапа сборщик считывает значения, которые были использованы в образцах `Option<T>`, и определяет два вида данных `Option<T>`: один для вида данных `i32`, а другой — для `f64`. Таким образом, он разворачивает обобщённое изложение `Option<T>` в два определения, именно для `i32` и `f64`, тем самым заменяя обобщённое изложение определенными.

Мономорфизированная исполнение рукописи выглядит примерно так (сборщик использует имена, отличные от тех, которые мы используем здесь для отображения):

<span class="filename">Файл: src/main.rs</span>

```rust
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
```

Обобщённое `Option<T>` заменяется определенными определениями, созданными сборщиком. Поскольку Ржавчина собирает обобщённый рукопись в рукопись, определяющий вид данных в каждом образце, мы не платим за использование обобщённых видов данных во время выполнения. Когда рукопись запускается, она работает точно так же, как если бы мы сделали повторение каждого определения вручную. Этап мономорфизации делает обобщённые виды данных Ржавчины чрезвычайно производительными во время выполнения.



["Приложение В"]: appendix-03-derivable-traits.html#partialord-и-ord-для-сравнения-значений