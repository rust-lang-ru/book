## Обобщённые виды данных

Мы используем обобщённые виды данных для объявления способов (функций) или стопок, которые затем можно использовать с различными определенными видами данных. Давайте сначала посмотрим, как объявлять способы (функции), стопки, перечисления и способы, используя обобщённые виды данных. Затем мы обсудим, как обобщённые виды данных влияют на производительность рукописи.

### В объявлении способов (функций)

Когда мы объявляем способ (функцию) с обобщёнными видами данных, мы размещаем обобщённые виды данных в ярлыке способа (функции), где мы обычно указываем входные виды данных переменных и возвращаемого значения. Использование обобщённых видов данных позволяет сократить рукопись и предоставить большую возможность при вызове нашей способа (функции), предотвращая повторы рукописи.

Рассмотрим пример с функцией `наибольшее`. Приложение 10-4 показывает два способа (функции), каждая из которых находит самое большое значение в срезе своего вида данных. Позже мы объединим их в одну способ (функцию), использующую обобщённые виды данных.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-04/src/main.rs:here}}
```

<span class="caption">Приложение 10-4: Два способа (функции), отличающиеся только именем и видом обрабатываемых данных</span>

Способ (функция) `наибольший_i32` уже встречалась нам: мы извлекли её из приложения 10-3, когда решили уменьшить рукопись — она находит наибольшее значение среди среза `[..]` вида данных `i32`. Способ (функция) `наибольший_знак` находит самое большое значение  среди среза `[..]` вида данных `char`. Тело у этих способов (функций) одинаковое, поэтому давайте сократим нашу рукопись, используя обобщённый вид данных `T` и его возможности, поместив всё в одну способ (функцию).

В новой объявляемом способе (функции) нам нужно указать в ярлыке способа (функции) изложение обобщённого вида данных `T` — так же, как мы это делаем во всех остальных способ (функция)х. Можно использовать любой определитель для имени свойства вида данных, но мы будем использовать `T`, потому что согласно правил Ржавчины, изложение вида данных  должно быть коротким (обычно длиной в один знак), а объявление составных видов данных в Ржавчине производится по правилу отсутствия знаков разделения между словами (таких как пробел, `-` `_` и т.д.) и заглавной буквы в начале каждого слова, например `СтопкаЗнаков` или `СтопкаЦелыхЧисел` согласно английскому правилу - UpperCamelCase. Сокращение слова «вид» («type») до одной буквы `T` является самым распространёнными выбором большинства разработчиков ПО, использующих язык Ржавчина.

Когда мы используем переменную в теле способа (функции), мы должны изложить данную переменную в ярлыке способа (функции), чтобы сборщик знал, её вид данных и имя. Подобно когда мы используем переменную в теле способа (функции), мы должны объявить раньше в самом ярлыке способа (функции), прежде чем мы её используем. Чтобы ввести обобщённую способ (функцию) `наибольшее`, необходимо указать особый признаки (треугольных скобки `<>`) при объявлении самого способа (функции) после её имени перед изложением видов данных `fn наибольшее<T>`, полный пример ниже:

```rust,ignore
fn наибольшее<T>(список: &[T]) -> &T {
```

Объявление читается так: способ (функция) `наибольшее` является обобщённой по виду данных `T`. Этот способ (функция) имеет одну переменную с именем `список`, который является ссылкой на срез значений вида данных `T`. Способ (функция) `наибольшее` возвращает ссылку на этот же вид данных `T`.

Приложение 10-5 определён способ (функция) `наибольшее` с использованием обобщённого вида данных в её ярлыке. Указано как мы можем вызвать способ (функцию) со ссылкой на срез вида данных `i32` или `char`. Данная рукопись имеет ошибки и не может быть собрана, к концу раздела мы внесём необходимые правки.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-05/src/main.rs}}
```

<span class="caption">Приложение 10-5: Способ (функция) <code>наибольшее</code>, использующая обобщённый вид данных. В настоящее время не доведена до работоспособного состояния</span>

При попытке собрать рукопись в исполняемое приложение, мы получим следующую ошибку:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-05/output.txt}}
```

В подсказке указана *сущность* `std::cmp::PartialOrd`. Мы поговорим про сущности в следующем разделе. Сейчас ошибка в способе (функции) `наибольшее` указывает, что способ (функция) не будет работать для всех возможных видов данных `T`. Так как мы хотим сравнивать значения вида данных `T` в теле способа (функции), мы можем использовать только те виды данных, для которых применима сущность `std::cmp::PartialOrd`. Если можно упорядочить вид данных — значит, можно и производить сравнения. Чтобы можно было задействовать возможность сравнения, встроенная библиотека использует сущность `std::cmp::PartialOrd`, которую вы можете использовать для определенных видов данных (смотрите ["Приложение В"] для получения больше сведений про данную сущность). Исправляя ошибку по совету сборщика, ограничим вид данных `T` теми видами данных, которые поддерживают сущность `PartialOrd`, и тогда пример успешно  собирается, так как встроенная библиотека использует `PartialOrd` как для вида данных `i32`, так и для вида данных `char`.

### Изложение стопки `Struct`

Мы также можем объявить виды данных в изложении обобщённых `T` для одного или сразу нескольких полей. Для этого требуется после имени способа (функции) указать `<T>`. Приложение 10-6 показывает, как определить вид данных `Point<T>`, чтобы хранить поля координат `x` и `y` любого вида данных.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-06/src/main.rs}}
```

<span class="caption">Приложение 10-6: Стопка <code>Point</code>, содержащая поля <code>x</code> и <code>y</code> обобщенного вида данных <code>T</code></span>

Правила написания использования обобщённых видов данных для стопки такие же как и для способов (функций). Сначала мы объявляем использование обобщенного вида данных `<T>`. Затем мы можем использовать обобщённые виды данных в изложении видов данных стопки в тех местах.

Так как мы используем только один обобщённый вид данных для определения стопки `Point<T>`, это изложение означает, что стопка `Point<T>` является обобщённой с видом данных `T`, и <em>оба</em> поля `x` и `y` используют один и тот же вид данных, каким бы он не являлся. Если мы попробуем создать образец данных - стопку `Point<T>` с двумя переменными, содержащие значения разных видов данных, как показано в приложении 10-7, будет ошибка и отказ в сборке.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-07/src/main.rs}}
```

<span class="caption">Приложение 10-7: Поля <code>x</code> и <code>y</code> должны быть одного вида данных, так как они имеют один и тот же обобщённый вид данных <code>T</code></span>

В этом примере, когда мы присваиваем целочисленное значение 5 переменной `x` , мы сообщаем сборщику, что обобщённый вид данных `T` будет целым числом для этого образца данных `Point<T>`. Затем, когда мы указываем значение 4.0 (имеющее вид данных, отличный от целого числа) для `y`, который по нашему определению должен иметь тот же вид данных, что и `x`, мы получим ошибку несоответствия видов данных:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-07/output.txt}}
```

Чтобы правильно объявить стопку `Point`, где обе переменной `x` и `y` являются обобщёнными, но различными видами данных, можно объявлять использование обобщённого вида данных несколько раз. Например, в приложении 10-8 изложение стопки `Point` выполнено таким образом, чтобы оно использовало обобщённые виды данных `T` и `U`, где `x` имеет вид данных `T` а `y` имеет вид данных `U`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-08/src/main.rs}}
```

<span class="caption">Приложение 10-8: Стопка <code>Point&lt;T, U&gt;</code> обобщена для двух видов данных, так что <code>x</code> и <code>y</code> могут быть значениями разных видов данных</span>

Теперь разрешено использовать разные виды данных для стопки `Point`! При создании стопки в `fn main()` можно использовать сколь угодно много обобщённых видов данных, но если делать это в большом количестве, рукопись будет тяжело читать. Если в вашей рукописи требуется много обобщённых видов данных, возможно, стоит разбить её на более мелкие части.

### Изложение перечислений `enum`

Как и стопки, перечисления также могут использовать обобщённые виды данных в своих исходах. Давайте ещё раз посмотрим на перечисление `Option<T>`, предоставленное встроенной библиотекой, которое мы использовали ранее в главе 6:

```rust
enum Option<T> {
    Some(T),
    None,
}
```

Это изложение теперь должно быть вам более понятно. Как видите,  перечисление `Option<T>` является обобщённым по виду данных `T` и имеет два исхода: исход `Some`, который содержит любое значение вида данных `T`, и исход `None`, который не содержит совсем ничего. Используя перечисление `Option<T>`, можно выразить абстрактный подход необязательного значения — и так как перечисление `Option<T>` является обобщённым, можно использовать эту абстракцию независимо от того, с каким видом данных данное перечисление мы будем использовать.

Перечисления также могут использовать несколько обобщённых видов данных. Изложение перечисления `Result`, которое мы упоминали в главе 9, является примером такого использования:

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

Перечисление `Result` содержит два обобщённых вида данных: `T` и `E` — и два исхода: успех -  `Ok`, который содержит обобщённый вид данных `T`, и  ошибку -`Err`, содержащий вид данных `E`. С таким изложением удобно использовать перечисление `Result` везде, где действия могут быть 2 исхода: успех (возвращая значение вида данных `T`) или ошибку (возвращая полученную ошибку вида данных `E`). Это то, что мы делали при открытии файла в приложении 9-3, где `T` возвращало содержимое исхода `std::fs::File` в случае успеха, либо ошибка - `E` возвращало содержимое исхода  `std::io::Error`, если при открытии файла возникали какие-либо сбои.

Если вы встречаете в рукописи случаи, когда несколько стопок или перечислений отличаются только изложениями видов данных,  вы можете их объединить, используя обобщённые виды данных.

### Возможности и способы для стопок `Struct`

Мы можем использовать сущности для стопок и перечислений (как мы делали в главе 5) и в изложении этих способов также использовать обобщённые виды данных. В приложении 10-9 стопка `Point<T>`, которую мы определили в приложении 10-6, имеет встроенную способ (функцию) `fn x`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-09/src/main.rs}}
```

<span class="caption">Приложение 10-9: Использование способа с именем <code>x</code> у стопки <code>Point&lt;T&gt;</code>, которая будет возвращать ссылку на переменную <code>x</code> вида данных <code>T</code> стопки `Point <T>`</span>

Здесь мы определили способ с именем `x` у стопки `Point<T>`, который возвращает ссылку на переменную `x`, объявленную в самой стопке `Point<T>`.

Обратите внимание, что мы должны объявить использование обобщенного вид данных`T` сразу после `impl` .  В этом случае мы можем использовать обобщенный вид данных `T` для указания на то, что используем способ для обобщенной стопки `Point<T>`. Объявив использование обобщенного вида данных `T`  сразу после `impl` , Ржавчина принимает решение, что вид данных в угловых скобках у стопки `Point` является обобщенным, а не определенным видом данных. Мы могли бы выбрать другое имя для этого обобщённого свойства в разделе `impl`, отличное от имени, использованного в определении стопки `Point<T>`, но обычно используют одно и то же обозначение. Способы, изложенные внутри раздела `impl` , который использует обобщённый вид данных, будут применяться для любого образца вида данных `<T>`, независимо от того, какой именно вид данных будет передан при оборачивании в обобщённый вид данных `<T>`.

Мы можем также указать ограничения, какие обобщённые виды данных разрешено использовать при вызове способов. Например, можно ограничить вызов способов только для значений вида данных `Point<f32>`, а не для всех возможных значений `Point<T>`, в который оборачивается любой произвольный обобщённый вид данных из всех доступных в Ржавчине. В приложении 10-10 для стопки `Point` мы строго указываем вид данных `f32`, это означает, что другие виды данных не поддерживаются `impl` и не будут использоваться.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-10/src/main.rs:here}}
```

<span class="caption">Приложение 10-10: Раздел<code>impl</code>, который применяется только к стопке, имеющей строго определенный вид данных `f32` для обобщённого вида данных <code>T</code></span>

Эта рукопись означает, что вид данных `Point<f32>` содержит способ с именем `расстояние_от_источника`, стопки `Point<T>` с другими видами данных `<T>`, отличных от `f32`, не смогут использовать этот способ. Способ производит расчёты - насколько далеко наша точка находится от точки с координатами (0.0, 0.0). Данный способ использует математические действия с видом данных `f32`, доступные исключительно для видов данных с плавающей точкой.

Обобщённые вида данных, которые мы объявляем в определении стопки, не всегда можно использовать с сущностями и со способами, которые будут объявлены позже. Чтобы пример был более очевидным, в приложении 10-11 используются обобщённые виды `X1` и `Y1` при изложении стопки `Point` и обобщённые виды `X2` `Y2` в изложении способа `mixup`. Способ создаёт новый образец данных стопки `Point`, где значение `x` берётся из `self` `Point` (имеющей вид данных `X1`), а значение переменной `y` - из переданной переменной `Y2`  стопке `Point` (где эта переменная имеет вид данных `Y2`).

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-11/src/main.rs}}
```

<span class="caption">Приложение 10-11: Способ, использующий разные обобщённые виды данных</span>

В способе (функции) `main` мы создаём стопку `Point`, которая имеет 2 переменных: вид данных `i32` для переменной `x` (со значением `5` ) и вид данных `f64` для переменной `y` (со значением `10.4`). Переменная `p2` является стопкой `Point`, которая содержит в себе строковый срез для переменной `x` (со значением `«Здравствуй»`) и знаковый вид данных `char` для переменной `y` (со значением `c`). Вызов способа `mixup` для стопки `p1` , при этом передавая способ переменную через свойство способа `p2` , то получим стопку `p3` вида `Point<<X1, Y1>`, которая будет содержать 2 вида данных: `i32` для переменной `x` (потому что `x` взят из стопки `p1`). Стопка `p3` будет содержать знаковый вид данных `char` для переменной `y` (потому что `y` взят из стопки `p2`). Вызов макроса `println!` выведет `p3.x = 5, p3.y = c`.

Цель этого примера — показать случай, в котором одни обобщённые виды данных объявлены в `impl`, а другие объявлены в определении самого способа `mixup`. Здесь обобщённые виды данных `X1` и `Y1` объявляются после `impl`, потому что они относятся к определению стопки. Обобщённые вида данных `X2` и `Y2` объявляются после `fn mixup`, так как они относятся только к способу.

### Производительность рукописи, использующего обобщённые виды данных

Вы могли бы задаться вопросом, возникают ли какие-нибудь дополнительные издержки при использовании обобщённых вида данных. Хорошая новость в том, что при использовании обобщённых видов данных, ваше приложение работает ничуть ни медленнее, чем если бы оно работало с использованием определенных видов данных.

В Ржавчине это достигается во время сборки при помощи мономорфизации рукописи, использующей обобщённые виды данных. *Мономорфизация* — это этап преобразования обобщённых видов данных в определенный вид данных путём подстановки определенных видов данных, использующихся при сборке. На этом этапе сборщик выполняет шаги, противоположные тем, которые мы использовали для создания обобщённой способы (функции) в приложении 10-5: он просматривает все места, где вызываются обобщённые вида данных, и порождает рукопись для определенных видов данных, которые вызываются в обобщенных способах
.

Давайте посмотрим, как это работает при использовании перечисления `Option<T>` из встроенной библиотеки:

```rust
let integer = Some(5);
let float = Some(5.0);
```

Когда Ржавчина собирает эту рукопись, она использует мономорфизацию. Во время этого этапа сборщик считывает значения, которые были использованы в образцах `Option<T>`, и определяет два вида данных `Option<T>`: один для вида данных `i32`, а другой — для `f64`. Таким образом, он разворачивает обобщённое изложение `Option<T>` в два определения, именно для `i32` и `f64`, тем самым заменяя обобщённое изложение определенными.

Мономорфизированное исполнение рукописи выглядит примерно так (сборщик использует имена, отличные от тех, которые мы используем здесь для отображения):

<span class="filename">Файл: src/main.rs</span>

```rust
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
```

Обобщённый вид данных `Option<T>` заменяется определенными видами данных, обёрнутыми в `Option`, созданными сборщиком. Поскольку Ржавчина собирает обобщённую рукопись в исполняемое приложение, определяя виды данных каждый раз, нет никаких издержек за использование обобщённых видов данных во время выполнения приложения. Когда рукопись запускается, она работает точно так же, как если бы мы указали принудительно каждый вид данных вручную. Этап мономорфизации даёт возможности использовать обобщённые виды данных Ржавчины без утраты производительности во время выполнения приложения. 



["Приложение В"]: appendix-03-derivable-traits.html#partialord-и-ord-для-сравнения-значений