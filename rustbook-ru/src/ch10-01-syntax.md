## Обобщённые виды данных

Мы используем обобщённые виды данных для объявления функций или стопок, которые затем можно использовать с различными определенными видами данных. Давайте сначала посмотрим, как объявлять функции, стопки, перечисления и способы, используя обобщённые виды данных. Затем мы обсудим, как обобщённые виды данных влияют на производительность рукописи.

### В объявлении функций

Когда мы объявляем функцию с обобщёнными видами данных, мы размещаем обобщённые виды данных в ярлыке функции, где мы обычно указываем виды данных переменных и возвращаемого значения. Используя обобщённые виды данных, мы делаем рукопись более гибким и предоставляем большую возможность при вызове нашей функции, предотвращая повторение рукописи.

Рассмотрим пример с функцией `largest`. Приложение 10-4 показывает две функции, каждая из которых находит самое большое значение в срезе своего вида данных. Позже мы объединим их в одну функцию, использующую обобщённые виды данных.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-04/src/main.rs:here}}
```

<span class="caption">Приложение 10-4: Две функции, отличающиеся только именем и видом обрабатываемых данных</span>

Функция `largest_i32` уже встречалась нам: мы извлекли её в приложении 10-3, когда боролись с повторением рукописи — она находит наибольшее значение вида данных `i32` в срезе. Функция `largest_char` находит самое большое значение вида данных `char` в срезе. Тело у этих функций одинаковое, поэтому давайте избавимся от повторной рукописи, используя свойство обобщённого вида данных в одной функции.

Для изменения свойств видов данных, в новой объявляемой функции нам нужно дать имя обобщённому виду данных — так же, как мы это делаем для переменных функций. Можно использовать любой определитель для имени свойства вида данных, но мы будем использовать `T`, потому что по соглашению имена свойств в Ржавчине должны быть короткими (обычно длиной в один знак), а именование видов данных в Ржавчине делается в наставлении UpperCamelCase. Сокращение слова «type» до одной буквы `T` является обычным выбором большинства программистов, использующих язык Ржавчина.

Когда мы используем свойство в теле функции, мы должны объявить имя свойства в ярлыке, чтобы сборщик знал, что означает это имя. Подобно когда мы используем имя вида данных свойства в ярлыке функции, мы должны объявить это имя раньше, чем мы его используем. Чтобы определить обобщённую функцию `largest`, поместим объявление имён свойств в треугольные скобки `<>` между именем функции и списком свойств, как здесь:

```rust,ignore
fn largest<T>(list: &[T]) -> &T {
```

Объявление читается так: функция `largest` является обобщённой по виду данных `T`. Эта функция имеет одно свойство с именем `list`, который является срезом значений с видом данных `T`. Функция `largest` возвращает значение этого же вида данных `T`.

Приложение 10-5 показывает определение функции `largest` с использованием обобщённых видов данных в её ярлыке. Приложение также показывает, как мы можем вызвать функцию со срезом данных вида данных `i32` или `char`. Данная рукопись пока не будет собираться, но мы исправим это к концу раздела.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-05/src/main.rs}}
```

<span class="caption">Приложение 10-5: Функция <code>largest</code>, использующая свойства обобщённого вида данных; пока ещё не собирается</span>

Если мы соберем программу сейчас, мы получим следующую ошибку:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-05/output.txt}}
```

В подсказке упоминается `std::cmp::PartialOrd`, который является *сущностью*. Мы поговорим про сущности в следующем разделе. Сейчас ошибка в функции `largest` указывает, что функция не будет работать для всех возможных видов данных `T`. Так как мы хотим сравнивать значения вида данных `T` в теле функции, мы можем использовать только те виды данных, данные которых можно упорядочить: можем упорядочить — значит, можем и сравнить. Чтобы можно было задействовать сравнения, обычная библиотека имеет сущность `std::cmp::PartialOrd`, который вы можете использовать для видов данных (смотрите дополнение С для больших сведений про данную сущность). Следуя совету в сообщении сборщика, ограничим вид данных `T` теми исходами, которые поддерживают сущность `PartialOrd`, и тогда пример успешно  собирается, так как обычная библиотека использует `PartialOrd` как для вида данных `i32`, так и для вида данных `char`.

### Определение видов данных

Мы также можем определить вид данных, использующие обобщённые виды в одном или нескольких своих полях, с помощью правил написания `<>`. Приложение 10-6 показывает, как определить вид данных `Point<T>`, чтобы хранить поля координат `x` и `y` любого вида данных.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-06/src/main.rs}}
```

<span class="caption">Приложение 10-6: Стопки <code>Point</code>, содержащая поля <code>x</code> и <code>y</code> вида данных <code>T</code></span>

Правила написания использования обобщённых видов данных в определении стопки очень похож на правила написания в определении функции. Сначала мы объявляем имена видов данных свойств внутри треугольных скобок сразу после названия стопки. Затем мы можем использовать обобщённые виды данных в определении стопки в тех местах, где ранее мы указывали бы определенные виды данных.

Так как мы используем только один обобщённый вид данных для определения стопки `Point<T>`, это определение означает, что стопка `Point<T>` является обобщённой с видом данных `T`, и <em>оба</em> поля `x` и <code>y</code> имеют одинаковый вид данных, каким бы он не являлся. Если мы создадим образец данных стопки `Point<T>` со значениями разных видов данных, как показано в приложении 10-7, наша рукопись не соберется.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-07/src/main.rs}}
```

<span class="caption">Приложение 10-7: Поля <code>x</code> и <code>y</code> должны быть одного вида данных, так как они имеют один и тот же обобщённый вид данных <code>T</code></span>

В этом примере, когда мы присваиваем целочисленное значение 5 переменной `x` , мы сообщаем сборщику, что обобщённый вид данных `T` будет целым числом для этого образца данных `Point<T>`. Затем, когда мы указываем значение 4.0 (имеющее вид данных, отличный от целого числа) для `y`, который по нашему определению должен иметь тот же вид данных, что и `x`, мы получим ошибку несоответствия видов данных:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-07/output.txt}}
```

Чтобы определить вид данных `Point`, где оба значения `x` и `y` являются обобщёнными, но различными видами данных, можно использовать несколько свойств обобщённого вида данных. Например, в приложении 10-8 мы изменим определение `Point` таким образом, чтобы оно использовало обобщённые виды данных `T` и `U`, где `x` имеет вид данных `T` а `y` имеет вид данных `U`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-08/src/main.rs}}
```

<span class="caption">Приложение 10-8: Стопки <code>Point&lt;T, U&gt;</code> обобщена для двух видов данных, так что <code>x</code> и <code>y</code> могут быть значениями разных видов данных</span>

Теперь разрешены все показанные образцы вида данных `Point`! В объявлении можно использовать сколь угодно много свойств обобщённого вида данных, но если делать это в большом количестве, рукопись будет тяжело читать. Если в вашей рукописи требуется много обобщённых видов данных, возможно, стоит разбить её на более мелкие части.

### В определениях перечислений

Как и стопки, перечисления также могут хранить обобщённые виды данных в своих исходах. Давайте ещё раз посмотрим на перечисление `Option<T>`, предоставленное встроенной библиотекой, которое мы использовали в главе 6:

```rust
enum Option<T> {
    Some(T),
    None,
}
```

Это определение теперь должно быть вам более понятно. Как видите,  перечисление `Option<T>` является обобщённым по виду данных `T` и имеет два исхода: исход `Some`, который содержит одно значение вида данных `T`, и исход `None`, который не содержит никакого значения. Используя перечисление `Option<T>`, можно выразить абстрактную подход необязательного значения — и так как `Option<T>` является обобщённым, можно использовать эту абстракцию независимо от того, каким будет вид данных необязательного значения.

Перечисления также могут использовать несколько обобщённых видов данных. Определение перечисления `Result`, которое мы упоминали в главе 9, является примером такого использования:

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

Перечисление `Result` имеет два обобщённых вида данных: `T` и `E` — и два исхода:  `Ok`, который содержит вид данных `T`, и `Err`, содержащий вид данных `E`. С таким определением удобно использовать перечисление `Result` везде, где действия могут быть выполнены успешно (возвращая значение вида данных `T`) или неуспешно (возвращая ошибку вида данных `E`). Это то, что мы делали при открытии файла в приложении 9-3, где `T` заполнялось видом `std::fs::File`, если файл был открыт успешно, либо `E` заполнялось видом  `std::io::Error`, если при открытии файла возникали какие-либо сбои.

Если вы встречаете в рукописи случаи, когда несколько определений стопок или перечислений отличаются только видами данных , содержащихся в них значений, вы можете устранить повторение, используя обобщённые виды данных.

### В определении стопок

Мы можем использовать способы для стопок и перечислений (как мы делали в главе 5) и в определениях этих способов также использовать обобщённые виды данных. В приложении 10-9 показана стопки `Point<T>`, которую мы определили в приложении 10-6, с добавленным для неё способом `x`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-09/src/main.rs}}
```

<span class="caption">Приложение 10-9: Использование способа с именем <code>x</code> у стопки <code>Point&lt;T&gt;</code>, которая будет возвращать ссылку на поле <code>x</code> вида данных <code>T</code></span>

Здесь мы определили способ с именем `x` у стопки `Point<T>`, который возвращает ссылку на данные в поле `x`.

Обратите внимание, что мы должны объявить `T` сразу после `impl` .  В этом случае мы можем использовать `T` для указания на то, что выполняем способ для вида данных `Point<T>`. Объявив `T` гибким видом данных сразу после `impl` , Ржавчина может определить, что вид данных в угловых скобках в `Point` является гибким, а не определенным видом данных. Мы могли бы выбрать другое имя для этого обобщённого свойства, отличное от имени, использованного в определении стопки, но обычно используют одно и то же имя. Способы, написанные внутри раздела `impl` , который использует обобщённый вид данных, будут определены для любого образца вида данных, независимо от того, какой определенный вид данных в конечном итоге будет подставлен вместо этого обобщённого.

Мы можем также указать ограничения, какие обобщённые виды данных разрешено использовать при определении способов. Например, мы могли бы использовать способы только для образцов вида данных `Point<f32>`, а не для образцов `Point<T>`, в которых используется произвольный обобщённый вид данных. В приложении 10-10 мы используем определенный вид данных `f32`, что означает, что мы не определяем никакие виды данных после `impl`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-10/src/main.rs:here}}
```

<span class="caption">Приложение 10-10: Раздел<code>impl</code>, который применяется только к стопке, имеющей определенный вид данных для свойства обобщённого вида данных <code>T</code></span>

Эта рукопись означает, что вид данных `Point<f32>` будет иметь способ с именем `distance_from_origin`, а другие образцы `Point<T>`, где `T` имеет вид данных, отличный от `f32`, не будут иметь этого способа. Способ вычисляет, насколько далеко наша точка находится от точки с координатами (0.0, 0.0), и использует математические действия, доступные только для видов данных с плавающей точкой.

Свойства обобщённого вида данных, которые мы используем в определении стопки, не всегда совпадают с подобиями, использующимися в ярлыках способов этой стопки. Чтобы пример был более очевидным, в приложении 10-11 используются обобщённые виды `X1` и `Y1` для определения стопки `Point` и виды `X2` `Y2` для ярлыки способа `mixup`. Способ создаёт новый образец данных стопки `Point`, где значение `x` берётся из `self` `Point` (имеющей вид данных `X1`), а значение `y` - из переданного стопки `Point` (где эта переменная имеет вид данных `Y2`).

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-11/src/main.rs}}
```

<span class="caption">Приложение 10-11: Способ, использующий обобщённые виды данных, отличающиеся от видов, используемых в определении стопки</span>

В функции `main` мы определили вид данных `Point`, который имеет вид данных `i32` для `x` (со значением `5` ) и вид данных `f64` для `y` (со значением `10.4`). Переменная `p2` является видом данных `Point`, которая имеет строковый срез для `x` (со значением `«Hello»`) и `char` для `y` (со значением `c`). Вызов `mixup` на `p1` с переменной `p2` создаст для нас образец данных стопки `p3`, который будет иметь вид данных `i32` для `x` (потому что `x` взят из `p1`). Переменная `p3` будет иметь вид данных `char`  для  `y` (потому что `y` взят из `p2`). Вызов макроса `println! ` выведет `p3.x = 5, p3.y = c`.

Цель этого примера — отобразить случай, в котором некоторые обобщённые свойства объявлены с помощью `impl`, а некоторые объявлены в определении способа. Здесь обобщённые свойства `X1` и `Y1` объявляются после `impl`, потому что они относятся к определению стопки. Обобщённые свойства `X2` и `Y2` объявляются после `fn mixup`, так как они относятся только к способу.

### Производительность рукописи, использующего обобщённые виды данных

Вы могли бы задаться вопросом, возникают ли какие-нибудь дополнительные издержки при использовании свойств обобщённого вида данных. Хорошая новость в том, что при использовании обобщённых видов данных ваша программа работает ничуть ни медленнее, чем если бы она работала с использованием определенных видов данных.

В Ржавчине это достигается во время сборки при помощи мономорфизации рукописи, использующего обобщённые виды данных. *Мономорфизация* — это этап превращения обобщённого рукописи в определенный рукопись путём подстановки определенных видов данных, использующихся при сборке. В этом этапе сборщик выполняет шаги, противоположные тем, которые мы использовали для создания обобщённой функции в приложении 10-5: он просматривает все места, где вызывается обобщённый рукопись, и порождает рукопись для определенных видов, использовавшихся для вызова в обобщённом.

Давайте посмотрим, как это работает при использовании перечисления `Option<T>` из встроенной библиотеки:

```rust
let integer = Some(5);
let float = Some(5.0);
```

Когда Ржавчина собирает эту рукопись, она использует мономорфизацию. Во время этого этапа сборщик считывает значения, которые были использованы в образцах `Option<T>`, и определяет два вида данных `Option<T>`: один для вида данных `i32`, а другой — для `f64`. Таким образом, он разворачивает обобщённое определение `Option<T>` в два определения, именно для `i32` и `f64`, тем самым заменяя обобщённое определение определенными.

Мономорфизированная исполнение рукописи выглядит примерно так (сборщик использует имена, отличные от тех, которые мы используем здесь для отображения):

<span class="filename">Файл: src/main.rs</span>

```rust
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
```

Обобщённое `Option<T>` заменяется определенными определениями, созданными сборщиком. Поскольку Ржавчина собирает обобщённый рукопись в рукопись, определяющий вид данных в каждом образце, мы не платим за использование обобщённых видов данных во время выполнения. Когда рукопись запускается, она работает точно так же, как если бы мы сделали повторение каждого определения вручную. Этап мономорфизации делает обобщённые виды данных Ржавчины чрезвычайно производительными во время выполнения.


