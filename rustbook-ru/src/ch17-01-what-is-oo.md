## Свойства предметно-направленных языков

В сообществе программистов нет единого мнения о том, какими свойствами должен обладать язык, чтобы считаться предметно-направленным. На Ржавчине повлияли многие парадигмы программирования, включая ООП - например, в главе 13 мы изучали сущности, пришедшие из функционального программирования. Однозначно можно утверждать, что ООП-языкам присущи следующие присущие сущности: предметы, инкапсуляция и наследование. Давайте рассмотрим, что каждая из них означает и поддерживает ли их Ржавчина.

### Предметы содержат данные и поведение

Книга *Приёмы предметно-направленной разработки. Образцы разработки* Erich Gamma, Richard Helm, Ralph Johnson, и John Vlissides (Addison-Wesley Professional, 1994), в просторечии называемая *Книга банды четырёх*, представляет собой сборник примеров предметно-направленной разработки. В ней даётся следующее определение ООП:

> Предметно-направленные программы состоят из предметов. *Предмет* представляет собой сущность, своего рода дополнение, с данными и процедурами, которые работают с этими данными. Процедуры обычно называются *способами* или *действиеми*.

В соответствии с этим определением, Ржавчина является предметно-направленным языком - в стопках и перечислениях содержатся данные, а в х `impl` определяются способы для них. Хотя стопки и перечисления, имеющие способы, не *называются* предметами, они обеспечивают  возможность, соответствующую определению предметов в книге банды четырёх.

### Инкапсуляция, скрывающая подробности выполнения

Другой особенностью, обычно связанной с предметно-направленным программированием, является мысль *инкапсуляции*: подробности выполнения предмета недоступны для рукописи, использующей этот предмет. Единственный способ взаимодействия с предметом — через его открытую внешнюю оболочку; рукопись, использующая этот предмет, не должна иметь возможности взаимодействовать с внутренними свойствами предметами напрямую изменять его данные или поведение. Инкапсуляция позволяет изменять и ресоздавать внутренние свойства предмета без необходимости изменять саму рукопись, которая использует предмет.

В главе 7 мы уже говорили о том, как управлять инкапсуляцией: мы можем использовать ключевое слово `pub`, чтобы определить, какие разделы, виды данных, функции и способы в нашей рукописи будут открытыми, а всё остальное по умолчанию будет закрытыми. Например, мы можем определить стопку `AveragedCollection`, в которой есть поле, содержащее вектор значений вида данных `i32`. Также, стопка будет иметь поле, содержащее среднее арифметическое чисел этого вектора, таким образом, среднее не нужно будет вычислять каждый раз, когда оно кому-то понадобится. Другими словами, `AveragedCollection` будет кэшировать вычисленное среднее для нас. В приложении 17-1 приведено определение стопки `AveragedCollection`:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch17-oop/listing-17-01/src/lib.rs}}
```

<span class="caption">Приложение 17-1: Стопка <code>AveragedCollection</code> содержит список целых чисел и их среднее арифметическое.</span>

Обратите внимание, что стопка помечена ключевым словом `pub`, что позволяет другому рукописи её использовать, однако, поля стопки остаются недоступными. Это важно, потому что мы хотим обеспечить обновление среднего значения при добавлении или удалении переменной из списка. Мы можем получить нужное поведение, определив в стопке способы `add`, `remove` и `average`, как показано в примере 17-2:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch17-oop/listing-17-02/src/lib.rs:here}}
```

<span class="caption">Приложение 17-2: Выполнение открытых способов <code>add</code>,<code>remove</code>, и <code>average</code> для <code>AveragedCollection</code></span>

Открытые способы `add`, `remove` и `average` являются единственным способом получить или изменить данные в образце `AveragedCollection`. Когда переменная добавляется в `list` способом `add`, или удаляется с помощью способа `remove`, рукопись выполнения каждого из этих способов вызывает закрытый способ `update_average`, который позаботится об обновлении поля `average`.

Мы оставляем поля `list` и `average` закрытыми, чтобы внешняя рукопись не могла добавлять или удалять переменные непосредственно в поле `list`; в противном случае поле `average` может оказаться не согласовано при подобном вмешательстве. Способ `average` возвращает значение в поле `average`, что позволяет внешней рукописи читать значение `average`, но не изменять его.

Поскольку мы инкапсулировали подробности выполнения стопки `AveragedCollection`, мы можем легко изменить такие особенности, как вида данных, в будущем. Например, мы могли бы использовать `HashSet<i32>` вместо `Vec<i32>` для поля `list`. Благодаря тому, что ярлыки открытых способов `add`, `remove` и `average` остаются неизменными, рукопись, использующая `AveragedCollection`, также не будет нуждаться в изменении. У нас бы не получилось этого достичь, если бы мы сделали поле `list` доступным внешней рукописи: `HashSet<i32>` и`Vec<i32>` имеют разные способы для добавления и удаления переменных, поэтому внешняя рукопись, вероятно, должна измениться, если она изменяет `list` напрямую.

Если инкапсуляция является обязательной особенностью для определения языка как предметно-направленного, то Ржавчина соответствует этому требованию. Возможность использовать или не использовать изменитель доступа `pub` для различных частей рукописи позволяет скрыть подробности выполнения.

### Наследование как перечень видов данных и способ совместного использования рукописи

*Наследование* — это рычаг, с помощью которого предмет может унаследовать переменные из определения другого предмета. то есть получить данные и поведение родительского предмета без необходимости повторно их определять.

Если язык должен иметь наследование, чтобы быть предметно-направленным, то Ржавчина таким не является. Здесь нет способа определить вид данных, наследующий поля и выполнения способов родительского вид данных, без использования макроса.

Однако, если вы привыкли иметь наследование в своём наборе средств для программирования, вы можете использовать другие решения в Ржавчине, в зависимости от того, по какой причине вы изначально хотите использовать наследование.

Вы могли бы выбрать наследование по двум основным причинам. Одна из них - возможность повторного использования рукописи: вы можете использовать определённое поведение для одного вида данных, а наследование позволит вам повторно использовать эту выполнение для другого вида данных. В Ржавчине для этого есть ограниченный способ, использующий использование способа сущности по умолчанию, который вы видели в приложении 10-14, когда мы добавили выполнение по умолчанию в способе `summarize` сущности `Summary`. Любой вид данных, использующий свойство `Summary` будет иметь доступный способ `summarize` без дополнительного рукописи. Это похоже на то, как родительский класс имеет использование способа, и класс-наследник тоже имеет использование способа. Мы также можем переопределить выполнение по умолчанию для способа `summarize`, когда выполняем сущность `Summary`, что похоже на дочерний класс, переопределяющий использование способа, унаследованного от родительского класса.

Вторая причина использования наследования относится к перечню видов данных: чтобы иметь возможность использовать дочерний вид данных в тех же места, что и родительский. Эта возможность также называется *полиморфизм* и означает возможность подменять предметы во время исполнения, если они имеют одинаковые свойства.

> ### Полиморфизм
>
> Для многих людей полиморфизм является родственным наследования. Но на самом деле это более общая подход, относящаяся к рукописи, которая может работать с данными нескольких видов данных. Обычно такими видами данных выступают подклассы при наследовании.
>
> Вместо этого Ржавчина использует обобщённые виды данных для абстрагирования от видов данных, и ограничения сущностей (trait bounds) для указания того, какие возможности эти виды данных должны предоставлять. Это иногда называют *ограниченным свойствоическим полиморфизмом*.

Наследование, как подход к разработке, в последнее время утратило распространенность во многих языках программирования, поскольку часто существует риск, что мы будем наследовать рукопись чаще, чем это необходимо. Подклассы не всегда должны обладать всеми свойствами родительского класса, но при использовании наследования другого исхода нет. Это может сделать внешний вид программы менее гибким. Кроме этого, появляется возможность вызова у подклассов способов, которые не имеют смысла или вызывают ошибки, потому что эти способы неприменимы к подклассу. Кроме того, в некоторых языках разрешается только одиночное наследование (т.е. подкласс может наследоваться только от одного класса), что ещё больше ограничивает гибкость разработки программы.

По этим причинам в Ржавчине применяется иной подход, с использованием сущностей-предметов вместо наследования. Давайте посмотрим как сущности-предметы выполняют полиморфизм в Ржавчине.
