## Приложение A: Ключевые слова

Следующий список содержит ключевые слова, забронированные для текущего или будущего использования в языке Ржавчина. Как таковые их нельзя использовать в качестве определителей (за исключением сырых определителей, которые мы обсудим в разделе [«Сырые определители]<!-- ignore -->»). определители — это имена функций, переменных, свойств, полей стопок, разделов, ящиков, постоянных переменных, макросов, постоянных переменных, способов, видов данных, сущностей или времён жизни.

### Используемые в настоящее время ключевые слова

Ниже приведён список используемых в настоящее время ключевых слов с их описанием.

-  `as` — использовать простое преобразование, уточнить определенное свойство, которое содержит предмет, или переименовать элемент в выражении `use`
- `async` — возврат `Future` вместо запрета текущего потока
- `await` — остановка выполнения до готовности итога `Future`
- `break` — немедленный выход из круговорота
- `const` — определение постоянной переменной или неизменяемого сырого указателя
- `continue` — досрочный переход к следующему повторению круговорота
- `crate` — ссылка на корень дополнения в пути к разделу
- `dyn` — изменяемая отсылка к сущности предмета
- `else` — иные  ветви для устройств управления условиями `if` и `if let`
- `enum` — определение перечислений
- `extern` — связывание внешней функции или переменной
- `false` — разновидность разумного вида данных со значением `ложь`
- `fn` — определение функции или вида указателя на функцию
- `for` — замкнутый перебор значений в круговороте.
- `if` — условный приказчик на основе ветвления из представленных условий
- `impl` — использование встроенных способов или возможностей сущности
- `in` — часть правил написания круговорота `for`
- `let` — объявление (связывание) переменной
- `loop` — безусловный круговорот
- `match` — сопоставление значения с образцами данных
- `mod` — определение раздела
- `move` — перекладывание владения на замыкание всеми захваченными переменными
- `mut` — обозначение изменяемости в  разных видах данных, в том числе в переменных, ссылках, сырых указателей и привязках к образцу данных
- `pub` — измениие открытого доступа для полей стопок, разделов `impl` и разделов
- `ref` — привязка по ссылке
- `return` — возвращает итог из функции
- `Self` — псевдоним для определяемого или исполняемого вида данных
- `self` — предмет текущего способа или раздела
- `static` — вездесущая переменная или время жизни, продолжающееся на протяжении всего выполнения программы
- `struct` — определение стопки
- `super` — родительское раздел имеющегося
- `trait` — определение сущности
- `true` — разновидность разумного вида данных со значением `истина`
- `type` — определение псевдонима вида данных или связанного вида данных
- `union` - определить [объединение]<!-- ignore -->; является ключевым словом только при использовании в объявлении объединения
- `unsafe` — обозначение небезопасной рукописи, функций, сущностей и их выполнений
- `use` — ввод имён в область видимости
- `where` — ограничение вида данных
- `while` — условный круговорот, основанный на итоге выражения

### Ключевые слова, забронированные для будущего использования

Следующие ключевые слова ещё не имеют никакой возможности, но забронированы Ржавчиной для возможного использования в будущем.

- `abstract`
- `become`
- `box`
- `do`
- `final`
- `macro`
- `override`
- `priv`
- `try`
- `typeof`
- `unsized`
- `virtual`
- `yield`

### Сырые определители

*Сырые определители* — это правила написания, позволяющие использовать ключевые слова там, где обычно они не могут быть. Для создания и использования сырого определителя к ключевому слову добавляется приставка `r#`.

Например, ключевое слово `match`. Если вы попытаетесь собрать следующую функцию, использующую в качестве имени `match`:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
fn match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}
```

вы получите ошибку:

```text
error: expected identifier, found keyword `match`
 --> src/main.rs:4:4
  |
4 | fn match(needle: &str, haystack: &str) -> bool {
  |    ^^^^^ expected identifier, found keyword
```

Ошибка говорит о том, что вы не можете использовать ключевое слово `match` в качестве определителя функции. Чтобы получить возможность использования слова `match` в качестве имени функции, нужно использовать правила написания «сырых определителей», например так:

<span class="filename">Файл: src/main.rs</span>

```rust
fn r#match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}
```

Эта рукопись собирается без ошибок. Обратите внимание, что приставка `r#` в определении имени функции указана так же, как она указана в месте её вызова в `main`.

Сырые определители позволяют вам использовать любое слово, которое вы выберете, в качестве определителя, даже если это слово окажется забронированным ключевым словом. Это даёт нам больше свободы в выборе имён определителей, а также позволяет нам встраиваться с программами, написанными на языке, где эти слова не являются ключевыми. Кроме того, необработанные определители позволяют вам использовать библиотеки, написанные в исполнениях Ржавчины, отличной от используемой в вашем ящике. Например, `try` не является ключевым словом в выпуске 2015 года, но является в выпуске 2018 года. Если вы зависите от библиотеки, написанной с использованием исполнения 2015 года и имеющей функцию `try`, вам потребуется использовать правила написания сырого определителя, в данном случае `r#try`, для вызова этой функции из рукописи исполнения 2018 года. См. [Приложение E]<!-- ignore --> для получения дополнительных сведений о изданиях Ржавчины.


[«Сырые определители]: #raw-identifiers
[объединение]: ../reference/items/unions.html
[Приложение E]: appendix-05-editions.html