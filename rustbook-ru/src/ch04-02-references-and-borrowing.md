## Ссылки и заимствование

Неполадка с рукописью упорядоченного ряда в приложении 4-5 заключается в том, что мы должны вернуть `String` из вызванной функции, чтобы использовать `String` после вызова `calculate_length`, потому что `String` была перемещена в `calculate_length`. Вместо этого мы можем предоставить ссылку на значение переменной `String`. *Ссылка* похожа на указатель в том смысле, что это адрес, по которому мы можем проследовать, чтобы получить доступ к данным, хранящимся по этому адресу; эти данные принадлежат какой-то другой переменной. В отличие от указателя, ссылка обязательно указывает на допустимое значение переменной определённого вида данных в течение всего срока существования этой ссылки.

Вот как вы могли бы определить и использовать функцию `calculate_length`, имеющую ссылку на предмет в качестве свойства, вместо того, чтобы брать на себя ответственность за значение переменной:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-07-reference/src/main.rs:all}}
```

Во-первых, обратите внимание, что вся рукопись упорядоченного ряда в объявлении переменной и возвращаемое значение функции исчезли. Во-вторых, обратите внимание, что мы передаём `&s1` в `calculate_length` и в его определении используем `&String`, а не `String`. Эти знаки представляют собой *ссылки*, и они позволяют вам ссылаться на некоторое значение переменной, не принимая владение над ним. Рисунок 4-5 изображает этот подход.

<img alt="&amp;String s pointing at String s1" src="img/trpl04-05.svg" class="">

<span class="caption">Рисунок 4-5: рисунок для <code>&amp;String s</code>, указывающей на <code>String s1</code></span>

> Примечание: противоположностью ссылки с использованием `&` является *разыменование*, выполняемое с помощью приказчика разыменования `*`. Мы увидим некоторые исходы использования приказчика разыменования в главе 8 и обсудим подробности разыменования в главе 15.

Давайте подробнее рассмотрим рычаг вызова функции:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-07-reference/src/main.rs:here}}
```

`&s1` позволяет нам создать ссылку, которая *ссылается* на значение переменной `s1`, но не владеет им. Поскольку она не владеет им, значением переменной, на которое она указывает, не будет удалено, когда ссылка перестанет использоваться.

Ярлык функции использует `&` для отображения того, что вид свойства `s` является ссылкой. Добавим объясняющие примечания:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-08-reference-with-annotations/src/main.rs:here}}
```

Область действия `s` такая же, как и область действия любого свойства функции, но значение переменной, на которое указывает ссылка, не удаляется, когда `s` перестаёт использоваться, потому что `s` не является её владельцем. Когда функции имеют ссылки в качестве свойств вместо действительных значений, нам не нужно возвращать значения, чтобы вернуть право владения, потому что мы никогда не владели ими.

Мы называем этап создания ссылки *заимствованием*. Как и в существующей жизни, если человек чем-то владеет, вы можете это у него позаимствовать. Когда вы закончите, вы должны вернуть это законному владельцу.

А что произойдёт, если попытаться изменить то, что было позаимствовано? Попробуйте рукопись приложения 4-6 К сведению: эта рукопись не сработает!

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-06/src/main.rs}}
```

<span class="caption">Приложение 4-6: попытка изменения заимствованной переменной</span>

Вот ошибка:

```console
{{#include ../listings/ch04-understanding-ownership/listing-04-06/output.txt}}
```

Как переменные неизменяемы по умолчанию, так и ссылки. Нам не разрешено изменять то, на что у нас есть ссылка.

### Изменяемые ссылки

Мы можем исправить рукопись из приложения 4-6, чтобы позволить себе изменять заимствованное значение переменной, с помощью нескольких небольших настроек, которые используют *изменяемую ссылку*:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-09-fixes-listing-04-06/src/main.rs}}
```

Сначала мы меняем `s` на `mut`. Затем мы создаём изменяемую ссылку с помощью `&mut s`, у которой вызываем `change` и обновляем ярлык функции, чтобы принять изменяемую ссылку с помощью `some_string: &mut String`. Это даёт понять, что `change` изменит значение переменной, которое заимствует.

Изменяемые ссылки имеют одно большое ограничение: если у вас есть изменяемая ссылка на значение переменной, у вас не может быть других ссылок на это же значение переменной. Рукопись, которая пытается создать две изменяемые ссылки на `s`, завершится ошибкой:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-10-multiple-mut-not-allowed/src/main.rs:here}}
```

Описание ошибки:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-10-multiple-mut-not-allowed/output.txt}}
```

Эта ошибка говорит о том, что рукопись недействительна, потому что мы не можем заимствовать `s` как изменяемую ссылки более одного раза в одно мгновение времени. Первое изменяемое заимствование находится в `r1` и должно длиться до тех пор, пока оно не будет использовано в `println!`, но между созданием этой изменяемой ссылки и её использованием мы попытались создать другую изменяемую ссылку в `r2`, которая заимствует те же данные, что и `r1`.

Ограничение, предотвращающее одновременное использование нескольких изменяемых ссылок на одни и те же данные, допускает изменение, но очень сложным управлением. Это то, с чем борются новые Rustaceans, потому что большинство языков позволяют изменять значение переменной в любое мгновение. Преимущество этого ограничения заключается в том, что Ржавчина может предотвратить гонку данных во время сборки. *Гонка данных* похожа на состояние гонки и происходит, когда возникают следующие три обстоятельства:

- Два или больше указателей используют одни и те же данные в одно и то же время,
- Самое наименьшее один указатель используется для записи данных,
- Отсутствуют рычаги для согласования доступа к данным.

Гонки данных вызывают неопределённое поведение, и их может быть сложно выявить и исправить, когда вы пытаетесь отследить их во время выполнения. Ржавчина предотвращает такую неполадку, отказываясь собирать рукопись с гонками данных!

Как всегда, мы можем использовать узорчатые скобки для создания новой области видимости, позволяющей использовать несколько изменяемых ссылок, но не *одновременно*:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-11-muts-in-separate-scopes/src/main.rs:here}}
```

Ржавчина применяет подобное правило для согласования изменяемых и неизменяемых ссылок. Эта рукопись приводит к ошибке:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-12-immutable-and-mutable-not-allowed/src/main.rs:here}}
```

Ошибка:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-12-immutable-and-mutable-not-allowed/output.txt}}
```

Вау! У нас *также* не может быть изменяемой ссылки, пока у нас есть неизменяемая ссылка на то же значение переменной.

Пользователи неизменяемой ссылки не ожидают, что значение переменной внезапно изменится из-под них! Однако разрешены множественные неизменяемые ссылки, потому что никто, кто просто считывает данные, не может повлиять на чтение данных кем-либо ещё.

Обратите внимание, что область действия ссылки начинается с того места, где она была введена, и продолжается до последнего использования этой ссылки. Например, эта рукопись будет собираться, потому что последнее использование неизменяемых ссылок `println!`, происходит до того, как вводится изменяемая ссылка:

```rust,edition2021
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-13-reference-scope-ends/src/main.rs:here}}
```

Области неизменяемых ссылок `r1` и `r2` заканчиваются после `println!` где они использовались в последний раз, то есть до создания изменяемой ссылки `r3`. Эти области не перекрываются, поэтому эта рукопись разрешена: сборщик может сказать, что ссылка больше не используется в точке перед концом области.

Несмотря на то, что ошибки заимствования могут иногда вызывать разочарование, помните, что сборщик Ржавчины заранее указывает на вероятную ошибку (во время сборки, а не во время выполнения) и точно показывает, в чем неполадка. Тогда вам не придётся выяснять, почему ваши данные оказались не такими, как вы ожидали.

### Висячие ссылки

В языках с указателями весьма легко ошибочно создать недействительную (висячую) *(dangling)* ссылку. Ссылку указывающую на участок памяти, который мог быть передан кому-то другому, путём освобождения некоторой памяти при сохранении указателя на эту память. В Ржавчине сборщик заверяет, что ссылки никогда не станут недействительными: если у вас есть ссылка на какие-то данные, сборщик обеспечит что эти данные не выйдут из области видимости прежде, чем из области видимости исчезнет ссылка.

Давайте попробуем создать висячую ссылку, чтобы увидеть, как Ржавчина предотвращает их появление с помощью ошибки во время сборки:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-14-dangling-reference/src/main.rs}}
```

Здесь ошибка:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-14-dangling-reference/output.txt}}
```

Это сообщение об ошибке относится к особенностям языка, которуе мы ещё не рассмотрели: время жизни. Мы подробно обсудим времена жизни в главе 10. Но если вы не обращаете внимания на особенности, касающиеся времени жизни, сообщение будет содержать ключ к тому, почему эта рукопись является неверной:

```text
this function's return type contains a borrowed value, but there is no value
for it to be borrowed from
```

Давайте подробнее рассмотрим, что именно происходит на каждом этапе нашей рукописи `dangle`:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-15-dangling-reference-annotated/src/main.rs:here}}
```

Поскольку `s` создаётся внутри `dangle`, когда рукопись `dangle` будет завершена, `s` будет освобождена. Но мы попытались вернуть ссылку на неё. Это означает, что эта ссылка будет указывать на недопустимую `String`. Это нехорошо! Ржавчина не позволит нам сделать это.

Решением будет вернуть непосредственно `String`:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-16-no-dangle/src/main.rs:here}}
```

Это работает без неполадок. Владение перемещено, и ничего не освобождено.

### Правила работы с ссылками

Давайте повторим  все, что мы обсудили про ссылки:

- В любое мгновение времени у вас может быть *одна* (но не обе) изменяемая ссылка или любое количество неизменяемых ссылок.
- Все ссылки должны быть действительными.

В следующей главе мы рассмотрим другой подвид ссылок — срезы.


