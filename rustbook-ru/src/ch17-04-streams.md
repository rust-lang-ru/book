##Потоки: Будущее в последовательности

<!-- Old headings. Do not remove or links may break. -->

<a id="streams"></a>

До сих пор в этой главе мы в основном придерживались отдельных фьючерсов. Единственным большим
исключением был несогласованный канал, который мы использовали. Вспомните, как мы использовали приемник для нашего
несогласованного канала ранее в этой главе в разделе [«Передача
сообщений»][17-02-messages]<!-- ignore -->. Несогласованный способ `recv`
создает последовательность элементов с течением времени. Это пример гораздо более
общего шаблона, известного как _stream_.

Мы видели последовательность элементов еще в главе 13, когда рассматривали сущность `Iterator` в разделе [Триггер повторителя и способ `next`][iterator-trait]<!-- ignore
-->, но между повторителями и приемником несогласованного
канала есть два различия. Первое различие — это время: повторители согласованны, а приемник канала несогласованен. Второе — это API. При работе
напрямую с `Iterator` мы вызываем его согласованный способ `next`. В частности, с потоком `trpl::Receiver` мы вызываем несогласованный способ `recv`
вместо этого. В остальном эти API кажутся очень похожими, и это сходство
не является совпадением. Поток похож на несогласованную вид итерации. В то время как
`trpl::Receiver` специально ожидает получения сообщений,
универсальный потоковый API гораздо шире: он предоставляет следующий элемент
так, как это делает `Iterator`, но несогласованно.

Сходство между повторителями и потоками в Ржавчине означает, что мы можем в действительности
создать поток из любого повторителя. Как и в случае с итератором, мы можем работать с потоком, вызывая его способ `next` и затем ожидая вывода, как в приложении
17-30.

<Listing number="17-30" caption="Создание потока из повторителя и вывод его значений" file-name="src/main.rs">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch17-async-await/listing-17-30/src/main.rs:stream}}
```

</Listing>

Мы начинаем с массива чисел, который преобразуем в повторитель, а затем вызываем
`map`, чтобы удвоить все значения. Затем мы преобразуем повторитель в поток,
используя способ (функцию) `trpl::stream_from_iter`. Затем мы циклически перебираем элементы в потоке
по мере их поступления с помощью круговорота `while let`.

К сожалению, когда мы пытаемся запустить код, он не собирается, а вместо этого сообщает, что нет доступного способа `next`:

<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-30
cargo build
copy only the error output
-->

```console
ошибка[E0599]: no method named `next` found for struct `Iter` in the current scope
  --> src/main.rs:10:40
   |
10 |         while let Some(значение) = stream.next().await {
   |                                        ^^^^
   |
   = примечание: the full type name has been written to 'file:///projects/async-await/target/debug/deps/async_await-575db3dd3197d257.long-type-14490787947592691573.txt'
   = примечание: consider using `--verbose` to print the full type name to the console
   = помощь: items from traits can only be used if the trait is in scope
помощь: the following traits which provide `next` are implemented but not in scope; perhaps you want to import one of them
   |
1  + use crate::trpl::StreamExt;
   |
1  + use futures_util::stream::stream::StreamExt;
   |
1  + use std::iter::Iterator;
   |
1  + use std::str::pattern::Searcher;
   |
помощь: there is a method `try_next` with a similar name
   |
10 |         while let Some(значение) = stream.try_next().await {
   |                                        ~~~~~~~~
```

Как поясняет этот вывод, причина ошибки сборщика в том, что нам нужен
правильный трейт в области действия, чтобы иметь возможность использовать способ `next`. Учитывая наше обсуждение
до сих пор, вы могли бы разумно ожидать, что этот трейт будет `Stream`, но на самом деле это
`StreamExt`. Сокращение от _extension_, `Ext` является распространенным шаблоном в
сообществе Ржавчина для расширения одного трейта другим.

Мы объясним трейты `Stream` и `StreamExt` немного подробнее в
конце главы, но сейчас все, что вам нужно знать, это то, что трейт `Stream`
определяет низкоуровневый интерфейс, который эффективно объединяет трейты `Iterator` и
`Future`. `StreamExt` предоставляет набор API более высокого уровня поверх
`Stream`, включая способ `next`, а также другие служебные способы,
подобные тем, которые предоставляет трейт `Iterator`. `Stream` и `StreamExt` пока не являются частью стандартной библиотеки Ржавчина, но большинство дополнений экосистемы используют одно и то же
определение.

Исправление ошибки сборщика заключается в добавлении оператора `use` для `trpl::StreamExt`,
как в приложении 17-31.

<Listing number="17-31" caption="Успешное использование повторителя в качестве основы для потока" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-31/src/main.rs:all}}
```

</Listing>

Собрав все эти части вместе, эта рукопись работает так, как мы хотим! Более того, теперь, когда у нас есть `StreamExt` в области видимости, мы можем использовать все его служебные
способы, как и с повторителями. Например, в приложении 17-32 мы используем способ `filter`, чтобы отфильтровать все, кроме кратных трем и пяти.

<Listing number="17-32" caption="Filtering a stream with the `StreamExt::filter` method" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-32/src/main.rs:all}}
```

</Listing>

Конечно, это не очень интересно, так как мы могли бы сделать то же самое с обычными повторителями и вообще без несогласованности. Давайте посмотрим, 
что мы можем сделать, что _уникально_ для потоков.

### Составление потоков

Многие концепции естественным образом представлены в виде потоков: элементы, становящиеся доступными в
очереди, фрагменты данных, извлекаемые постепенно из файловой системы, когда
полный набор данных слишком велик для памяти компьютера, или данные, поступающие по
сети с течением времени. Поскольку потоки являются будущими, мы можем использовать их с любым другим
видом будущих и комбинировать их интересными способами. Например, мы можем
объединять события, чтобы избежать запуска слишком большого количества сетевых вызовов, устанавливать тайм-ауты для последовательностей
длительных действий или регулировать события пользовательского интерфейса, чтобы избежать выполнения
ненужной работы.

Давайте начнем с создания небольшого потока сообщений в качестве замены для потока
данных, которые мы можем видеть из WebSocket или другого протокола связи в реальном времени, как показано в приложении 17-33.

<Listing number="17-33" caption="Использование приемника `rx` в качестве `ReceiverStream`" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-33/src/main.rs:all}}
```

</Listing>

Сначала мы создаем способ (функцию) `get_messages`, которая возвращает `impl Stream<Item
= String>`. Для ее реализации мы создаем несогласованный канал, цикл по первым 10 буквам английского алфавита и отправляем их по каналу.

Мы также используем новый вид: `ReceiverStream`, который преобразует получателя `rx` из
`trpl::channel` в `Stream` с помощью способа `next`. Возвращаясь в `main`, мы используем цикл `while let` для вывода всех сообщений из потока.

Когда мы запускаем эта рукопись, мы получаем именно те итоги, которые и ожидали:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads запщущен differently rather than
changes in the compiler -->

```text
Сообщение: 'a'
Сообщение: 'b'
Сообщение: 'c'
Сообщение: 'd'
Сообщение: 'e'
Сообщение: 'f'
Сообщение: 'g'
Сообщение: 'h'
Сообщение: 'i'
Сообщение: 'j'
```

Опять же, мы могли бы сделать это с помощью обычного API `Receiver` или даже обычного API `Iterator`, поэтому давайте добавим способ (функцию), которая требует потоков: добавим
тайм-аут, который применяется к каждому элементу в потоке, и задержку для элементов, которые мы
отправляем, как показано в приложении 17-34.

<Listing number="17-34" caption="Использование способа `StreamExt::timeout` для установки ограничения по времени для элементов в потоке" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-34/src/main.rs:timeout}}
```

</Listing>

Мы начинаем с добавления тайм-аута к потоку с помощью способа `timeout`, который
приходит из видажа `StreamExt`. Затем мы обновляем тело круговорота `while let`,
потому что поток теперь возвращает `Result`. Вариант `Ok` указывает,
что сообщение пришло вовремя; вариант `Err` указывает, что тайм-аут истек
до поступления любого сообщения. Мы `сопоставляем` этот итог и либо печатаем сообщение,
когда мы его успешно получим, либо печатаем уведомление о тайм-ауте.
Наконец, обратите внимание, что мы закрепляем сообщения после применения к ним тайм-аута,
потому что помощник тайм-аута создает поток, который необходимо закрепить для
опроса.

Однако, поскольку между сообщениями нет задержек, этот тайм-аут не
меняет поведение приложения. Давайте добавим переменную задержку к сообщениям,
которые мы отправляем, как показано в приложении 17-35.

<Listing number="17-35" caption="Отправка сообщений через `tx` с несогласованной задержкой без превращения `get_messages` в несогласованную способ (функцию)" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-35/src/main.rs:messages}}
```

</Listing>

В `get_messages` мы используем способ повторителя `enumerate` с массивом `messages`
чтобы мы могли получить индекс каждого элемента, который мы отправляем вместе с самим элементом. Затем мы применяем задержку в 100 миллисекунд к элементам с четным индексом и задержку в 300 миллисекунд к элементам с нечетным индексом, чтобы смоделировать различные задержки, которые мы
можем увидеть в потоке сообщений в реальном мире. Поскольку наш тайм-аут составляет 200 миллисекунд, это должно повлиять на половину сообщений.

Чтобы заснуть между сообщениями в способе (функции) `get_messages` без блокировки, нам
нужно использовать несогласованность. Однако мы не можем сделать сам `get_messages` несогласованной функцией, потому что тогда мы вернем `Future<Output = Stream<Предмет = String>>`
вместо `Stream<Предмет = String>>`. Вызывающему пришлось бы ожидать
`get_messages` сам, чтобы получить доступ к потоку. Но помните: все в
данном будущем происходит линейно; одновременность происходит _между_ будущими событиями. Ожидание
`get_messages` потребовало бы отправки всех сообщений, включая задержку
сна между каждым сообщением, перед возвратом потока получателя. В итоге,
тайм-аут был бы бесполезен. Не было бы никаких задержек в самом потоке;
они все произошли бы еще до того, как поток стал бы доступен.

Вместо этого мы оставляем `get_messages` как обычную способ (функцию), которая возвращает поток,
и порождаем задачу для обработки несогласованных вызовов `sleep`.

> Примечание: Вызов `spawn_task` таким образом работает, потому что мы уже настроили нашу
> среду выполнения; если бы мы этого не сделали, это вызвало бы панику. Другие реализации выбирают
> другие соглашения: они могут порождать новую среду выполнения и избегать паники, но
> в конечном итоге имеют некоторые дополнительные накладные расходы, или они могут просто не предоставлять
> отдельный способ порождать задачи без ссылки на среду выполнения. Убедитесь,
> что вы знаете, какое соглашение выбрала ваша среда выполнения, и пишите свой код соответствующим образом!

Теперь наш код имеет гораздо более интересный итог. Между каждой парой сообщений ошибка `Problem: Elapsed(())`.

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads запщущен differently rather than
changes in the compiler -->

```text
Сообщение: 'a'
Problem: Elapsed(())
Сообщение: 'b'
Сообщение: 'c'
Problem: Elapsed(())
Сообщение: 'd'
Сообщение: 'e'
Problem: Elapsed(())
Сообщение: 'f'
Сообщение: 'g'
Problem: Elapsed(())
Сообщение: 'h'
Сообщение: 'i'
Problem: Elapsed(())
Сообщение: 'j'
```

Тайм-аут не мешает сообщениям прибывать в конце. Мы все равно получаем
все исходные сообщения, потому что наш канал _неограничен_: он может хранить столько сообщений, сколько мы можем поместить в памяти. Если сообщение не прибудет до
тайм-аута, наш обработчик потока учтет это, но когда он снова опросит поток, сообщение может уже прибыть.

При необходимости вы можете получить другое поведение, используя другие виды каналов или
другие виды потоков в более общем смысле. Давайте рассмотрим один из них в действительности,
объединив поток временных интервалов с этим потоком сообщений.

### Объединение потоков

Сначала давайте создадим еще один поток, который будет выдавать элемент каждую миллисекунду, если мы позволим ему работать напрямую. Для простоты мы можем использовать способ (функцию) `sleep` для отправки
сообщения с задержкой и объединить ее с тем же подходом, который мы использовали в `get_messages` для создания потока из канала. Разница в том, что на этот раз мы собираемся отправить обратно количество прошедших интервалов, поэтому
возвращаемый вид будет `impl Stream<Предмет = u32>`, и мы можем вызвать способ (функцию)
`get_intervals` (см. приложение 17-36).

<Listing number="17-36" caption="Создание потока со счетчиком, который будет отправляться раз в миллисекунду" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-36/src/main.rs:intervals}}
```

</Listing>

Мы начинаем с определения `count` в задаче. (Мы могли бы определить его и вне
задачи, но понятнее ограничить область действия любой заданной переменной.) Затем мы
создаем бесконечный цикл. Каждая итерация круговорота несогласованно спит
одну миллисекунду, увеличивает счетчик, а затем отправляет его по каналу.
Поскольку все это обернуто в задачу, созданную `spawn_task`, все это,
включая бесконечный цикл, будет очищено вместе с выполнением.

Такой вид бесконечного круговорота, который заканчивается только тогда, когда вся среда выполнения будет
завершена, довольно распространен в несогласованном Ржавчина: многим приложением нужно продолжать работать
неопределенно долго. В несогласованном режиме это не блокирует ничего другого, пока есть
хотя бы одна точка ожидания в каждой итерации круговорота.

Теперь, вернувшись в несогласованный раздел нашей основном способе (функции), мы можем попытаться объединить потоки `messages` и `intervals`, как показано в приложении 17-37.

<Listing number="17-37" caption="Попытка объединить потоки `messages` и `intervals`" file-name="src/main.rs">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch17-async-await/listing-17-37/src/main.rs:main}}
```

</Listing>

Мы начинаем с вызова `get_intervals`. Затем мы объединяем потоки `messages` и
`intervals` с помощью способа `merge`, который объединяет несколько потоков
в один поток, который производит элементы из любого исходного потока, как только
они становятся доступны, без навязывания какого-либо определенного порядка. Наконец, мы
циклируем по этому объединенному потоку вместо `messages`.

На этом этапе ни `messages`, ни `intervals` не нужно закреплять или изменять,
потому что оба будут объединены в один поток `merged`. Однако этот
вызов `merge` не собирается! (Как и вызов `next` в цикле `while
let`, но мы вернемся к этому.) Это потому, что два потока имеют
разные виды данных. Поток `messages` имеет вид `Timeout<impl Stream<Предмет =
String>>`, где `Timeout` — это вид, который использует `Stream` для вызова `timeout`. Поток `intervals` имеет вид `impl Stream<Предмет = u32>`. Чтобы объединить эти два потока, нам нужно преобразовать один из них в соответствии с другим. Мы
переработаем поток intervals, поскольку messages уже находится в базовом формате, который нам нужен, и должен обрабатывать ошибки тайм-аута (см. приложение 17-38).
<!-- We cannot directly test this one, because it never stops. -->

<Listing number="17-38" caption="Приведение вида потока `intervals` в соответствие с видом потока `messages`" file-name="src/main.rs">

```rust,ignore
{{#rustdoc_include ../listings/ch17-async-await/listing-17-38/src/main.rs:main}}
```

</Listing>

Во-первых, мы можем использовать вспомогательный способ `map` для преобразования `intervals` в
строку. Во-вторых, нам нужно сопоставить `Timeout` из `messages`. Поскольку нам на самом деле не нужен тайм-аут для `intervals`, мы можем просто создать тайм-аут,
который больше, чем другие используемые нами длительности. Здесь мы создаем
10-секундный тайм-аут с `Duration::from_secs(10)`. Наконец, нам нужно сделать `stream` изменяемыми, чтобы вызовы `next` круговорота `while let` могли
перебирать поток, и закрепить его, чтобы это было безопасно. Это приводит нас _почти_ к тому, где нам нужно быть. Все виды данных проверяются. Однако, если вы запустите это,
будут две проблемы. Во-первых, он никогда не остановится! Вам нужно будет остановить его с помощью
<span class="keystroke">ctrl-c</span>. Во-вторых, сообщения из английского алфавита будут погребены среди всех сообщений счетчика интервалов:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the tasks запщущен differently rather than
changes in the compiler -->

```text
--snip--
Interval: 38
Interval: 39
Interval: 40
Сообщение: 'a'
Interval: 41
Interval: 42
Interval: 43
--snip--
```

В приложении 17-39 показан один из способов решения последних двух проблем.

<Listing number="17-39" caption="Использование `throttle` и `take` для управления объединенными потоками" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-39/src/main.rs:throttle}}
```

</Listing>

Во-первых, мы используем способ `throttle` в потоке `intervals`, чтобы он не
перегружал поток `messages`. _Throttling_ — это способ ограничить частоту, с которой будет вызываться способ (функция), или, в данном случае, частоту опроса потока. Один раз в 100 миллисекунд должно хватить, потому что примерно так часто
приходят наши сообщения.

Чтобы ограничить количество элементов, которые мы будем принимать из потока, мы применяем способ `take` к потоку `merged`, потому что мы хотим ограничить конечный вывод, а не только один поток.

Теперь, когда мы запускаем программу, она останавливается после извлечения 20 элементов из потока,
и интервалы не перегружают сообщения. Мы также не получаем `Interval:
100` или `Interval: 200` или что-то в этом роде, а вместо этого получаем `Interval: 1`, `Interval: 2` и так далее — даже несмотря на то, что у нас есть исходный поток, который _может_ создавать событие каждую
миллисекунду. Это потому, что вызов `throttle` создает новый поток, который оборачивает
исходный поток так, что исходный поток опрашивается только со скоростью throttle, а не со своей собственной «родной» скоростью. У нас нет кучи необработанных сообщений интервала, которые мы решили игнорировать. Вместо этого мы никогда не создаем эти сообщения интервала в первую очередь! Это присущая «лень» будущих событий Ржавчина
снова в действии, позволяя нам выбирать характеристики производительности.

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads запщущен differently rather than
changes in the compiler -->

```text
Interval: 1
Сообщение: 'a'
Interval: 2
Interval: 3
Problem: Elapsed(())
Interval: 4
Сообщение: 'b'
Interval: 5
Сообщение: 'c'
Interval: 6
Interval: 7
Problem: Elapsed(())
Interval: 8
Сообщение: 'd'
Interval: 9
Сообщение: 'e'
Interval: 10
Interval: 11
Problem: Elapsed(())
Interval: 12
```

Осталось еще одно, с чем нам нужно справиться: ошибки! С обоими этими потоками на основе каналов вызовы `send` могут завершиться неудачей, когда другая сторона
канала закрывается — и это всего лишь вопрос того, как среда выполнения выполняет фьючерсы,
составляющие поток. До сих пор мы игнорировали эту возможность, вызывая `unwrap`, но в хорошо работающем приложении мы должны явно обрабатывать ошибку, как минимум, завершая цикл, чтобы не пытаться отправлять больше сообщений. В приложении
17-40 показана простая стратегия обработки ошибок: вывести проблему, а затем `break` из
круговоротов.

<Listing number="17-40" caption="Обработка ошибок и завершение круговоротов">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-40/src/main.rs:errors}}
```

</Listing>

Как обычно, правильный способ обработки ошибки отправки сообщения будет разным; просто убедитесь, что у вас есть стратегия.

Теперь, когда мы увидели кучу несогласованности в действительности, давайте сделаем шаг назад и углубимся в некоторые детали того, как `Future`, `Stream` и другие ключевые сущности,
которые Ржавчина использует для работы несогласованности.

[17-02-messages]: ch17-02-concurrency-with-async.html#message-passing
[iterator-trait]: ch13-02-iterators.html#the-iterator-trait-and-the-next-method
