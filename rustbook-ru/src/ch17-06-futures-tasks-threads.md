## Собираем все вместе: фьючерсы, задачи и потоки

Как мы видели в [Главе 16][ch16]<!-- игнорировать -->, потоки предоставляют один подход к
одновременности. Мы видели другой подход в этой главе: использование несогласованности с
фьючерсами и потоками. Если вам интересно, когда выбрать способ, а когда другой,
ответ: это зависит! И во многих случаях выбор не в потоках _или_
несогласованности, а скорее в потоках _и_ несогласованности.

Многие операционные системы уже десятилетиями предоставляют модели одновременности на основе потоков, и многие языки программирования поддерживают их в итоге. Однако эти модели не лишены своих компромиссов. Во многих операционных системах они
используют довольно много памяти для каждого потока, и они несут некоторые накладные расходы на
запуск и завершение работы. Потоки также являются вариантом только тогда, когда ваша
операционная система и оборудование поддерживают их. В отличие от обычных настольных и мобильных компьютеров, некоторые встроенные системы вообще не имеют ОС, поэтому у них также нет потоков.

Несогласованная средство предоставляет другой — и в конечном итоге дополнительный — набор компромиссов. В несогласованной модели одновременные действия не требуют собственных
потоков. Вместо этого они могут выполняться в задачах, как когда мы использовали `trpl::spawn_task` для
запуска работы из согласованной функции в разделе потоков. Задача
похожа на поток, но вместо того, чтобы управляться операционной системой, она
управляется кодом уровня библиотеки: средой выполнения.

В предыдущем разделе мы увидели, что можем создать поток, используя несогласованный
канал и порождая несогласованную задачу, которую можно вызвать из согласованной рукописи. Мы можем
сделать то же самое с потоком. В приложении 17-40 мы использовали `trpl::spawn_task` и `trpl::sleep`. В приложении 17-41 мы заменяем их на API `thread::spawn` и `thread::sleep` из стандартной библиотеки в функции `get_intervals`.

<Listing number="17-41" caption="Использование API `std::thread` вместо несогласованных API `trpl` для функции `get_intervals`" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-41/src/main.rs:threads}}
```

</Listing>

Использование API `std::thread` вместо несогласованных API `trpl` для функции `get_intervals` Если вы запустите эта рукопись, вывод будет идентичен приложению 17-40. И
обратите внимание, как мало изменений здесь с точки зрения вызывающей рукописи. Более того, даже несмотря на то, что одна из наших функций породила несогласованную задачу во время выполнения, а
другая породила поток ОС, полученные потоки не были затронуты
различиями.

Несмотря на их сходство, эти два подхода ведут себя совершенно по-разному,
хотя нам может быть трудно измерить это в этом очень простом примере.

Мы могли бы породить миллионы несогласованных задач на любом современном персональном компьютере. Если бы мы попытались сделать это с потоками, у нас бы буквально закончилась память!

Однако есть причина, по которой эти API так похожи. Потоки действуют как граница
для наборов согласованных действий; одновременность возможен _между_ потоками. Задачи выступают в качестве границы для наборов _несогласованных_ действий; одновременность возможен как _между_ задачами, так и _внутри_ них, поскольку задача может переключаться между
будущими в своем теле. Наконец, будущие являются наиболее гранулярной единицей одновременности Ржавчина, и каждый будущий может представлять дерево других будущих.
Среда выполнения — в частности, ее исполнитель — управляет задачами, а задачи управляют будущими. В этом отношении задачи похожи на легкие, управляемые средой выполнения потоки с
дополнительными возможностями, которые возникают из-за управления средой выполнения, а не
операционной системой.

Это не означает, что несогласованные задачи всегда лучше потоков (или наоборот). Одновременность с потоками в некотором роде является более простым средствами программирования,
чем одновременность с `async`. Это может быть как сильной, так и слабой стороной. Потоки
в некотором роде «запустил и забыл»; у них нет собственного подобия future, поэтому они
просто выполняются до завершения, не прерываясь ни кем, кроме самой операционной
системы. То есть, у них нет встроенной поддержки _внутритаскового
одновременности_, как это делают futures. Потоки в Ржавчине также не имеют механизмов
отмены — предмет, который мы явно не рассматривали в этой главе, но
подразумевался тем фактом, что всякий раз, когда мы завершали future, его состояние очищалось
правильно.

Эти ограничения также затрудняют компоновку потоков, чем futures. Например, гораздо
труднее использовать потоки для создания вспомогательных способов, таких как
способы `timeout` и `throttle`, которые мы создали ранее в этой главе. То обстоятельство, что
futures являются более богатыми видами данных, означает, что их можно компоновать вместе более
естественно, как мы видели.

Задачи, таким образом, дают нам _дополнительный_ контроль над futures, позволяя нам выбирать,
где и как их группировать. И оказывается, что потоки и задачи часто работают
очень хорошо вместе, потому что задачи можно (по крайней мере в некоторых средах выполнения) перемещать
между потоками. Фактически, под капотом среда выполнения, которую мы
использовали, включая функции `spawn_blocking` и `spawn_task`,
по умолчанию является многопоточной! Многие среды выполнения используют подход, называемый _work stealing_,
чтобы прозрачно перемещать задачи между потоками, в зависимости от того, как потоки
используются в данный момент, чтобы улучшить общую производительность системы. Этот
подход на самом деле требует потоков _и_ задач, а значит, и будущих событий.

Когда вы думаете о том, какой способ использовать и когда, учтите следующие практические правила:

- Если работа _очень одновременна_, например, обработка большого объема данных, где
каждая часть может быть обработана отдельно, потоки являются лучшим выбором.
- Если работа _очень одновременна_, например, обработка сообщений из большого количества
различных источников, которые могут поступать с разными интервалами или с разной скоростью,
несогласованность является лучшим выбором.

А если вам нужны и одновременность, и конкурентность, вам не нужно выбирать
между потоками и несогласованностью. Вы можете свободно использовать их вместе, позволяя каждому
играть ту роль, в которой он лучше всего. Например, приложение 17-42 показывает довольно распространенный
пример такого рода смеси в реальном коде Ржавчина.

<Listing number="17-42" caption="Отправка сообщений с блокирующим кодом в потоке и ожидание сообщений в несогласованном блоке" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-42/src/main.rs:all}}
```

</Listing>

Мы начинаем с создания несогласованного канала, затем создаем поток, который берет на себя
владение стороной отправителя канала. В потоке мы отправляем
числа от 1 до 10, засыпая на секунду между каждым. Наконец, мы запускаем
будущее, созданное с несогласованным блоком, переданным в `trpl::run`, как мы делали
на протяжении всей главы. В этом будущем мы ждем эти сообщения, как и в
других примерах передачи сообщений, которые мы видели.

Возвращаясь к сценарию, с которого мы начали главу, представьте себе запуск набора
задач кодирования видео с использованием выделенного потока (потому что кодирование видео
привязано к вычислениям), но уведомляем пользовательский интерфейс о том, что эти действия выполняются с помощью несогласованного
канала. Существует бесчисленное множество примеров таких комбинаций в
реальных случаях использования.

## Итог

Это не последний раз, когда вы увидите одновременность в этой книге. Проект в
[Главе 21][ch21] применит эти концепции в более реалистичной ситуации,
чем более простые примеры, обсуждаемые здесь, и более непосредственно сравнит решение проблем с потоками и задачами.

Независимо от того, какой из этих подходов вы выберете, Ржавчина дает вам средства, необходимые для написания безопасного, быстрого, одновременного рукописи — будь то для высокопроизводительного веб-сервера или встроенной операционной системы.

Далее мы поговорим об идиоматических способах моделирования проблем и структурирования решений
по мере того, как ваши приложения Ржавчина становятся больше. Кроме того, мы обсудим, как идиомы Ржавчина
соотносятся с теми, с которыми вы, возможно, знакомы по объектно-ориентированному программированию.

[ch16]: http://localhost:3000/ch16-00-concurrency.html
[combining-futures]: ch17-03-more-futures.html#building-our-own-async-abstractions
[streams]: ch17-04-streams.html#composing-streams
[ch21]: ch21-00-final-project-a-web-server.html
