## Расширенная многопоточность с помощью сущностей `Sync` и `Send`

Важно, что сам язык Ржавчина имеет *очень* мало возможностей для многопоточности. Почти все функции многопоточности о которых мы говорили в этой главе, были частью встроенной библиотеки, а не языка. Ваши исходы работы с многопоточностью не ограничиваются языком или встроенной библиотекой; Вы можете написать свой собственный многопоточный возможности или использовать возможности написанные другими.

Тем не менее, в язык встроены два подхода многопоточности: `std::marker` сущности `Sync` и `Send`.

### Разрешение передачи во владение между потоками с помощью `Send`

Маркерная сущность `Send` указывает, что владение видом данных выполняющим `Send`, может передаваться между потоками. Почти каждый вид данных Ржавчины является видом `Send`, но есть некоторые исключения, вроде `Rc<T>`: он не может быть `Send`, потому что если вы удвоили значение `Rc<T>` и попытались передать владение двойником в другой поток, оба потока могут обновить счётчик ссылок одновременно. По этой причине `Rc<T>` выполнен для использования в однопоточных случаях, когда вы не хотите платить за снижение производительности.

Следовательно, перечень видов данных Ржавчине и ограничений сущности заверяют, что вы никогда не сможете случайно небезопасно отправлять значение `Rc<T>` между потоками. Когда мы попытались сделать это в приложении 16-14, мы получили ошибку, `the trait Send is not implemented for Rc<Mutex<i32>>`. Когда мы переключились на `Arc<T>`, который является видом данных `Send`, то рукопись собралась.

Любой вид данных полностью состоящий из видов данных `Send` самостоятельно помечается как `Send`. Почти все простые виды данных являются `Send`, кроме сырых указателей, которые мы обсудим в главе 19.

### Разрешение доступа из нескольких потоков с `Sync`

Маркерный сущность `Sync` указывает, что на вид данных использующий `Sync` можно безопасно ссылаться из нескольких потоков. Другими словами, любой вид данных `T` является видом данных `Sync`, если `&T` (ссылка на `T` ) является видом данных `Send`, что означает что ссылку можно безопасно отправить в другой поток. Подобно `Send`, простые виды данных являются видом `Sync`, а виды данных полностью объединенные из видов данных `Sync`, также являются `Sync` видом данных.

Умный указатель `Rc<T>` не является `Sync` видом данных по тем же причинам, по которым он не является `Send`. Вид данных `RefCell<T>` (о котором мы говорили в главе 15) и семейство связанных видов `Cell<T>` не являются `Sync`. Выполнение проверки заимствования, которую делает вид данных `RefCell<T>` во время выполнения программы не является поточно-безопасной. Умный указатель `Mutex<T>` является видом `Sync` и может использоваться для совместного доступа из нескольких потоков, как вы уже видели в разделе <a data-md-type="raw_html" href="ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads">«Совместное использование `Mutex<T>` между несколькими потоками»</a> <!-- ignore -->.

### Использование `Send` и `Sync` вручную небезопасно

Поскольку виды данных созданные из сущностей `Send` и `Sync` самостоятельно также являются видами данных `Send` и `Sync`, мы не должны использовать эти сущности вручную. Являясь маркерными сущностями у них нет никаких способов для выполнения. Они просто полезны для выполнения неизменных величин, связанных с многопоточностью.

Ручное выполнение этих сущностей включает в себя выполнение небезопасной рукописи Ржавчины. Мы поговорим об использовании небезопасной рукописи Ржавчины в главе 19; на данное мгновение важные сведения заключается в том, что для создания новых многопоточных видов данных, не состоящих из частей `Send` и `Sync` необходимо тщательно продумать заверения безопасности. В [Rustonomicon] есть больше сведений об этих заверениях и о том как их соблюдать.

## Итоги

Это не последний случай, когда вы увидите многопоточность в этой книге: дело в главе 20 будет использовать подходы этой Главы для более существующегостичного случая, чем небольшие примеры обсуждаемые здесь.

Как упоминалось ранее, поскольку в языке Ржавчина очень мало того, с помощью чего можно управлять многопоточностью, многие решения  выполнены в виде ящиков. Они развиваются быстрее, чем обычная библиотека, поэтому обязательно поищите в Мировой сети текущие современные ящики.

Обычная библиотека Ржавчины предоставляет потоки для передачи сообщений и виды данных умных указателей, такие как `Mutex<T>` и `Arc<T>`, которые можно безопасно использовать в многопоточных средах. Перечень видов данных и оценщик заимствований заверяют, что рукопись использующий эти решения не будет содержать гонки данных или недействительные ссылки. Получив собирающийся рукопись, вы можете быть уверены, что она будет успешно работать в нескольких потоках без ошибок, которые трудно обнаружить в других языках. Многопоточное программирование больше не является подходом, которую стоит опасаться: иди вперёд и сделай свои программы многопоточными безбоязненно!

Далее мы поговорим об идиоматичных способах расчетов неполадок и внутреннего выстраивания
 решений по мере усложнения ваших программ на Ржавчине. Кроме того, мы обсудим как устойчивого выражения Ржавчины связаны с теми, с которыми вы, возможно, знакомы по предметно-направленному программированию.


[Rustonomicon]: ../nomicon/index.html