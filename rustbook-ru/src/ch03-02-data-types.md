## Виды Данных

Каждое значение в Ржавчине относится к определённому *виду данных*, который указывает на вид данных данных, что позволяет Ржавчине знать, как работать с этими данными. Мы рассмотрим два подмножества видов данных: одиночные и составные.

Не забывайте, что Ржавчина является *постоянным строго определенным* (statically typed) языком. Это означает, что он должен знать виды данных всех переменных во время сборки. Обычно сборщик может предположить, какой вид данных используется (вывести его), основываясь на значении и на том, как мы с ним работаем. В случаях, когда может быть выведено несколько видов данных, необходимо добавлять изложение вида данных вручную. Например, когда мы преобразовали `String` в Число с помощью вызова `parse` в разделе [«Сравнение предположения с загаданным номером»](ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number) Главы 2, мы должны добавить такое изложение:<!-- ignore -->

```rust
let догадка: u32 = "42".parse().expect("Не число!");
```

Если мы не добавим изложение вида данных `: u32`, показанную в предыдущем рукописи, Ржавчина отобразит следующую ошибку, которая означает, что сборщику нужно от нас больше сведений, чтобы узнать, какой вид данных мы хотим использовать:

```console
{{#include ../listings/ch03-common-programming-concepts/output-only-01-no-type-annotations/output.txt}}
```

В будущем вы увидите различные изложении для разных видов данных.

### Одиночные виды данных

*Одиночный* вид данных представляет собой единичное значение. В Ржавчине есть четыре основных одиночных вида данных: целочисленный, числа с плавающей точкой, разумный и знаки. Вы наверняка знакомы с этими видами данных по другим языкам программирования. Давайте разберёмся, как они работают в Ржавчине.

#### Целочисленные виды данных

Целочисленный вид данных (*integer*) — это Число без дробной части. В главе 2 мы использовали один целочисленный вид данных — вид данных `u32`. Такое объявление вида данных указывает, что значение, с которым оно связано, должно быть целым числом без знака (виды данных целых чисел со знаком начинаются с `i` вместо `u`), которое занимает 32 бита памяти. В Таблице 3-1 показаны встроенные целочисленные виды данных в Ржавчине. Мы можем использовать любой из этих исходов для объявления вида данных целочисленного значения.

<span class="caption">Таблица 3-1: целочисленные виды данных в Ржавчине</span>

Длина | Со знаком | Без знака
--- | --- | ---
8 бит | `i8` | `u8`
16 бит | `i16` | `u16`
32 бита | `i32` | `u32`
64 бита | `i64` | `u64`
128 бит | `i128` | `u128`
архитектурно-зависимая | `isize` | `usize`

Каждый исход может быть как со знаком, так и без знака и имеет заранее определенный размер. Такое свойство вида данных как *знаковый* и *беззнаковый* определяет возможность числа быть отрицательным. Другими словами, должно ли Число иметь знак (знаковое) или оно всегда будет только положительным и, следовательно, может быть представлено без знака (беззнаковое). Это похоже на написание чисел на бумаге: когда знак имеет значение, Число отображается со знаком + или со знаком - , однако, когда можно с уверенностью предположить, что Число положительное, оно отображается без знака. Числа со знаком хранятся с использованием [дополнительного рукописи].

Каждый исход со знаком может хранить числа от -(2 <sup>n - 1</sup> ) до 2 <sup>n - 1</sup> - 1 включительно, где *n* — количество битов, которые использует этот исход. Таким образом, `i8` может хранить числа от -(2 <sup>7</sup> ) до 2 <sup>7</sup> - 1, что равно значениям от -128 до 127. Исходы без знака могут хранить числа от 0 до 2 <sup>n</sup> - 1, поэтому `u8` может хранить числа от 0 до 2 <sup>8</sup> - 1, что равно значениям от 0 до 255.

Кроме того, виды данных `isize` и `usize` зависят от архитектуры компьютера, на котором выполняется приложение, и обозначаются в таблице как "arch": 64 бита, если используется 64-битная архитектура, и 32 бита, если используется 32-битная архитектура.

Вы можете записывать целочисленные записи в любой из разновидностей, показанных в таблице 3-2. Заметьте, что числовые записи, имеющие несколько числовых видов данных, допускают использование вставки вида данных, например `57u8`, для обозначения вида данных. Числовые записи также могут использовать `_` в качестве внешнего разделителя для облегчения чтения числа, например `1_000`, который будет иметь такое же значение, как если бы было задано `1000`.

<span class="caption">Таблица 3-2: Целочисленные записи в Ржавчине</span>

Числовая запись | Пример
--- | ---
Десятичный | `98_222`
Шестнадцатеричный | `0xff`
восьмеричный | `0o77`
Двоичный | `0b1111_0000`
Байт (только `u8`) | `b'A'`

Как же узнать, какой вид данных целого числа использовать? Если вы не уверены, значения по умолчанию в Ржавчине, как правило, подходят для начала: целочисленные виды данных по умолчанию `i32`. Основной случай, в котором вы должны использовать `isize` или `usize`, — это упорядочивание какого-либо собрания.

>  <h>Целочисленное переполнение</h> Допустим, имеется переменная вида данных `u8`, которая может хранить значения от 0 до 255. Если попытаться изменить переменную на значение вне этого ряда, например, 256, произойдёт *целочисленное переполнение*, что может привести к одному из двух исходов поведения. Если выполняется сборка в режиме отладки, Ржавчина включает проверку на целочисленное переполнение, приводящую вашу программу к *сбое* во время выполнения, когда возникает такое поведение. Ржавчина использует понятие *сбой (panicking)*, когда приложение завершается с ошибкой. Мы обсудим сбой более подробно в разделе ["Неустранимые ошибки с `panic!`"] в главе 9 . При сборке в режиме release с клеймом `--release`, Ржавчина *не* включает проверки на целочисленное переполнение, которое вызывает сбой. Вместо этого, в случае переполнения, Ржавчина использует *обёртывание второго дополнения*. Проще говоря, значения, превышающие наибольшее значение, которое может хранить вид данных, "оборачиваются" к наименьшему из значений, которые может хранить вид данных. В случае `u8` значение 256 становится 0, значение 257 становится 1, и так далее. Приложение не вызовет сбой, но переменная будет иметь значение, которое, вероятно, не будет соответствовать вашим ожиданиям. Полагаться на поведение обёртывания целочисленного переполнения считается ошибкой. Для явной обработки возможности переполнения существует семейство способов, предоставляемых встроенной библиотекой для простых числовых видов данных:
>  - Обёртывание во всех режимах с помощью способов `wrapping_*`, таких как `wrapping_add`.
> - Возврат значения `None` при переполнении с помощью способов `checked_*`.
> - Возврат значения и разумный показатель, указывающий, произошло ли переполнение при использовании способов `overflowing_*`.
> - Насыщение наименьшим или наибольшим значением с помощью способов `saturating_*`.
>

#### Числа с плавающей запятой

Также в Ржавчине есть два простых вида данных для чисел с плавающей запятой, представляющих собой числа с десятичной точкой. Виды данных с плавающей точкой в Ржавчине - это f32 и f64, размер которых составляет 32 бита и 64 бита соответственно. По умолчанию используется вид данных f64, поскольку на современных ЦПУ он работает примерно с той же скоростью, как и f32, но обладает большей точностью. Все виды данных с плавающей запятой являются знаковыми.

Вот пример, отображающий числа с плавающей запятой в действии:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-06-floating-point/src/main.rs}}
```

Числа с плавающей запятой представлены в соответствии со исполнением IEEE-754. Вид данных `f32` является плавающей запятой одинарной точности, а `f64` - двойной точности.

#### Числовые действия

Ржавчина поддерживает основные математические действия, привычные для всех числовых видов данных: сложение, вычитание, умножение, деление и остаток. Целочисленное деление обрезает значение в направлении нуля до ближайшего целого числа. Следующая рукопись показывает, как можно использовать каждое числовое действие в указании `let`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-07-numeric-operations/src/main.rs}}
```

Каждое выражение в этих указаниях использует математический приказчик и вычисляется в одно значение, которое связывается с переменной. [Приложение B ](appendix-02-operators.html) содержит список всех приказчиков, которые предоставляет Ржавчина.

#### Разумный вид данных

Как и в большинстве других языков программирования, разумный вид данных в Ржавчине имеет два возможных значения: `true` и `false`. Значения разумных видов данных имеют размер в один байт. Разумный вид данных в Ржавчине задаётся с помощью `bool`. Например:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-08-boolean/src/main.rs}}
```

Основной способ использования разумных значений - это использование условий, таких как выражение `if`. Мы рассмотрим, как выражения `if` работают в Ржавчине в разделе ["Поток управления"].

#### Знаковый вид данных

Вид данных `char` в Ржавчине является самым простым алфавитным видом языка. Вот несколько примеров объявления значений `char`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-09-char/src/main.rs}}
```

Заметьте, мы указываем записи `char` с одинарными кавычками, в отличие от строковых записей, для которых используются двойные кавычки. Вид данных `char` в Ржавчине имеет размер четыре байта и представляет собой одиночное значение Unicode, а значит, может представлять собой не только ASCII. Акцентированные буквы, китайские, японские и корейские знаки, эмодзи и пробелы нулевой ширины - все это допустимые значения вида данных `char` в Ржавчине. Одиночные значения Unicode находятся в ряде от `U+0000` до `U+D7FF` и от `U+E000` до `U+10FFFF` включительно. Однако "знак" не является понятием в Unicode, поэтому ваше человеческое представление о том, что такое "знак", может не совпадать с тем, что такое `char` в Ржавчине. Мы подробно обсудим эту тему в главе 8 "Хранение писания в представлении UTF-8 с помощью строк".

### Составные виды данных

*Составные виды данных* могут объединять различные значения в один вид данных. В Ржавчине есть два простых составных вида данных: составные ряды и массивы.

#### Составные ряды

*Составной ряд*- это гибкий способ объединения нескольких значений с различными видами данных в один составной вид данных. составные ряды имеют конечную длину: после объявления они не могут увеличиваться или уменьшаться в размерах.

Мы создаём составной ряд, записывая список значений, разделённых запятыми, внутри круглых скобок. Каждое значение в составном ряде имеет вид данных, причём виды данных различных значений в составном ряде не обязательно должны быть одинаковыми. В этом примере мы добавили необязательные изложения видов данных:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-10-tuples/src/main.rs}}
```

Переменная `tup` связана со всем усоставным рядом, поскольку составной ряд является одной составной переменной. Чтобы получить отдельные значения из составного ряда, можно использовать сопоставление с образцом для разъединения значения составного ряда, например, так:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-11-destructuring-tuples/src/main.rs}}
```

Это приложение сначала создаёт составной ряд и связывает его с переменной `tup`. Затем с помощью образца `let` берётся `tup` и превращается в три отдельные переменные, `x`, `y` и `z`. Это называется *разъединением*, поскольку разбивает единый составной ряд на три части. Наконец, приложение выводит значение `y`, которое равно `6.4`.

Мы также можем получить доступ к переменной составного ряда напрямую, используя точку (`.`), за которой следует порядковый указатель значения, требуемого для доступа. Например:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-12-tuple-indexing/src/main.rs}}
```

Это приложение создаёт составной ряд `x`, а затем обращается к каждой переменной составного ряда, используя соответствующие порядковые указатели. Как и в большинстве языков программирования, первый порядковый указатель в составном ряде равен 0.

составной ряд, не имеющий значений, имеет особое имя  *единичный вид данных (unit)*. Это значение и соответствующий ему вид данных записываются как `()` и представляет собой пустое значение или пустой возвращаемый вид данных. Выражения неявно возвращают значение единичного вида данных, если не возвращают никакого другого значения.

#### Массивы

Другим способом создания собрания из нескольких значений является массив *array*. В отличие от составного ряда, каждая переменная массива должен иметь один и тот же вид данных. В отличие от массивов в некоторых других языках, массивы в Ржавчине имеют конечную длину.

Мы записываем значения в массиве в виде списка, разделённого запятыми, внутри квадратных скобок:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-13-arrays/src/main.rs}}
```

Массивы удобно использовать, если данные необходимо разместить в обойме, а не в куче (мы подробнее обсудим обойму и кучу в [Главе 4]) или если требуется, чтобы количество переменных всегда было конечным. Однако массив не так гибок, как вектор. *Вектор* - это подобный вид собрания, предоставляемый встроенной библиотекой, который *может* увеличиваться или уменьшаться в размере. Если вы не уверены, что лучше использовать - массив или вектор, то, скорее всего, вам следует использовать вектор. Более подробно векторы рассматриваются в [Главе 8].

Однако массивы более полезны, когда вы знаете, что количество переменных не нужно будет изменять. Например, если бы вы использовали названия месяцев в программе, вы, вероятно, использовали бы массив, а не вектор, потому что вы знаете, что он всегда будет содержать 12 переменных:

```rust
let месяцы = ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль",
              "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"];
```

Вид массива записывается следующим образом: в квадратных скобках обозначается вид данных переменных массива, а затем, через точку с запятой, количество переменных. Например:

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

Здесь `i32` является видом данных каждой переменной массива. После точки с запятой указано Число `5`, показывающее, что массив содержит 5 переменных.

Вы также можете объявить массив, содержащий одно и то же значение для каждой переменной, указав это значение вместо вида данных. Следом за этим так же следует точка с запятой, а затем — длина массива в квадратных скобках, как показано здесь:

```rust
let a = [3; 5];
```

Массив в переменной `a` будет включать `5` переменных, значение которых будет равно `3`. Данная запись подобна рукописи `let a = [3, 3, 3, 3, 3];`, но является более краткой.

##### Доступ к переменным массива

Массив — это единый отрывок памяти известного конечного размера, который может быть размещён в обойме. Вы можете получить доступ к переменным массива с помощью упорядочивания, например:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-14-array-indexing/src/main.rs}}
```

В этом примере переменная с именем first получит значение 1, потому что это значение находится по порядковому указателю [0] в массиве. Переменная с именем second получит значение 2 по порядковому указателю [1] в массиве.

##### Неправильный доступ к переменной массива

Давайте посмотрим, что произойдёт, если попытаться получить доступ к переменной массива, находящемуся за его пределами. Допустим, вы запускаете данная рукопись, похожий на игру в угадывание из Главы 2, чтобы получить от пользователя порядковый указатель массива:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,panics
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access/src/main.rs}}
```

Эта рукопись успешно собирается. Если запустить эту рукопись с помощью `cargo run` и ввести `0`, `1`, `2`, `3` или `4`, приложение выведет соответствующее значение по данному порядковому указателю в массиве. Если вместо этого ввести Число за пределами границ массива, например, `10`, то приложение выведет следующее:

<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->

```console
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

Приложение столкнулась с ошибкой во *время выполнения* на этапе применения недопустимого значения во время обращения к порядковому номеру содержимого массива. Приложение завершилась с сообщением об ошибке и не выполнила конечное указание `println!`. При попытке доступа к переменной с помощью порядкового указателя Ржавчина проверяет, что указанный порядковый указатель меньше длины массива. Если порядковый указатель больше или равен длине, Ржавчина вызывает сбой. Эта проверка должна происходить во время выполнения, особенно в данном случае, потому что сборщик не может знать, какое значение введёт пользователь при последующем выполнении рукописи.

Это пример принципов безопасности памяти Ржавчины в действии. Во многих низкоуровневых языках такая проверка не выполняется, и когда вы указываете неправильный порядковый указатель, доступ к памяти может быть неправильным. Ржавчина защищает вас от такого рода ошибок, немедленно закрываясь вместо того, чтобы разрешать доступ к памяти и продолжать работу. В главе 9 подробнее обсуждается обработка ошибок в Ржавчине и то, как вы можете написать  безопасную рукопись, которая не вызывает сбой и не разрешает неправильный доступ к памяти.


[дополнительного рукописи]: https://en.wikipedia.org/wiki/Two%27s_complement
["Поток управления"]: ch03-05-control-flow.html#control-flow
[Главе 4]: ch04-01-what-is-ownership.html#the-stack-and-the-heap
[Главе 8]: ch08-01-vectors.html
["Неустранимые ошибки с `panic!`"]: ch09-01-unrecoverable-errors-with-panic.html