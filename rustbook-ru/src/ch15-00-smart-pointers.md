# Умные указатели

*Указатель* — это общая подход для переменной, которая содержит адрес участка памяти. Этот адрес «относится к», или «указывает на» некоторые другие данные. Наиболее общая разновидность указателя в Ржавчине — это ссылка, о которой вы узнали из Главы 4. Ссылки обозначаются знаком `&` и заимствуют значение, на которое указывают. Они не имеют каких-либо особых возможностей, кроме как ссылаться на данные, и не имеют никаких накладных расходов.

*Умные указатели*, с другой стороны, являются видами данных, которые не только действуют как указатель, но также имеют дополнительные метаданные и возможности. Подход умных указателей не неповторим для Ржавчины: умные указатели возникли в C++ и существуют в других языках. В Ржавчине есть разные умные указатели, определённые во встроенной библиотеке, которые обеспечивают возможность, выходящую за рамки ссылок. Одним из примеров, который мы рассмотрим в этой главе, является вид умного указателя *reference counting* (подсчёт ссылок). Этот указатель позволяет иметь несколько владельцев с помощью отслеживания количества владельцев и, когда владельцев не остаётся, очищает данные.

Ржавчина с его подходом владения и заимствования имеет дополнительное различие между ссылками и умными указателями: в то время, как ссылки только заимствуют данные, умные указатели часто *владеют* данными, на которые указывают.

Ранее мы уже сталкивались с умными указателями в этой книге, хотя и не называли их так, например `String` и `Vec<T>` в главе 8. Оба этих вида данных считаются умными указателями, потому что они владеют некоторой областью памяти и позволяют ею управлять. У них также есть метаданные и дополнительные возможности или заверения. `String`, например, хранит свой размер в виде метаданных и заверяет, что содержимое строки всегда будет в представлении UTF-8.

Умные указатели обычно выполняются с помощью видов данных. Присущей чертой, которая отличает умный указатель от обычного вида данных, является то, что для умных указателей выполнены сущности `Deref` и `Drop`. Сущность `Deref` позволяет образцу умного указателя вести себя как ссылка, так что вы можете написать рукопись, работающей с ним как со ссылкой, так и как с умным указателем. Сущность `Drop` позволяет написать рукопись, которая будет запускаться когда образец данных умного указателя выйдет из области видимости. В этой главе мы обсудим обе сущности и выясним, почему они важны для умных указателей.

Учитывая, что образец данных умного указателя является общим образцом разработки, часто используемым в Ржавчине, эта глава не описывает все существующие умные указатели. Множество библиотек имеют свои умные указатели, и вы также можете написать свои. Мы охватим наиболее распространённые умные указатели из встроенной библиотеки:

- `Box<T>` для распределения значений в куче (памяти)
- `Rc<T>` вид счётчика ссылок, который допускает множественное владение
- Виды данных `Ref<T>` и `RefMut<T>`, доступ к которым осуществляется через вид данных `RefCell<T>`, который обеспечивает правила заимствования во время выполнения вместо времени сборки

Дополнительно мы рассмотрим образец данных *внутренней изменчивости (interior mutability)*, где неизменяемый вид данных предоставляет API для изменения своего внутреннего значения. Мы также обсудим *ссылочные замкнутости (reference cycles)*: как они могут приводить к утечке памяти и как это предотвратить.

Приступим!
