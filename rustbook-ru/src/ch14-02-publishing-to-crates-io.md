## Обнародование библиотеки в Crates.io

Мы использовали дополнения из [crates.io](https://crates.io/)<!--  --> в качестве дополнений в нашем деле, но вы также можете поделиться своими примерами наработок с другими людьми, обнародовав свои собственные дополнения. Перечень библиотек по адресу [crates.io](https://crates.io/)<!--  --> распространяет исходную рукопись ваших дополнений, поэтому он в основном размещает примеры с открытой исходной рукописью.

В Ржавчине и Cargo есть функции, которые облегчают поиск и использование обнародованного дополнения. Далее мы поговорим о некоторых из этих функций, а затем объясним, как обнародовать дополнение.

### Создание полезных примечаний к пособию

Правильное документирование ваших дополнений поможет другим пользователям знать, как и когда их использовать, поэтому стоит потратить время на написание пособия. В главе 3 мы обсуждали, как вносить примечания в рукопись Ржавчины, используя две косые черты, `//`. В Ржавчине также есть особый вид примечаний к пособию, который обычно называется *примечанием к пособию*, который порождает пособие HTML. HTML-рукопись отображает содержимое примечаний к пособию для открытых переменных API, предназначенных для программистов, увлеченных в знании того, как *использовать* вашу библиотеку, в отличие от того, как она *выполнена*.

Примечания к пособию используют три слеша, `///` вместо двух и поддерживают наставление Markdown для разметки писания. Размещайте примечания к пособию непосредственно перед элементом, который они документируют. В приложении 14-1 показаны примечания к пособию для функции `add_one` в библиотеке с именем `my_crate`:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch14-more-about-cargo/listing-14-01/src/lib.rs}}
```

<span class="caption">Приложение 14-1: Примечание к пособию для функции</span>

Здесь мы даём описание того, что делает функция `add_one`, начинаем раздел с заголовка `Examples`, а затем предоставляем рукопись, которая отображает, как использовать функцию `add_one`. Мы можем создать пособие HTML из этого примечания к пособию, запустив `cargo doc`. Этот приказ запускает средство `rustdoc`, поставляемое с Ржавчиной, и помещает созданное HTML-пособие в папку *target/doc*.

Для удобства, запустив `cargo doc --open`, мы создадим HTML для пособия вашей текущей библиотеки (а также пособие для всех дополнений вашей библиотеки) и откроем итог в сетевого-обозревателе. Перейдите к функции `add_one` и вы увидите, как отображается писание в примечаниях к пособию, что показано на рисунке 14-1:

 <img alt="HTML-пособие для функции `add_one`` my_crate`" src="img/trpl14-01.png" class="center">

<span class="caption">Рисунок 14-1: HTML пособие для функции <code>add_one</code></span>

#### Часто используемые разделы

Мы использовали Markdown заголовок `# Examples` в приложении 14-1 для создания раздела в HTML с заголовком "Examples". Вот некоторые другие разделы, которые составители библиотек обычно используют в своей пособия:

- **Panics**: Задумки, в которых документированная функция может вызывать сбой. Вызывающие функцию, которые не хотят, чтобы их программы вызвал сбои, должны убедиться, что они не вызывают функцию в этих случаях.
- **Ошибки**: Если функция возвращает `Result`, описание видов ошибок, которые могут произойти и какие условия могут привести к тому, что эти ошибки могут быть возвращены, может быть полезным для вызывающих, так что они могут написать рукопись для обработки различных видов ошибок разными способами.
- **Безопасность**: Если функция является `unsafe` для вызова (мы обсуждаем безопасность в главе 19), должен быть раздел, объясняющий, почему функция небезопасна и охватывающий неизменные величины, которые функция ожидает от вызывающих сторон.

В подавляющем большинстве случаев примечания к пособию не нуждаются во всех этих разделах, но это хорошая подсказка, напоминающая вам о тех особенностях вашей рукописи, о которых пользователям будет важно узнать.

#### Примечания к пособию как проверки

Добавление примеров рукописи в примечания к пособию может помочь отобразить, как использовать вашу библиотеку, и это даёт дополнительное преимущество: запуск `cargo test` запустит примеры рукописи в вашем пособии как проверки! Нет ничего лучше, чем пособие с примерами. Но нет ничего хуже, чем примеры, которые не работают, потому что рукопись изменилась со времени написания пособия. Если мы запустим `cargo test` с пособием для функции `add_one` из приложения 14-1, мы увидим раздел итогов проверки, подобный этому:

<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo test
copy just the doc-tests section below
-->

```text
   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s
```

Теперь, если мы изменим либо функцию, либо пример, так что `assert_eq!` в примере вызывает сбой, и снова запустим `cargo test`, мы увидим, что проверки пособия обнаруживают, что пример и рукопись не согласованы друг с другом!

#### Указание примечаний, содержащихся переменных

Исполнение примечаний к документам `//!` добавляет пособие к переменной, содержащему примечания, а не к переменным, следующим за примечаниями. Обычно мы используем эти примечания внутри корневого файла ящика (по соглашению *src/lib.rs* ) или внутри раздела для документирования ящика или раздела в целом.

Например, чтобы добавить пособие, описывающую назначение `my_crate` , содержащего функцию `add_one` , мы добавляем примечания к пособию, начинающиеся с `//!` в начало файла *src/lib.rs* , как показано в приложении 14-2:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch14-more-about-cargo/listing-14-02/src/lib.rs:here}}
```

<span class="caption">Приложение 14-2: Пособие для ящика <code>my_crate</code> в целом</span>

Обратите внимание, что после последней строки, начинающейся с `//!`, нет никакого рукописи. Поскольку мы начали примечания с `//!` вместо `///`, мы документируем элемент, который содержит это примечание, а не элемент, который следует за этим примечанием. В данном случае таким элементом является файл *src/lib.rs*, который является корнем crate. Эти примечания описывают весь ящик.

Когда мы запускаем `cargo doc --open`, эти примечания будут отображаться на первой странице пособия для `my_crate` над списком открытых переменных в библиотеке, как показано на рисунке 14-2:

 <img alt="Пособие для библиотеки `art`, в которой перечислены разделы `types` и `utils`" src="img/trpl14-02.png" class="center">

<span class="caption">Рисунок 14-2: Предоставленная пособие для <code>my_crate</code>, включая примечание, описывающие ящик в целом</span>

Примечания к пособию внутри переменных полезны для описания ящиков и разделов особенно. Используйте их, чтобы объяснить общую цель дополнения, чтобы помочь вашим пользователям понять устройство ящика.

### Экспорт удобного общедоступного API с `pub use`<a id="exporting-a-convenient-public-api-with-pub-use"></a>

Устройство вашего открытого API является основным обстоятельством при обнародования ящика. Люди, которые используют вашу библиотеку, менее знакомы с устройством, чем вы и могут столкнуться с трудностями при поиске частей, которые они хотят использовать, если ваша библиотека имеет большую упорядочивание разделов.

В главе 7 мы рассмотрели, как сделать переменные общедоступными с помощью ключевого слова `pub` и ввести переменные в область видимости с помощью ключевого слова `use`. Однако устройство, которое имеет смысл для вас при разработке ящика, может быть не очень удобной для пользователей. Вы можете согласовать устройство в виде упорядочивания с несколькими уровнями, но тогда люди, желающие использовать вид данных, который вы определили в глубине упорядочивания, могут столкнуться с неполадкой его поиска. Их также может раздражать необходимость вводить `use` `my_crate::some_module::another_module::UsefulType;` вместо `use` `my_crate::UsefulType;`.

Хорошей новостью является то, что если устройство *не* удобно для использования другими из другой библиотеки, вам не нужно перестраивать внутреннее устройство: вместо этого вы можете реэкспортировать переменные, чтобы сделать открытое устройство, отличное от вашего внутреннего устройства, используя `pub use`. Реэкспорт берет открытую переменную или способ в одном месте и делает его открытым в другом месте, как если бы он был определён в другом месте.

Например, скажем, мы создали библиотеку с именем `art` для расчетов художественных подходов. Внутри этой библиотеки есть два раздела: раздел `kinds` содержащий два перечисления с именами `PrimaryColor` и `SecondaryColor` и раздел `utils`, содержащий функцию с именем `mix`, как показано в приложении 14-3:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground,test_harness
{{#rustdoc_include ../listings/ch14-more-about-cargo/listing-14-03/src/lib.rs:here}}
```

<span class="caption">Приложение 14-3: Библиотека <code>art</code> с переменными, согласованными в разделы <code>kinds</code> и <code>utils</code></span>

На рисунке 14-3 показано, как будет выглядеть титульная страница пособия для этого ящика, созданный `cargo doc`:

 <img alt="Предоставлена Пособие для библиотеки `art` с реэкспортом на первой странице" src="img/trpl14-03.png" class="center">

<span class="caption">Рисунок 14-3: Первая страница пособия для <code>art</code>, в которой перечислены разделы <code>kinds</code> и <code>utils</code></span>

Обратите внимание, что виды данных `PrimaryColor` и `SecondaryColor` не указаны на главной странице, равно как и функция `mix`. Мы должны нажать `kinds` и `utils`, чтобы увидеть их.

В другой библиотеке, которая зависит от этой библиотеки, потребуются приказчики `use`, которые подключают переменные из `art` в область видимости, определяя устройство раздела, которая определена в данный мгновение. В приложении 14-4 показан пример ящика, в котором используются переменные `PrimaryColor` и `mix` из ящика `art`:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch14-more-about-cargo/listing-14-04/src/main.rs}}
```

<span class="caption">Приложение 14-4: Ящик использующий переменные из ящика <code>art</code> с экспортированным внутренним устройством</span>

Составителю рукописи в приложении 14-4, которая использует ящик `art`, пришлось выяснить, что `PrimaryColor` находится в разделе `kinds`, а `mix` - в разделе `utils`. Устройства раздела `art` ящика больше подходит для разработчиков, работающих над `art` ящиком, чем для тех, кто его использует. Внутреннее устройство не содержит никаких полезных сведений для того, кто пытается понять, как использовать ящик `art`, а скорее вызывает путаницу, поскольку разработчики, использующие его, должны понять, где искать, и должны указывать имена разделов в выражениях `use`.

Чтобы удалить внутреннее устройство из общедоступного API, мы можем изменить рукопись ящика `art` в приложении 14-3, чтобы добавить приказчики `pub use` для повторного реэкспорта переменных на верхнем уровне, как показано в приложении 14-5:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch14-more-about-cargo/listing-14-05/src/lib.rs:here}}
```

<span class="caption">Приложение 14-5: Добавление приказчиков <code>pub use</code> для реэкспорта переменных</span>

Пособие API, которую `cargo doc` порождает для этой библиотеки, теперь будет перечислять и связывать реэкспорты на главной странице, как показано на рисунке 14-4, упрощая поиск видов данных `PrimaryColor`, `SecondaryColor` и функции `mix`.

 <img alt="HTML-пособие с примечанием для библиотеки в целом" src="img/trpl14-04.png" class="center">

<span class="caption">Рисунок 14-4: Первая страница пособия для <code>art</code>,  которая перечисляет реэкспорт</span>

Пользователи ящика `art` могут по-прежнему видеть и использовать внутреннее устройство из приложения 14-3, как показано в приложении 14-4, или они могут использовать более удобное устройство в приложении 14-5, как показано в приложении 14-6:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch14-more-about-cargo/listing-14-06/src/main.rs:here}}
```

<span class="caption">Приложение 14-6: Программа, использующая реэкспортированные переменные из ящика <code>art</code></span>

В случаях, когда имеется много вложенных разделов, реэкспорт видов данных на верхнем уровне с помощью `pub use` может существенно повысить удобство работы для людей, использующих ящик. Ещё одно распространённое использование `pub use` - это реэкспорт определений зависимого раздела в текущем ящике, чтобы сделать определения этого ящика частью открытого API вашего ящика.

Создание полезного открытого устройства API - это больше искусство чем наука, и вы можете повторять, чтобы найти API, который лучше всего подойдёт вашим пользователям. Использование `pub use` даёт вам гибкость в том, как вы внутренне выстраиваете свою библиотеку внутри и отделяете это внутреннее устройство от того, что вы предоставляете пользователям. Посмотрите на рукопись некоторых установленных ящиков, чтобы увидеть отличается ли их внутреннее устройства от их открытого API.

### Настройка учётной записи Crates.io

Прежде чем вы сможете обнародовать любые библиотеки, вам необходимо создать учётную запись на [crates.io](https://crates.io/)<!--  --> и получить API токен. Для этого зайдите на домашнюю страницу [crates.io](https://crates.io/)<!--  --> и войдите в систему через учётную запись GitHub. (В настоящее время требуется наличие учётной записи GitHub, но сайт может поддерживать другие способы создания учётной записи в будущем.) Сразу после входа в систему перейдите в настройки своей учётной записи по адресу [https://crates.io/me/](https://crates.io/me/)<!--  --> и получите свой ключ API. Затем выполните приказ `cargo login` с вашим ключом API, например:

```console
$ cargo login abcdefghijklmnopqrstuvwxyz012345
```

Этот приказ сообщит Cargo о вашем API token и сохранит его местно в *~/.cargo/credentials*. Обратите внимание, что этот токен является *тайным*: не делитесь им ни с кем другим. Если вы по какой-либо причине поделитесь им с кем-либо, вы должны отозвать его и создать новый токен на [crates.io](https://crates.io/).

### Добавление метаданных в новую библиотеку

Допустим, у вас есть ящик, который вы хотите обнародовать. Перед обнародованием вам нужно добавить некоторые метаданные в раздел `[package]` файла *Cargo.toml* ящика.

Вашему ящику понадобится не повторяющееся имя. Пока вы работаете над ящиком местно, вы можете назвать его как угодно. Однако названия ящиков на [crates.io](https://crates.io/)<!-- ignore --> определятся в мгновение первой обнародования. Как только ящику присвоено название, никто другой не сможет обнародовать ящик с таким же именем. Перед тем как обнародовать ящик, поищите название, которое вы хотите использовать. Если такое имя уже используется, вам придётся подобрать другое и изменить поле `name` в файле *Cargo.toml* в разделе `[package]`, чтобы использовать новое имя в качестве размещаяемого, например, так:

<span class="filename">Файл: Cargo.toml</span>

```toml
[package]
name = "guessing_game"
```

Даже если вы выбрали не повторяющееся имя, когда вы запустите `cargo publish` чтобы обнародовать ящик, вы получите предупреждение, а затем ошибку:

<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo publish
copy just the relevant lines below
-->

```console
$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
--snip--
error: failed to publish to registry at https://crates.io

Caused by:
  the remote server responded with an error: missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for how to upload metadata
```

Это ошибка, потому что вам не хватает важной сведений: необходимы описание и лицензия, чтобы люди знали, что делает ваш ящик и на каких условиях они могут его использовать. В поле *Cargo.toml* добавьте описание, состоящее из одного-двух предложений, поскольку оно будет появляться вместе с вашим ящиком в итогах поиска. Для поля `license` нужно указать значение *определителя лицензии*. В [Linux Foundation's Software Package Data Exchange (SPDX)] перечислены определители, которые можно использовать для этого значения. Например, чтобы указать, что вы лицензировали свой crate, используя лицензию MIT, добавьте определитель `MIT`:

<span class="filename">Файл: Cargo.toml</span>

```toml
[package]
name = "guessing_game"
license = "MIT"
```

Если вы хотите использовать лицензию, которая отсутствует в SPDX, вам нужно поместить писание этой лицензии в файл, включите файл в своё дело, а затем используйте `license-file`, чтобы указать имя этого файла вместо использования ключа `license`.

Руководство по выбору лицензии для вашего дела выходит за рамки этой книги. Многие люди в сообществе Ржавчина лицензируют свои дела так же, как и Ржавчина, используя двойную лицензию `MIT OR Apache 2.0`. Эта применение отображает, что вы также можете указать несколько определителей лицензий, разделённых `OR`, чтобы иметь несколько лицензий для вашего дела.

С добавлением единственного имени, исполнения, вашего описания и лицензии, файл *Cargo.toml* для дела, который готов к обнародования может выглядеть следующим образом:

<span class="filename">Файл: Cargo.toml</span>

```toml
[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"
description = "A fun game where you guess what number the computer has chosen."
license = "MIT OR Apache-2.0"

[dependencies]
```

[Пособие Cargo](https://doc.rust-lang.org/cargo/) описывает другие метаданные, которые вы можете указать, чтобы другие могли легче находить и использовать ваш ящик.

### Обнародование на Crates.io

Теперь, когда вы создали учётную запись, сохранили свой токен API, выбрали имя для своего ящика и указали необходимые метаданные, вы готовы к обнародования! Обнародование библиотеки загружает определённую исполнение в [crates.io](https://crates.io/)<!--  --> для использования другими.

Будьте осторожны, потому что обнародование является *перманентной* действием. Исполнение никогда не сможет быть перезаписана, а рукопись не подлежит удалению. Одна из основных целей [crates.io](https://crates.io/)<!-- ignore --> - служить постоянным архивом рукописи, чтобы сборки всех дел, зависящих от crates из [crates.io](https://crates.io/)<!-- ignore --> продолжали работать. Предоставление возможности удаления исполнений сделало бы выполнение этой цели невозможным. При этом количество исполнений ящиков, которые вы можете обнародовать, не ограничено.

Запустите приказ `cargo publish` ещё раз. Сейчас этот приказ должен выполниться успешно:

<!-- manual-regeneration
go to some valid crate, publish a new version
cargo publish
copy just the relevant lines below
-->

```console
$ cargo publish
    Updating crates.io index
   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
   Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
```

Поздравляем! Теперь вы поделились своей рукописью с сообществом Ржавчины и любой может легко добавить вашу библиотеку в качестве дополнения в своё дело.

### Обнародование нового исполнения существующей библиотеки

Когда вы внесли изменения в свой ящик и готовы выпустить новую исполнение, измените значение `version`, указанное в вашем файле *Cargo.toml* и повторите размещение. Воспользуйтесь [Semantic Versioning rules], чтобы решить, какой номер следующей исполнения подходит для ваших изменений. Затем запустите `cargo publish`, чтобы загрузить новую исполнение.

<!-- Old link, do not remove -->

<a id="removing-versions-from-cratesio-with-cargo-yank"></a>

### Устранение устаревших исполнений с Crates.io с помощью `cargo yank`

Хотя вы не можете удалить предыдущие исполнения ящика, вы можете помешать любым будущим делам добавлять его в качестве нового дополнения. Это полезно, когда исполнение ящика сломана по той или иной причине. В таких случаях Cargo поддерживает *выламывание* (yanking) исполнения ящика.

Вычёркивание исполнения не позволяет новым делам зависеть от этой исполнения, но при этом позволяет всем существующим делам, зависящим от неё, продолжать работу. По сути, исключение означает, что все дела с *Cargo.lock* не сломаются, а любые файлы *Cargo.lock*, которые будут порождаться в будущем, не смогут использовать исключённую исполнение.

Чтобы вычеркнуть исполнение ящика, в папки ящика, который вы обнародовали ранее, выполните приказ `cargo yank` и укажите, какую исполнение вы хотите вычеркнуть. Например, если мы обнародовали ящик под названием `guessing_game` исполнения 1.0.1 и хотим вычеркнуть её, в папке дела для `guessing_game` мы выполним:

<!-- manual-regeneration:
cargo yank carol-test --version 2.1.0
cargo yank carol-test --version 2.1.0 --undo
-->

```console
$ cargo yank --vers 1.0.1
    Updating crates.io index
        Yank guessing_game@1.0.1
```

Добавив в приказ `--undo`, вы также можете отменить выламывание и разрешить делам начать зависеть от исполнения снова:

```console
$ cargo yank --vers 1.0.1 --undo
    Updating crates.io index
      Unyank guessing_game@1.0.1
```

Вычёркивание *не удаляет* рукопись. Оно не может, например, удалить случайно загруженные пароли. Если это произойдёт, вы должны немедленно сбросить эти пароли.


[Linux Foundation's Software Package Data Exchange (SPDX)]: http://spdx.org/licenses/
[Semantic Versioning rules]: http://semver.org/