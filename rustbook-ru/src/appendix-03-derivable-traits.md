## Дополнение В: Выводимые сущности

Во многих частях книги мы обсуждали свойство `derive`, которые Вы могли применить к объявлению стопки или перечисления. Свойство `derive` порождает рукопись по умолчанию для использования сущности, который вы указали в  `derive`.

В этом дополнении, мы расскажем про все сущности, которые вы можете использовать в свойстве `derive`. Каждая раздел содержит:

- Действия и способы, добавляемые сущностью
- Как представлена использование сущности через `derive`
- Что использование сущности рассказывает про вид
- Условия, в которых разрешено или запрещено использовать сущность
- Примеры случаев, которые требуют наличие сущности

Если Вам понадобилось поведение отличное от поведения при использовании через `derive`, обратитесь к [пособия по встроенной библиотеке](../std/index.html)<!-- ignore --> чтобы узнать как вручную использовать сущность.

Перечисленные здесь сущности являются единственными, определёнными встроенной библиотекой, которые могут быть выполнены в ваших видах с помощью `derive`. Другие сущности, определённые во встроенной библиотеке, не имеют ощутимого поведения по умолчанию, поэтому вам решать, как использовать их для достижения ваших целей.

Пример сущности, которую нельзя использовать через derive - `Display`, который обрабатывает разметку для конечных пользователей. Вы всегда должны сами рассмотреть лучший способ для отображения вида данных конечному пользователю. Какие части видов данных должны быть разрешены для просмотра конечному пользователю? Какие части они найдут подходящими? Какой вид вывода для них будет самым подходящим? Сборщик Ржавчины не знает ответы на эти вопросы, поэтому он не может подобрать подходящее обычное поведение.

Список видов, используемых через derive, в этом дополнении не является исчерпывающим: библиотеки могут использовать `derive` для их собственных сущностей, составляя свои списки сущностей, которые Вы можете использовать с помощью `derive`. Использование `derive` включает в себя использование процедурных макросов, которые были рассмотрены в разделе ["Макросы"]<!--  --> Главы 19.

### `Debug` для отладочного вывода

Сущность `Debug` включает отладочную разметку в размеченных строках, которые вы можете указать с помощью `:?` внутри `{}` узорчатых скобок.

Сущность `Debug` позволяет Вам вывести предметы видов данных с целью отладки, поэтому Вы и другие разработчики, использующие Ваш вид, смогут проверить предмет в определённой точке выполнения приложения.

Сущность `Debug` обязателен в некоторых случаях. Например, при использовании макроса `assert_eq!`. Этот макрос выводит значения входных переменных, если они не совпадают. Это позволяет разработчикам увидеть, почему эти предметы не равны.

### `PartialEq` и `Eq` для сравнения равенства

Сущность `PartialEq` позволяет Вам сравнить предметы одного вида данных на равнозначность, и включает для них использование приказчиков `==` и `!=`.

Использование `PartialEq` использует способ `eq`. Когда `PartialEq` используют для стопки, два предмета равны если равны *все* поля предметов, и предметы не равны, если хотя бы одно поле отлично. Когда используется для перечислений, каждый исход равен себе, и не равен другим исходам.

Сущность `PartialEq` обязателен в некоторых случаях. Например для макроса `assert_eq!`, где необходимо сравнивать два предмета одного вида данных на равнозначность.

Сущность `Eq` не имеет способов. Он указывает что каждое значение определенного вида данных равно самому себе. Сущность `Eq` может быть применён только для видов использующих сущность `PartialEq`, хотя не все виды, которые используют `PartialEq` могут использовать `Eq`. Примером являются числа с плавающей запятой: использование чисел с плавающей запятой говорит, что два образца данных со значениями не-Число (`NaN`) не равны друг другу.

Сущность `Eq`необходим в некоторых случаях. Например, для ключей в `HashMap<K, V>`. Поэтому `HashMap<K, V>` может сказать, что два ключа являются одним и тем же.

### `PartialOrd` и `Ord` для сравнения значений

Сущность `PartialOrd` позволяет Вам сравнить предметы одного вида данных с помощью упорядочивания. Вид данных, использующий сущность `PartialOrd`, может использоваться с приказчиками `<`, `>`, `<=`, и `>=`. Вы можете использовать сущность `PartialOrd` только для тех видов данных, которые поддерживают `PartialEq`.

Сущность `PartialOrd` использует способ `partial_cmp`, который в возвращает значение `Option<Ordering>`, в случае ошибки возвращает `None`, в том случае, когда значения нельзя упорядочить и соответственно сравнить. Примером значения, которое не может быть упорядочено, это то - что не являются числом , то есть (`NaN`) при сравнении значения с плавающей запятой. Вызов `partial_cmp` с любым числом с плавающей запятой и значением `NaN` вернёт `None`.

При использовании сущности `PartialOrd` для стопок, происходит сравнения двух предметов, путём сравнения значений каждого поля в таком порядке, в котором эти поля объявлены в стопке. Когда используется для перечислений, то исходы перечисления, объявленные ранее, будут меньше чем исходы объявленные позже.

Например, сущность `PartialOrd` может потребоваться для способа `gen_range` из дополнения `rand`, которое порождает случайные значения в заданном пределе (который определён нижней и верхней границей).

Сущность `Ord` производит проверку с целью подтвердить, что для двух значений определенного вида данных всегда можно произвести сравнение и упорядочить. Сущность `Ord` использует способ `cmp`, который возвращает `Ordering` а не `Option<Ordering>`, потому что значения всегда можно упорядочить и сравнить. Вы можете применить сущность  `Ord` только для тех видов данных, которые поддерживают сущность `PartialOrd` и `Eq` (`Eq` также требует `PartialEq`). При использовании на стопках или перечислениях, `cmp` имеет такое же поведение, как и `partial_cmp` в `PartialOrd`.

Сущность `Ord` необходима в некоторых случаях. Например, сохранение значений в `BTreeSet<T>`, в виде данных, который хранит сведения на основе упорядоченных данных.

### `Clone` и `Copy` для создания повтора (двойника) значений переменных

Сущность `Clone` позволяет вам явно создать полный повтор значения, хранимого в переменной, а также этап повторения может вызывать особую рукопись и воспроизводить данные с кучи. Более подробно про `Clone` смотрите в разделы ["Способы взаимодействия переменных и данных: удваивание"](ch04-01-what-is-ownership.html#ways-variables-and-data-interact-clone) в разделе 4.

Использование `Clone` использует способ `clone`, который в случае выполнения на всем виде, вызывает `clone`для каждой части данных вида. Это подразумевает, что все поля или значения в виде данных также должны использовать `Clone` для использования `Clone`.

Сущность `Clone` необходим в некоторых случаях. Например, для вызова способа `to_vec` для среза. Срез не владеет данными, содержащимися в нем, но вектор значений, возвращённый из `to_vec` должен владеть этими предметами, поэтому `to_vec` вызывает `clone` для всех данных. Таким образом, вид хранящийся в срезе, должен использовать `Clone`.

Сущность `Copy` позволяет повторять значения повторяя только данные, которые хранятся в обойме, произвольная рукопись не требуется. Смотрите раздел ["Данные из обоймы: Повторение"](ch04-01-what-is-ownership.html#stack-only-data-copy)<!-- ignore --> в разделе 4 для больших сведений о `Copy`.

Сущность `Copy` не содержит способов для предотвращения перегрузки этих способов разработчиками, иначе бы это нарушило соглашение, что никакой произвольная рукопись не запускается. Таким образом все разработчики могут предполагать, что повторение значений будет происходить быстро.

Вы можете вывести `Copy` для любого вида данных все части которого используют `Copy`. Вид, который использует `Copy` должен также использовать `Clone`, потому что вид использующий `Copy` имеет обыкновенную использование `Clone` который использует ту же задачу, что и `Copy`.

Сущность `Copy` нужна очень редко; виды, использующие `Copy` имеют небольшую переработку, то есть для него не нужно вызывать способ `clone`, который делает рукопись более кратким.

Все, что вы делаете с `Copy` можно также делать и с `Clone`, но рукопись может быть медленнее и требовать вызов способа `clone` в некоторых местах.

### `Hash` для превращения значения в значение конечного размера

Сущность `Hash` позволяет превратить значение произвольного размера в значение конечного размера с использованием хеш-функции. Использование `Hash` использует способ `hash`. При использовании через derive, способ `hash` сочетает итоги вызова `hash` на каждой части данных вида, то есть все поля или значения должны использовать `Hash` для использования `Hash` с помощью derive.

Сущность `Hash` необходим в некоторых случаях. Например, для хранения ключей в `HashMap<K, V>`, для их более качественного хранения.

### `Default` для значений по умолчанию

Сущность `Default` позволяет создавать значение по умолчанию для вида. Использование `Default` использует функцию `default`. Обычная использование способа `default` вызовет функцию `default` на каждой части данных вида, то есть для использования `Default` через derive, все поля и значения вида данных должны также использовать `Default`.

Функция `Default::default`часто используется в сочетания с правилами написания обновления стопки, который мы обсуждали в разделы ["Создание образца данных стопки из образца данных другой стопки с помощью правил написания обновления стопки"](ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax)<!-- ignore --> Главы 5. Вы можете настроить несколько полей для стопки, а для остальных полей установить значения с помощью <code>..Default::default()</code>.

Сущность `Default` необходим в некоторых случаях. Например, для способа `unwrap_or_default` у вида данных `Option<T>`. Если значение `Option<T>` будет `None`, способ `unwrap_or_default` вернёт итог вызова функции `Default::default` для вида данных `T`, хранящегося в `Option<T>`.


["Макросы"]: ch19-06-macros.html#macros