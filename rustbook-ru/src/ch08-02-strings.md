## Хранение закодированного писания UTF-8 в строках

Мы говорили о строках в главе 4, но сейчас мы рассмотрим их более подробно. Новички в Ржавчине обычно застревают на строках из-за  сочетания трёх причин: склонность сборщика Ржавчины  к выявлению возможных ошибок, более сложный вид данных чем считают многие программисты и UTF-8. Эти обстоятельства объединяются таким образом, что освоение может показаться сложным, если вы пришли из других языков программирования.

Рассмотрим строки в среде собраний, потому что строки внутренне представлены в виде набора байтов, дополнительно включены ряд способов для обеспечения действий над строками, которые выполняют действия над при переводе их в писание, понятное человеку. В этом разделе мы поговорим о действиях над видом данных `String`. Создание, чтение, изменение, которые есть у каждого вида собраний. Мы также обсудим какими особенностями вид данных `String` отличается от других собраний, а именно каким образом упорядочивание в виде данных  `String` осложняется различием между тем как люди и компьютеры представляют данные, заключённые в виде `String`.

### Что же такое строка?

Сначала мы определим, что мы подразумеваем под понятием  `*строка* (string)`. В Ржавчине есть только один строковый вид данных в ядре языка - срез строки `str`, обычно используемый в заимствованном исполнении как вид данных `&str`. В Главе 4 мы говорили о *срезах строк, string slices*, которые являются ссылками на некоторые строковые данные в представлении UTF-8. Например, строковые записи хранятся в двоичном файле программы и поэтому являются срезами строк.

Вид данных `String` , предоставляемый встроенной библиотекой Ржавчины, не встроен в ядро языка. Поэтому его можно расширять, изменять, изменять владение, он представлен в виле UTF-8.  Когда Rustaceans говорят о "строках" то, они обычно имеют в виду виды данных `String` или строковые срезы `&str`, а не просто один из них. Хотя этот раздел в основном посвящён виду данных `String`, оба вида данных усиленно используются во встроенной библиотеке Ржавчины оба, и сама строка `String` и строковые срезы, кодируются в UTF-8.

### Создание новых строк

Многие из тех же действий, которые доступны  виду данных `Vec<T>` , доступны также в виде данных `String`, потому что `String` в действительности выполнен как обёртка вокруг вектора байтов с некоторыми дополнительными заверениями, ограничениями и возможностями. Примером способа, который одинаково работает с видами данных `Vec<T>` и `String`, является способ  `new`, создающий новый образец вида данных, и показана в Приложении 8-11.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-11/src/main.rs:here}}
```

<span class="caption">Приложение 8-11: Создание новой пустой строки вида данных <code>String</code></span>

Эта строка создаёт новую пустую строковую переменную с именем `s`, в которую мы можем затем внести данные. Часто у нас есть некоторые начальные данные, которые мы хотим присвоить строке. Для этого мы используем способ `to_string`, доступный для любого вида данных, который использует сущность `Display`, как у строковых записей. Приложение 8-12 показывает два примера.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-12/src/main.rs:here}}
```

<span class="caption">Приложение 8-12: Использование способа <code>to_string</code> для создания образца вида данных <code>String</code>  из строковой записи</span>

Эти выражения создают строку с содержимым `initial contents`.

Мы также можем использовать способ (функцию) `String::from` для создания вида данных `String`  из строковой записи (строкового среза). Рукопись приложения 8-13 является равнозначной рукописи из приложения 8-12, которая использует способ `to_string`:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-13/src/main.rs:here}}
```

<span class="caption">Приложение 8-13: Использование способа <code>String::from</code> для создания образца вида данных <code>String</code> из строковой записи</span>

Поскольку строки используются для очень многих вещей, можно использовать множество API для строк, предоставляющих множество возможностей. Некоторые из них могут показаться избыточными, но все они применимы в том или ином случае!  В данном случае способы `String::from` и `to_string` делают одно и тоже, поэтому выбор зависит от исполнения, которое вас больше всего устраивает.

Запомните, что строки представлены в UTF-8, поэтому можно использовать любые допустимые знаки, которые включены в UTF-8, как показано в приложении 8-14:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:here}}
```

<span class="caption">Приложение 8-14: Хранение приветствий в `строках` на разных языках</span>

Все это допустимые наборы знаков для вида данных `String`, представленных в UTF-8.

### Изменение строковых данных

Строка `String` может увеличиваться в размере, а её содержимое может меняться, по подобию как содержимое `Vec<T>` при вставке в него большего количества данных. Кроме того, можно использовать приказчик `+` или макрос `format!` для объединения значений `String`.

#### Присоединение к строке с помощью способов `push_str` и `push`

Мы можем расширять вид данных `String` используя способ `push_str`, который добавит в исходную строку новые знаки (строковый срез), как показано в приложении 8-15.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-15/src/main.rs:here}}
```

<span class="caption">Приложение 8-15. Добавление среза строки к <code>String</code> с помощью способа <code>push_str</code></span>

После выполнения способа `push_str` строка `s` будет содержать значение `foobar`. В ярлыке способа `push_str` принимается переменная - строковый срез, так как нам не обязательно быть владельцем значения. Например, в рукописи в приложении 8-16 показан исход, когда мы не передаем владение строковым срезом `s2` другой строке - `s1` через способ `push_str`. Мы просто добавляем строковый срез `s2` к строке `s1`.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-16/src/main.rs:here}}
```

<span class="caption">Приложение 8-16: Использование среза строки после его добавления к содержимому другой <code>String</code></span>

Если способ `push_str` стал бы владельцем переменной`s2`, мы не смогли бы вывести его значение в последней строке. Однако эта рукопись работает так, как мы ожидали!

Способ `push` принимает один знак в качестве свойства и добавляет его к `String`. В приложении 8-17 показана рукопись, добавляющая букву “l” к `String`, используя способ `push`.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-17/src/main.rs:here}}
```

<span class="caption">Приложение 8-17: Добавление одного знака к строке <code>s</code>, используя способ <code>push</code></span>

В итоге `s` будет содержать `lol`.

#### Объединение строк с помощью приказчика `+` или макроса `format!`

Часто хочется объединять две существующие строки. Один из возможных способов — это использование приказчика `+` из приложения 8-18:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-18/src/main.rs:here}}
```

<span class="caption">Приложение 8-18: Использование приказчика <code>+</code> для объединения двух значений вида данных <code>String</code> в новую <code>String</code> </span>

Строка `s3` будет содержать `Hello, world!`. При использовании способа `+` переменная `s1` после действия добавления больше недействительна, при этом обязательно использование ссылки на строку `s2`. Данные обстоятельства указаны в ярлыке вызываемого способа приказчика `+`. Приказчик `+` использует способ `add`, чей ярлык выглядит примерно так:

```rust,ignore
fn add(self, s: &str) -> String {
```

Во встроенной библиотеке вы увидите способ `add`, определённым с использованием обобщённых и связанных видов данных. Здесь мы видим ярлык  с определенными видами данных, заменяющими обобщённый, что происходит когда вызывается данный способ со значениями `String`. Мы обсудим обобщённые виды данных в Главе 10. Этот ярлык даёт нам ключ для понимания особенностей приказчика `+`.

Во-первых, перед переменной `s2` мы видим знак `&`, что означает что мы объединяем *ссылку* на строку `s2` со строкой `s1`. Это происходит из-за  свойства `s` в способе `add`: мы можем добавить только ссылку на срез строки `&str` к виду данных `String`; мы не можем сложить два значения вида данных `String`. Но подождите — ссылка `&s2` это ссылка на строку `&String`, а не на срез строки `&str`, как определено второе свойство в способе `add`. Так почему рукопись в приложении 8-18 собирается?

Причина, по которой мы можем использовать неизменяемую ссылку на строку `&s2` в вызове способа `add` заключается в том, что сборщик может *принудительно привести (coerce)* переменную вида данных строка `&String` к виду данных строковый срез `&str`. Когда мы вызываем способ `add`, в Ржавчине используется *принудительное приведение* (deref coercion), которое превращает строку `&s2` в  строковый срез `&s2[..]`. Мы подробно обсудим принудительное приведение в Главе 15. Так как способ `add` не забирает во владение переменную `s2` через свойство, переменная `s2` по прежнему будет действительной строкой `String` после применения действия.

Во-вторых, как можно видеть в ярлыке, способ `add` забирает во владение `self`, потому что  `self` *не имеет* ссылку `&`. Это означает, что переменная `s1` в приложении 8-18 во время вызова способа `add` передана ему во владение и более не будет действительна после вызова способа `add`. Не смотря на то, что рукопись `let s3 = s1 + &s2;` выглядит как будто она лишь объединяет обе строки и создаёт новую, этот способ в действительности забирает во владение переменную `s1`, присоединяет к ней повтор содержимого переменной `s2`, а затем возвращает итог объединения.  Другими словами, это выглядит как будто рукопись создаёт множество повторений переменных, но это не так; Данное выполнение более производительно, чем повторение переменных.

Если нужно объединить несколько строк, изложение через приказчик `+` становится громоздким:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/no-listing-01-concat-multiple-strings/src/main.rs:here}}
```

Здесь переменная `s` будет содержать `tic-tac-toe`. С множеством знаков `+` и `"` становится трудно понять, что происходит. Для более сложного соединения строк можно использовать макрос `format!`:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/no-listing-02-format/src/main.rs:here}}
```

Эта рукопись также присваивает переменной `s` значение `tic-tac-toe`. Макрос `format!` работает тем же способом, что макрос `println!`, но вместо вывода на экран возвращает вид данных `String` с содержимым. Использование объединения через макрос `format!` значительно легче читается, а также рукопись, созданная макросом `format!`, использует ссылки, а значит не забирает во владение ни одно из её переменных.

### Упорядочивание в строках

Доступ к отдельным знакам в строке, при помощи ссылки на них по порядковому указателю, является допустимым и распространённым действием во многих других языках программирования. Тем не менее, если вы попытаетесь получить доступ к частям вида данных `String`, используя правила написания упорядочивания в Ржавчине, то вы получите ошибку. Рассмотрим неверную рукопись в приложении 8-19.

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-19/src/main.rs:here}}
```

<span class="caption">Приложение 8-19: Попытка использовать получения значения из строки через порядковый указатель</span>

Эта рукопись приведёт к следующей ошибке:

```console
{{#include ../listings/ch08-common-collections/listing-08-19/output.txt}}
```

Ошибка и примечание разъясняет, что в Ржавчине строки не поддерживают упорядочивание. Но почему так? Чтобы ответить на этот вопрос, нужно обсудить то, как в Ржавчине представлены строки в памяти.

#### Внутреннее представление

Вид данных `String` является оболочкой над видом данных  `Vec<u8>`. Давайте посмотрим на несколько закодированных правильным образом в UTF-8 строк из примера приложения 8-14. Начнём с этой:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:spanish}}
```

В этом случае `len` будет 4, что означает вектор, хранит строку "Hola" длиной 4 байта. Каждая из этих букв занимает 1 байт при преобразовании в UTF-8. Но как насчёт следующей строки? (Обратите внимание, что эта строка начинается с заглавной кириллической "З", а не цифры 3.)

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:russian}}
```

Отвечая на вопрос, какова длина строки, вы можете ответить 12. Однако ответ Ржавчины - 24, что равно числу байт, необходимых для преобразования «Здравствуйте» в UTF-8, так происходит, потому что один знак UTF-8 в этой строке занимает 2 байта памяти. Следовательно, порядковый указатель в данном случае не применим. Так как 1 знак в строке в представлении UTF-8 не всегда будет соответствовать 1 байту в памяти. Для отображения рассмотрим эту недопустимую рукопись в Ржавчине:

```rust,ignore,does_not_compile
let hello = "Здравствуйте";
let answer = &hello[0];
```

Каким должно быть значение переменной `answer`? Должно ли оно быть значением первой буквы `З`? При представлении в UTF-8, первый байт значения `З` равен значению `208`, а второй - значению `151`, поэтому содержимое в переменной `answer` на самом деле должно быть значение `208`, но само по себе значение `208` не является действительным знаком в представлении UTF-8. Значение `208`, скорее всего не то, что хотел бы получить пользователь: ведь он ожидает первую букву (знак) этой строки; тем не менее, это единственный байт данных, который в Ржавчине доступен по порядковому указателю 0. Пользователи обычно не хотят получить значение байта, даже если строка содержит только латинские буквы: если `&"hello"[0] `была бы допустимой рукописью, которая вернула значение байта, то она вернула бы значение `104`, а не знак `h`.

Таким образом, чтобы предотвратить возврат непредвиденного значения, вызывающего ошибки, которые не могут быть сразу обнаружены, Ржавчина просто не собирает такую рукопись и предотвращает недопонимание на ранних этапах этапа разработки.

#### Байты, одиночные значения и кластеры графем! Боже мой!

Ещё одна особенность, касающаяся UTF-8, заключается в том, что на самом деле существует три способа рассмотрения строк с точки зрения Ржавчины: как байты, как одиночные значения и как кластеры графем (самая близкая вещь к тому, что мы назвали бы *буквами*).

Если посмотреть на слово языка хинди «नमस्ते», написанное в транскрипции Devanagari, то оно хранится как вектор значений в виде данных `u8`, который выглядит следующим образом:

```text
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
```

Эти 18 байт являются именно тем, как компьютеры в конечном итоге сохранят в памяти эту строку. Если мы посмотрим на 18 байт как на одиночные UTF-8 значения, которые являются в Ржавчине видом данных `char`, то байты будут выглядеть так:

```text
['न', 'म', 'स', '्', 'त', 'े']
```

Здесь есть шесть значений вида данных `char`, но четвёртый и шестой являются не буквами: они диакритики, особые обозначения, которые не имеют смысла сами по себе. Наконец, если мы посмотрим на байты как на кластеры графем, то получим то, что человек назвал бы словом на хинди состоящем из четырёх букв:

```text
["न", "म", "स्", "ते"]
```

Ржавчина предоставляет различные способы преобразования необработанных строковых данных, которые компьютеры хранят так, чтобы каждой программе можно было выбрать необходимое преобразование, независимо от того, на каком человеческом языке представлены эти данные.

Последняя причина, по которой Ржавчина не позволяет нам упорядочивать вид данных `String` для получения знаков является то, что программисты ожидают, что действия упорядочивания всегда имеют постоянное время (O(1)) выполнения. Но невозможно обеспечить такую производительность для вида данных `String`, потому что Ржавчине понадобилось бы пройтись по содержимому от начала до заданного порядкового указателя, чтобы определить, сколько строка содержит действительных знаков.

### Срезы строк

Упорядочивание строк часто является плохой мыслью, потому что не ясно каким должен быть возвращаемый вид данных такого действия: байтовым значением, знаком, кластером графем или срезом строки. Поэтому Ржавчина просит вас быть более определенным, если действительно требуется использовать порядковые указатели для создания срезов строк.

Вместо упорядочивания с помощью числового порядкового указателя `[]`, вы можете использовать приказчик ряда`[]`. При создании среза строки через способ ряда, необходимо указать на то, срез каких байтов надо делать:

```rust
let hello = "Здравствуйте";

let s = &hello[0..4];
```

Здесь переменная `s` будет вида данных - среза строки `&str`, который содержит первые 4 байта строки. Ранее мы упоминали, что каждый из этих знаков был по 2 байта, что означает, что строка `s` будет содержать <!-- yaspeller ignore:start -->"Зд"<!-- yaspeller ignore:end -->.

Что бы произошло, если бы мы использовали `&hello[0..1]`? Ответ: Ржавчина бы вызвала сбой во время выполнения точно так же, как если бы обращались к недействительному порядковому указателю в векторе:

```console
{{#include ../listings/ch08-common-collections/output-only-01-not-char-boundary/output.txt}}
```

Вы должны использовать ряды для создания срезов строк с осторожностью, потому что это может привести к сбою вашей программы.

### Способы для перебора строк

Лучший способ работать со срезами строк — чётко указать, нужны ли вам знаки или байты. Для отдельных одиночных значений в UTF-8 используйте способ `chars`. Вызов `chars` у <!-- yaspeller ignore:start -->"Зд"<!-- yaspeller ignore:end --> выделяет и возвращает два значения вида данных `char`, вы можете использовать способ `.chars` для получения каждого знака по отдельности в круговороте `for`:

```rust
for c in "Зд".chars() {
    println!("{c}");
}
```

Рукопись выведет следующее:

```text
З
д
```

Способ `bytes` возвращает каждый байт, который может быть подходящим в другой предметной области:

```rust
for b in "Зд".bytes() {
    println!("{b}");
}
```

Эта рукопись выведет четыре байта, составляющих эту строку:

```text
208
151
208
180
```

Но делая так, обязательно помните, что один знак UTF-8 может состоять более чем из одного байта памяти.

Извлечение кластеров графем из строк, как в случае с языком хинди, является сложным, поэтому эта возможность не предусмотрена встроенной библиотекой. На [crates.io](https://crates.io/)<!-- ignore --> есть доступные библиотеки, если Вам нужны данные возможности.

### Строки не так просты

Подводя итог, становится ясно, что строки сложны. Различные языки программирования предоставляют различные приемы того, как представить решить тот или иной вопрос программисту. В Ржавчине решили принять свод правил обработки  вида данных `String` поведением по умолчанию для всех программ Ржавчины, что означает, что программисты должны заранее продумать обработку данных UTF-8. Это решение раскрывает большую сложность при использовании строк `String` и `str`, чем в других языках программирования, но это предотвращает от необходимости обрабатывать ошибки, связанные с не-ASCII знаками, которые могут появиться в ходе разработки позже.

Хорошая новость состоит в том, что обычная библиотека предлагает множество полезных возможностей, построенных на основе видов данных `String` и `&str`, чтобы помочь правильно обрабатывать эти сложные случаи. Обязательно ознакомьтесь с подробным пособием для использования способов, таких как `contains` - для поиска в строке и `replace` - для замены частей строки другой строкой.

Давайте переключимся на что-то немного менее сложное: HashMap!
