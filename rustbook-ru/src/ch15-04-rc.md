## `Rc<T>`, умный указатель с подсчётом ссылок

В большинстве случаев владение является однозначным: вы точно знаете, какая переменная владеет данным значением. Однако бывают случаи, когда у одного значения может быть несколько владельцев. Например, в Графовых видах данных может быть несколько рёбер, указывающих на один и тот же узел — таким образом, этот узел становится в действительности собственностью всех этих рёбер. Узел не подлежит удалению, за исключением тех случаев, когда на него не указывает ни одно ребро и, соответственно, у него нет владельцев.

Вы должны включить множественное владение явно, используя вид данных Ржавчины `Rc<T>`, которое является условным обозначением для *подсчёта ссылок*. Вид данных `Rc<T>` отслеживает количество ссылок на значение, чтобы определить, используется ли оно ещё. Если ссылок на значение нет, значение может быть очищено и при этом ни одна ссылка не станет недействительной.

Представьте себе `Rc<T>` как телевизор в гостиной. Когда один человек входит, чтобы смотреть телевизор, он включает его. Другие могут войти в комнату и посмотреть телевизор. Когда последний человек покидает комнату, он выключает телевизор, потому что он больше не используется. Если кто-то выключит телевизор во время его просмотра другими, то оставшиеся телезрители устроят шум!

Вид данных `Rc<T>` используется, когда мы хотим разместить в куче некоторые данные для чтения несколькими частями нашей программы и не можем определить во время сборки, какая из частей завершит использование данных последней. Если бы мы знали, какая часть завершит использование последней то, мы могли бы сделать эту часть владельцем данных и вступили бы в силу обычные правила владения, применяемые во время сборки.

Обратите внимание, что `Rc<T>` используется только в однопоточных задумках. Когда мы обсудим состязательность в главе 16, мы рассмотрим, как выполнять подсчёт ссылок во многопоточных программах.

### Использование `Rc<T>` для совместного использования данных

Давайте вернёмся к нашему примеру с cons списком в приложении 15-5. Напомним, что мы определили его с помощью способа `Box<T>`. В этот раз мы создадим два списка, оба из которых будут владеть третьим списком. Мировозренческо это похоже на рисунок 15-3:

 <img alt="Two lists that share ownership of a third list" src="img/trpl15-03.svg">

<span class="caption">Рисунок 15-3: Два списка, <code>b</code> и <code>c</code>, делят владение над третьим списком, <code>a</code></span>

Мы создадим список `a`, содержащий 5 и затем 10. Затем мы создадим ещё два списка: `b` начинающийся с 3 и `c` начинающийся с 4. Оба списка `b` и `c` затем продолжать первый список `a`, содержащий 5 и 10. Другими словами, оба списка будут разделять первый список, содержащий 5 и 10.

Попытка выполнить эту задумку, используя определение `List` с видом данных `Box<T>` не будет работать, как показано в приложении 15-17:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-17/src/main.rs}}
```

<span class="caption">Приложение 15-17: Отображение того, что нельзя иметь два списка, использующих <code>Box&lt;T&gt;</code>, которые пытаются совместно владеть третьим списком</span>

При сборке этой рукописи, мы получаем эту ошибку:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-17/output.txt}}
```

Исходы `Cons` владеют данными, которые они содержат, поэтому, когда мы создаём список `b`, то `a` перемещается в `b`, а `b` становится владельцем `a`. Затем, мы пытаемся использовать `a` снова при создании `c`, но нам не разрешают, потому что `a` был перемещён.

Мы могли бы изменить определение `Cons`, чтобы вместо этого хранить ссылки, но тогда нам пришлось бы указывать свойства времени жизни. Указывая свойства времени жизни, мы бы указали, что каждая переменная в списке будет жить как самое меньшее столько же, сколько и весь список. Это относится к переменным и спискам в приложении 15.17, но не во всех задумках.

Вместо этого мы изменим наше определение вида данных `List` так, чтобы использовать `Rc<T>` вместо `Box<T>`, как показано в приложении 15-18. Каждый исход `Cons` теперь будет содержать значение и вид данных `Rc<T>`, указывающий на `List`. Когда мы создадим `b` то, вместо того чтобы стал владельцем `a`, мы будем удваивать `Rc<List>` который содержит `a`, тем самым увеличивая количество ссылок с единицы до двойки и позволяя переменным `a` и `b` разделять владение на данные в виде данных `Rc<List>`. Мы также удвоим `a` при создании `c`, увеличивая количество ссылок с двух до трёх. Каждый раз, когда мы вызываем `Rc::clone`, счётчик ссылок на данные внутри `Rc<List>` будет увеличиваться и данные не будут очищены, если на них нет пустых ссылок.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-18/src/main.rs}}
```

<span class="caption">Приложение 15-18: Определение <code>List</code>, использующее <code>Rc&lt;T&gt;</code></span>

Нам нужно добавить указанию `use`, чтобы подключить вид данных `Rc<T>` в область видимости, потому что он не входит в список самостоятельного подключения встроенного набора. В `main`, мы создаём список владеющий 5 и 10, сохраняем его в новом `Rc<List>` переменной `a`. Затем при создании `b` и `c`, мы называем функцию `Rc::clone` и передаём ей ссылку на `Rc<List>` как переменная `a`.

Мы могли бы вызвать `a.clone()`, а не `Rc::clone(&a)`, но в Ржавчине принято использовать `Rc::clone` в таком случае. Внутреннее использование `Rc::clone` не делает глубокого повторения всех данных, как это происходит в видах данных большинства выполнений `clone`. Вызов `Rc::clone` только увеличивает счётчик ссылок, что не занимает много времени. Глубокое повторение данных может занимать много времени. Используя `Rc::clone` для подсчёта ссылок, можно внешне различать виды удваивания с глубоким повторением и удваивания, которые увеличивают количество ссылок. При поиске в рукописи неполадок с производительностью нужно рассмотреть только  удваивание с глубоким повторением и пренебрегать вызовы `Rc::clone` .

### Удваивание `Rc<T>` увеличивает количество ссылок

Давайте изменим рабочий пример в приложении 15-18, чтобы увидеть как изменяется число ссылок при создании и удалении ссылок на `Rc<List>` внутри переменной `a`.

В приложении 15-19 мы изменим `main` так, чтобы она имела внутреннюю область видимости вокруг списка `c`; тогда мы сможем увидеть, как меняется счётчик ссылок при выходе `c` из внутренней области видимости.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-19/src/main.rs:here}}
```

<span class="caption">Приложение 15-19: вывод количества ссылок</span>

В каждой части программы, где количество ссылок меняется, мы выводим количество ссылок, которое получаем, вызывая функцию `Rc::strong_count`. Эта функция названа `strong_count`, а не `count`, потому что вид данных `Rc<T>` также имеет `weak_count`; мы увидим, для чего используется `weak_count` в разделе <a data-md-type="raw_html" href="ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt">"Предотвращение замкнутых ссылок: Превращение `Rc<T>` в <code data-md-type="raw_html">Weak&lt;T&gt;</code>"</a><!-- ignore -->.

Рукопись выводит в окно вывода:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-19/output.txt}}
```

Можно увидеть, что `Rc<List>` в переменной `a` имеет начальный счётчик ссылок равный 1; затем каждый раз при вызове `clone` счётчик увеличивается на 1. Когда `c` выходит из области видимости, счётчик уменьшается на 1. Нам не нужно вызывать функцию уменьшения счётчика ссылок, как при вызове `Rc::clone` для увеличения счётчика ссылок: использование `Drop` самостоятельно уменьшает счётчик ссылок, когда значение `Rc<T>` выходит из области видимости.

В этом примере мы не наблюдаем того, что когда `b`, а затем `a` выходят из области видимости в конце `main`, счётчик становится равным 0, и `Rc<List>` полностью очищается. Использование `Rc<T>` позволяет одному значению иметь несколько владельцев, а счётчик заверяет, что значение остаётся действительным до тех пор, пока любой из владельцев ещё существует.

С помощью неизменяемых ссылок, вид данных `Rc<T>` позволяет обмениваться данными между несколькими частями вашей программы только для чтения данных. Если вид данных `Rc<T>` позволял бы иметь несколько изменяемых ссылок, вы могли бы нарушить одно из правил заимствования, описанных в главе 4: множественные изменяемые заимствования в одном и том же месте могут вызвать гонки данных (data races) и несогласованность данных. Но возможность изменять данные очень полезна! В следующем разделе мы обсудим образец данных внутренней изменчивости и вид данных `RefCell<T>`, который можно использовать вместе с `Rc<T>` для работы с этим ограничением.


