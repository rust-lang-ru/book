## Функции

Функции широко распространены в рукописи Ржавчины. Вы уже познакомились с одной из самых важных функций в языке: функцией `main`, которая является точкой входа большинства программ. Вы также видели ключевое слово `fn`, позволяющее объявлять новые функции.

Рукопись Ржавчины использует *змеиный регистр (snake case)* как основное исполнение для имён функций и переменных, в котором все буквы строчные, а знак подчёркивания разделяет слова. Вот программа, содержащая пример определения функции:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-16-functions/src/main.rs}}
```

Для определения функции в Ржавчине необходимо указать `fn`, за которым следует имя функции и набор круглых скобок. Узорчатые скобки указывают сборщику, где начинается и заканчивается тело функции.

Мы можем вызвать любую функцию, которую мы определили ранее, введя её имя и набор скобок следом. Поскольку в программе определена `another_function`, её можно вызвать из функции `main`. Обратите внимание, что `another_function` определена *после* функции `main` в исходной рукописи; мы могли бы определить её и раньше. Ржавчине не важно, где вы определяете свои функции, главное, чтобы они были определены где-то в той области видимости, которую может видеть вызывающая их рукопись.

Создадим новое двоичное дело с названием *functions* для дальнейшего изучения функций. Поместите пример `another_function` в файл *src/main.rs* и запустите его. Вы должны увидеть следующий вывод:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-16-functions/output.txt}}
```

Строки выполняются в том порядке, в котором они расположены в функции `main`. Сначала выводится сообщение "Hello, world!", а затем вызывается `another_function`, которая также выводит сообщение.

### Свойства функции

Мы можем определить функции, имеющие *свойства*, которые представляют собой особые переменные, являющиеся частью ярлыков функции. Когда у функции есть свойства, необходимо предоставить ей определенные значения этих свойств. Технически определенные значения называются *переменные*, но в повседневном общении люди обычно используют слова *свойство* и *переменная* как взаимозаменяемые либо для переменных в определении функции, либо для определенных значений, передаваемых при вызове функции.

В этом исполнении `another_function` мы добавляем свойство:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-17-functions-with-parameters/src/main.rs}}
```

Попробуйте запустить эту программу. Должны получить следующий итог:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-17-functions-with-parameters/output.txt}}
```

Объявление `another_function` содержит одно свойство с именем `x`. Вид данных `x` задан как `i32`. Когда мы передаём `5` в `another_function`, макрос `println!` помещает `5` на место пары узорчатых скобок, содержащих `x` в строке вида данных.

В описании самих функций вы *обязаны* указывать вид данных каждого свойства. Это принятое решение согласно свода правил Ржавчины: требование указаний видов данных в определениях функций позволяет сборщику в дальнейшем избежать необходимости использовать их в других местах рукописи, чтобы определить, какой вид данных вы имеете в виду. Сборщик также может выдавать более полезные сообщения об ошибках, если он знает, какие виды данных ожидает функция.

При определении нескольких свойств, разделяйте объявления свойств запятыми, как показано ниже:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-18-functions-with-multiple-parameters/src/main.rs}}
```

Этот пример создаёт функцию под именем `print_labeled_measurement` с двумя свойствами. Первый свойство называется `value` с видом данных `i32`. Второе свойство называется `unit_label` и имеет вид данных `char`. Затем функция выводит `value` и `unit_label`.

Попробуем запустить эту рукопись. Замените текущую программу дела *functions* в файле *src/main.rs* на предыдущий пример и запустите его с помощью `cargo run`:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-18-functions-with-multiple-parameters/output.txt}}
```

Поскольку мы вызвали функцию с `5` в качестве значения для `value` и `'h'` в качестве значения для `unit_label`, вывод программы содержит эти значения.

### Указания и выражения

Тела функций состоят из ряда указаний, необязательно заканчивающихся выражением. До сих пор функции, которые мы рассматривали, не включали завершающее выражение, но вы видели выражение как часть указания. Поскольку Ржавчина является языком, основанным на выражениях, это важное различие необходимо понимать. В других языках таких различий нет, поэтому давайте рассмотрим, что такое указания и выражения, и как их различия влияют на тела функций.

- **Указания** выполняют какое-либо действие и не возвращают значения.
- **Выражения** вычисляются до итогового значения. Давайте рассмотрим несколько примеров.

На самом деле мы уже использовали указания и выражения. Создание переменной и присвоение ей значения с помощью ключевого слова `let` является приказчиком. В Приложении 3-1, `let y = 6;` — это указание.

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/listing-03-01/src/main.rs}}
```

<span class="caption">Приложение 3-1: Объявление функции <code>main</code>, содержащей одно указание</span>

Определения функций также являются указанием. Весь предыдущий пример сам по себе является указанием.

Указания не возвращают значения. Следовательно вы не можете присвоить `let` указанию другой переменной, как это пытается сделать следующую рукопись. Вы получите ошибку:

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-19-statements-vs-expressions/src/main.rs}}
```

Если вы запустите эту программу, то ошибка будет выглядеть так:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-19-statements-vs-expressions/output.txt}}
```

Указание `let y = 6` не возвращает значение, поэтому не с чем связать переменную `x`. Это отличается от поведения в других языках, таких как C и Ruby, где присваивание возвращает присвоенное значение. В таких языках можно писать рукопись `x = y = 6` и обе переменные `x` и `y` будут иметь значение `6`. Но в Ржавчине не так.

Выражения вычисляют значение и составляют большую часть остальной рукописи, которую вы напишите на Ржавчине. Рассмотрим математическое действие, к примеру `5 + 6`, которое является выражением, вычисляющим значение `11`. Выражения могут быть частью указаний: в приложении 3-1 `6` в указании `let y = 6;` является выражением, которое вычисляется в значение `6`. Вызов функции — это выражение. Вызов макроса — это выражение. Новый раздел области видимости, созданный с помощью узорчатых скобок, представляет собой выражение, например:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-20-blocks-are-expressions/src/main.rs}}
```

Это выражение:

```rust,ignore
{
    let x = 3;
    x + 1
}
```

это раздел, который в данном случае вычисляется в значение `4`. Это значение связывается с `y` как часть указания `let`. Обратите внимание, что строка `x + 1` не имеет точки с запятой в конце, что отличается от большинства строк, которые вы видели до сих пор. Выражения не содержат завершающих точек с запятой. Если вы добавите точку с запятой в конец выражения, вы превратите его в указание, и тогда оно не будет возвращать значение. Помните об этом, когда будете изучать возвращаемые значения функций и выражения.

### Функции с возвращаемыми значениями

Функции могут возвращать значения рукописи, которая их вызывает. Мы не называем возвращаемые значения, но мы должны объявить их вид данных после стрелки ( `->` ). В Ржавчине возвращаемое значение функции является родственным значения конечного выражения в разделе тела функции. Вы можете раньше выйти из функции и вернуть значение, используя ключевое слово `return` и указав значение, но большинство функций неявно возвращают последнее выражение. Вот пример такой функции:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-21-function-return-values/src/main.rs}}
```

В рукописи функции `five` нет вызовов функций, макросов или даже указаний  `let` — есть только одно число `5`. Это является безусловно правильной функцией в Ржавчине. Заметьте, что возвращаемый вид данных у данной функции определён как `-> i32`. Попробуйте запустить эту рукопись. Вывод будет таким:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-21-function-return-values/output.txt}}
```

Значение `5` в `five` является возвращаемым функцией значением, поэтому возвращаемый вид данных - `i32`. Рассмотрим пример более подробно. Здесь есть две важных особенности: во-первых, строка `let x = five();` показывает использование возвращаемого функцией значения для объявления переменной. Так как функция `five` возвращает `5`, то эта строка равнозначна следующей:

```rust
let x = 5;
```

Во-вторых, у функции `five` нет свойств и определён вид данных возвращаемого значения, но тело функции представляет собой одинокую `5` без точки с запятой, потому что это выражение, значение которого мы хотим вернуть.

Рассмотрим другой пример:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-22-function-parameter-and-return/src/main.rs}}
```

Запуск рукописи выведет `The value of x is: 6`. Но если поставить точку с запятой в конце строки, содержащей `x + 1`, превратив её из выражения в указание, мы получим ошибку:

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-23-statements-dont-return-values/src/main.rs}}
```

Сборка данной рукописи вызывает следующую ошибку:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-23-statements-dont-return-values/output.txt}}
```

Основное сообщение об ошибке, `несовпадение видов данных`, раскрывает ключевую неполадку этой рукописи. Определение функции `plus_one` сообщает, что будет возвращено `i32`, но указания не вычисляются в значение, что и выражается единичным видом данных `()`. Следовательно, ничего не возвращается, что противоречит определению функции и приводит к ошибке. В этом выводе Ржавчина выдаёт сообщение, которое, возможно, поможет исправить эту неполадку: он предлагает удалить точку с запятой для устранения ошибки.
