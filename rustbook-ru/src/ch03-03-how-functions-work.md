## Способа (функции)

Способы (функции) широко распространены в рукописи Ржавчины. Вы уже познакомились с одной из самых важных способов (функций) в языке: функцией `main`, которая является точкой входа большинства программ. Вы также видели ключевое слово `fn`, позволяющее объявлять новые способы (функции).

Рукопись Ржавчины использует *змеиный регистр (snake case)* как основное исполнение для имён способов (функций) и переменных, в котором все буквы строчные, а знак подчёркивания разделяет слова. Вот приложение, содержащая пример определения способа (функции):

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-16-functions/src/main.rs}}
```

Для определения способа (функции) в Ржавчине необходимо указать `fn`, за которым следует имя способа (функции) и набор круглых скобок. Узорчатые скобки указывают сборщику, где начинается и заканчивается тело способа (функции).

Мы можем вызвать любую способ (функцию), которую мы определили ранее, введя её имя и набор скобок следом. Поскольку в программе определена `another_function`, её можно вызвать из способа (функции) `main`. Обратите внимание, что `another_function` определена *после* способа (функции) `main` в исходной рукописи; мы могли бы определить её и раньше. Ржавчине не важно, где вы определяете свои способы (функции), главное, чтобы они были определены где-то в той области видимости, которую может видеть вызывающая их рукопись.

Создадим новое исполняемый ящик с названием *functions* для дальнейшего изучения способов (функций). Поместите пример `another_function` в файл *src/main.rs* и запустите его. Вы должны увидеть следующий вывод:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-16-functions/output.txt}}
```

Строки выполняются в том порядке, в котором они расположены в способе (функции) `main`. Сначала выводится сообщение "Здравствуй мир!", а затем вызывается `another_function`, которая также выводит сообщение.

### Свойства способа (функции)

Мы можем определить способы (функции), имеющие *свойства*, которые представляют собой особые переменные, являющиеся частью ярлыков способа (функции). Когда у способа (функции) есть свойства, необходимо предоставить ей определенные значения этих свойств. Технически определенные значения называются *переменные*, но в повседневном общении люди обычно используют слова *свойство* и *переменная* как взаимозаменяемые либо для переменных в определении способе (функции), либо для определенных значений, передаваемых при вызове способа (функции).

В этом исполнении `another_function` мы добавляем свойство:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-17-functions-with-parameters/src/main.rs}}
```

Попробуйте запустить эту программу. Должны получить следующий итог:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-17-functions-with-parameters/output.txt}}
```

Объявление `another_function` содержит одну переменную с именем `x`. Вид данных `x` задан как `i32`. Когда мы передаём `5` в `another_function`, макрос `println!` помещает `5` на место пары узорчатых скобок, содержащих `x` в строке вида данных.

В описании самих способов (функций) вы *обязаны* указывать вид данных каждого свойства. Это принятое решение согласно свода правил Ржавчины: требование указаний видов данных в определениях способов (функций) позволяет сборщику в дальнейшем избежать необходимости использовать их в других местах рукописи, чтобы определить, какой вид данных вы имеете в виду. Сборщик также может выдавать более полезные сообщения об ошибках, если он знает, какие виды данных ожидает способ (функция).

При определении нескольких свойств, разделяйте объявления свойств запятыми, как показано ниже:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-18-functions-with-multiple-parameters/src/main.rs}}
```

Этот пример создаёт способ (функцию) под именем `print_labeled_measurement` с двумя свойствами. Первый свойство называется `значение` с видом данных `i32`. Второе свойство называется `unit_label` и имеет вид данных `char`. Затем способ (функция) выводит `значение` и `unit_label`.

Попробуем запустить эту рукопись. Замените текущую программу приложения *functions* в файле *src/main.rs* на предыдущий пример и запустите его с помощью `cargo run`:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-18-functions-with-multiple-parameters/output.txt}}
```

Поскольку мы вызвали способ (функцию) с `5` в качестве значения для `значение` и `'h'` в качестве значения для `unit_label`, вывод приложения содержит эти значения.

### Указания и выражения

Тела способов (функций) состоят из ряда указаний, необязательно заканчивающихся выражением. До сих пор способы (функции), которые мы рассматривали, не включали завершающее выражение, но вы видели выражение как часть указания. Поскольку Ржавчина является языком, основанным на выражениях, это важное различие необходимо понимать. В других языках таких различий нет, поэтому давайте рассмотрим, что такое указания и выражения, и как их различия влияют на тела способов (функций).

- **Указания** выполняют какое-либо действие и не возвращают значения.
- **Выражения** вычисляются до итогового значения. Давайте рассмотрим несколько примеров.

На самом деле мы уже использовали указания и выражения. Создание переменной и присвоение ей значения с помощью ключевого слова `let` является приказчиком. В Приложении 3-1, `let y = 6;` — это указание.

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/listing-03-01/src/main.rs}}
```

<span class="caption">Приложение 3-1: Объявление способа (функции) <code>main</code>, содержащей одно указание</span>

Определения способов (функций) также являются указанием. Весь предыдущий пример сам по себе является указанием.

Указания не возвращают значения. Следовательно вы не можете присвоить `let` указанию другой переменной, как это пытается сделать следующую рукопись. Вы получите ошибку:

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-19-statements-vs-expressions/src/main.rs}}
```

Если вы запустите эту программу, то ошибка будет выглядеть так:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-19-statements-vs-expressions/output.txt}}
```

Указание `let y = 6` не возвращает значение, поэтому не с чем связать переменную `x`. Это отличается от поведения в других языках, таких как C и Ruby, где присваивание возвращает присвоенное значение. В таких языках можно писать рукопись `x = y = 6` и обе переменные `x` и `y` будут иметь значение `6`. Но в Ржавчине не так.

Выражения вычисляют значение и составляют большую часть остальной рукописи, которую вы напишите на Ржавчине. Рассмотрим математическое действие, к примеру `5 + 6`, которое является выражением, вычисляющим значение `11`. Выражения могут быть частью указаний: в приложении 3-1 `6` в указании `let y = 6;` является выражением, которое вычисляется в значение `6`. Вызов способа (функции) — это выражение. Вызов макроса — это выражение. Новый раздел области видимости, созданный с помощью узорчатых скобок, представляет собой выражение, например:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-20-blocks-are-expressions/src/main.rs}}
```

Это выражение:

```rust,ignore
{
    let x = 3;
    x + 1
}
```

это раздел, который в данном случае вычисляется в значение `4`. Это значение связывается с `y` как часть указания `let`. Обратите внимание, что строка `x + 1` не имеет точки с запятой в конце, что отличается от большинства строк, которые вы видели до сих пор. Выражения не содержат завершающих точек с запятой. Если вы добавите точку с запятой в конец выражения, вы превратите его в указание, и тогда оно не будет возвращать значение. Помните об этом, когда будете изучать возвращаемые значения способов (функций) и выражения.

### Способы (функции) с возвращаемыми значениями

Способы (функции) могут возвращать значения рукописи, которая их вызывает. Мы не называем возвращаемые значения, но мы должны объявить их вид данных после стрелки ( `->` ). В Ржавчине возвращаемое значение способа (функции) является родственным значения конечного выражения в разделе тела способа (функции). Вы можете раньше выйти из способа (функции) и вернуть значение, используя ключевое слово `return` и указав значение, но большинство способов (функций) неявно возвращают последнее выражение. Вот пример такого способа (функции):

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-21-function-return-values/src/main.rs}}
```

В рукописи способа (функции) `пять` нет вызовов способов (функций), макросов или даже указаний  `let` — есть только одно Число `5`. Это является безусловно правильной функцией в Ржавчине. Заметьте, что возвращаемый вид данных у данного способа (функции) определён как `-> i32`. Попробуйте запустить эту рукопись. Вывод будет таким:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-21-function-return-values/output.txt}}
```

Значение `5` в `пять` является возвращаемым функцией значением, поэтому возвращаемый вид данных - `i32`. Рассмотрим пример более подробно. Здесь есть две важных особенности: во-первых, строка `let x = пять();` показывает использование возвращаемого функцией значения для объявления переменной. Так как способ (функция) `пять` возвращает `5`, то эта строка равнозначна следующей:

```rust
let x = 5;
```

Во-вторых, у способа (функции) `пять` нет свойств и определён вид данных возвращаемого значения, но тело способа (функции) представляет собой одинокую `5` без точки с запятой, потому что это выражение, значение которого мы хотим вернуть.

Рассмотрим другой пример:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-22-function-parameter-and-return/src/main.rs}}
```

Запуск рукописи выведет `Значение переменной x: 6`. Но если поставить точку с запятой в конце строки, содержащей `x + 1`, превратив её из выражения в указание, мы получим ошибку:

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-23-statements-dont-return-values/src/main.rs}}
```

Сборка данной рукописи вызывает следующую ошибку:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-23-statements-dont-return-values/output.txt}}
```

Основное сообщение об ошибке, `несовпадение видов данных`, раскрывает ключевую неполадку этой рукописи. Определение способа (функции) `увеличить_на_единицу` сообщает, что будет возвращено `i32`, но указания не вычисляются в значение, что и выражается единичным видом данных `()`. Следовательно, ничего не возвращается, что противоречит определению способа (функции) и приводит к ошибке. В этом выводе Ржавчина выдаёт сообщение, которое, возможно, поможет исправить эту неполадку: он предлагает удалить точку с запятой для устранения ошибки.
