## Привет, Cargo!

Cargo - это средство сборки и управленец дополнений Ржавчины. Большая часть разработчиков используют данное средство для управления делами, потому что Cargo использует за вас множество задач, таких как сборка рукописи, загрузка библиотек, от которых зависит ваша рукопись, и создание этих библиотек. (Мы называем библиотеки, которые нужны вашей рукописи, *дополнениями*.)

Самые простые программы на Ржавчине, подобные той, которую мы написали, не имеют никаких дополнений. Если бы мы сделали дело «Hello, world!» с Cargo, он бы использовал только ту часть Cargo, которая отвечает за сборку вашей рукописи. По мере написания более сложных программ на Ржавчине вы будете добавлять дополнения, а если вы начнёте дело с использованием Cargo, добавлять дополнения станет намного проще.

Поскольку значительное число дел, написанных на языке Ржавчина используют Cargo, оставшаяся часть книги подразумевает, что вы тоже используете Cargo. Cargo входит в состав поставки Ржавчины если вы скачали установочный набор напрямую от разрабочиков, рассмотрен в разделе ["Установка"]<!-- ignore -->. Если вы установили Ржавчину другим способом, проверьте, установлен ли Cargo, введя в окне вызова следующее:

```console
$ cargo --version
```

Если приказ выдал номер исполнения, то значит Cargo установлен. Если вы видите ошибку, вроде `command not found` ("приказ не найден"), загляните в пособие для использованного вами способа установки, чтобы выполнить установку Cargo отдельно.

### Создание своего дела с помощью Cargo

Давайте создадим новое дело с помощью Cargo и посмотрим, как оно отличается от нашего начального дела "Hello, world!". Перейдите обратно в папку *projects* (или любую другую, где вы решили сохранять рукопись). Затем, в любой операционной системе, запустите приказ:

```console
$ cargo new hello_cargo
$ cd hello_cargo
```

Первый приказ создаёт новую папку и дело с именем *hello_cargo*. Мы назвали наше дело  *hello_cargo*, и Cargo создаёт свои файлы в папке с тем же именем.

Перейдём в папку *hello_cargo* и посмотрим файлы. Увидим, что Cargo создал два файла и одну папку: файл  *Cargo.toml* и папка *src* с файлом *main.rs* внутри.

Кроме того, cargo объявил новое хранилище Git вместе с файлом *.gitignore*. Файлы Git не будут созданы, если вы запустите `cargo new` в существующем хранилище Git; вы можете изменить это поведение, используя `cargo new --vcs=git`.

> Примечание. Git — это распространённое средство управления исполнениями. Вы можете изменить `cargo new`, чтобы использовать другую систему управления исполнений или не использовать систему управления исполнений, используя клеймо `--vcs`. Запустите `cargo new --help`, чтобы увидеть доступные свойства.

Откройте файл *Cargo.toml* в любом письменном редакторе. Он должен выглядеть как рукопись в приложении 1-2.

<span class="filename">Файл: Cargo.toml</span>

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
```

<span class="caption">Приложение 1-2: Содержимое файла <em>Cargo.toml</em>, созданное приказом <code>cargo new</code></span>

Это файл в виде[*TOML*](https://github.com/toml-lang/toml)<!--  --> (*Tom’s Obvious, Minimal Language*), который является видом настроек Cargo.

Первая строка, `[package]`, является заголовочным разделом, которая указывает что следующие указания настраивают дополнение. По мере добавления больше сведений в данный файл, будет добавляться больше разделов и указаний (строк).

Следующие три строки задают сведения о настройке, необходимую Cargo для сборки вашей программы: имя, исполнение и издание Ржавчина, который будет использоваться. Мы поговорим о ключе `edition` в [Приложении E]<!-- ignore -->.

Последняя строка, `[dependencies]` является началом раздела для списка любых дополнений вашего дела. В Ржавчине, это внешние дополнения рукописи, на которые ссылаются ключевым словом *crate*. Нам не нужны никакие дополнения в данном деле, но мы будем использовать их в первом деле Главы 2, так что нам пригодится данный раздел дополнений потом.

Откройте файл *src/main.rs* и загляните в него:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    println!("Hello, world!");
}
```

Cargo создал для вас программу "Hello, world!", подобную той, которую мы написали в Приложении 1-1! Пока что различия между нашим предыдущим делом и делом, созданным при помощи Cargo, заключаются в том, что Cargo поместил исходную рукопись в папку *src*, и у нас есть настроечный файл *Cargo.toml* в верхней папке дела.

Cargo ожидает, что ваши исходные файлы находятся внутри папки *src*. Папка верхнего уровня дела предназначена только для файлов README, сведений о лицензии, файлы настроек и чего то ещё не относящего к вашей рукописи. Использование Cargo помогает создавать дело. Есть место для всего и все находится на своём месте.

Если вы создали дело без использования Cargo, как мы делали для "Hello, world!" дела, то можно преобразовывать его в дело с использованием Cargo. Один из простых способов получить этот файл *Cargo.toml* — запустить `cargo init`, который автоматически его создаст.

### Сборка и запуск дела через Cargo

Посмотрим, в чем разница при сборке и запуске программы "Hello, world!" с помощью Cargo. В папке *hello_cargo* соберите дело следующим приказом:

```console
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```

Этот приказ создаёт исполняемый файл в *target/debug/hello_cargo* (или *target\debug\hello_cargo.exe* в Windows), а не в вашем текущем папке. Поскольку обычная сборка является отладочной, Cargo помещает двоичный файл в папке с именем *debug*. Вы можете запустить исполняемый файл с помощью этого приказа:

```console
$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
```

Если все хорошо, то `Hello, world!` выводится в окне вызова. Запуск приказа `cargo build` в первый раз также приводит к созданию нового файла *Cargo.lock* в папке верхнего уровня. Данный файл хранит сведения о используемых дополнений вашего дела. Так как у нас нет дополнений, то файл пустой. Вы никогда не должны менять этот файл вручную: Cargo сам управляет его содержимым за вас.

Только что мы собрали дело приказом `cargo build` и запустили его из `./target/debug/hello_cargo`. Но мы также можем при помощи приказа `cargo run` сразу и собрать рукопись, и затем запустить полученный исполняемый файл всего лишь одним приказом:

```console
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```


Использование `cargo run` более удобно, чем необходимость помнить и запускать `cargo build`, а затем использовать весь путь к двоичному файлу, поэтому большинство разработчиков используют `cargo run`.

Обратите внимание, что на этот раз мы не видели вывода, указывающего на то, что Cargo собирает `hello_cargo`. Cargo выяснил, что файлы не изменились, поэтому не стал пересобирать, а просто запустил двоичный файл. Если бы вы изменили свой исходную рукопись, Cargo пересобрал бы дело перед его запуском, и вы бы увидели этот вывод:

```console
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

Cargo также предоставляет приказ `cargo check`. Этот приказ быстро проверяет вашу рукопись, чтобы убедиться, что она собирается, но не создаёт исполняемый файл:

```console
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```

Почему вам не нужен исполняемый файл? Часто `cargo check` используется намного быстрее, чем `cargo build`, поскольку пропускает этап создания исполняемого файла. Если вы постоянно проверяете свою работу во время написания рукописи, использование `cargo check` ускорит этап уведомления вас о том, что ваше дело всё ещё собирается! Таким образом, многие Rustacean периодически запускают `cargo check`, когда пишут свои программы, чтобы убедиться, что она собирается. Затем они запускают `cargo build`, когда готовы использовать исполняемый файл.

Давайте подытожим, что мы уже узнали о Cargo:

- Мы можем создать дело с помощью `cargo new`.
- можно собирать дело, используя приказ `cargo build`,
- можно одновременно собирать и запускать дело одним приказом `cargo run`,
- можно собрать дело для проверки ошибок с помощью `cargo check`, не тратя время на создание рукописи исполняемого файла,
- cargo сохраняет итоги сборки не в папку с исходной рукописью, а в отдельную папку *target/debug*.

Дополнительным преимуществом использования Cargo является то, что его приказы одинаковы для разных операционных систем. С этой точки зрения, мы больше не будем предоставлять отдельные указания для Linux, macOS или Windows.

### Сборка конечного исполнения (Release)

Когда дело, наконец, готов к исполнению, можно использовать приказ `cargo build --release` для его сборки с переработкой. Данная приказ создаёт исполняемый файл в папке *target/release* в отличии от папки *target/debug*. Переработки делают так, что Ржавчина рукопись работает быстрее, но их включение увеличивает время сборки. По этой причине есть два отдельных профиля: один для разработки, когда нужно осуществлять сборку быстро и часто, и другой, для сборки конечной программы, которую будете отдавать пользователям, которая готова к работе и будет выполняться сверх быстро. Если вы замеряете время выполнения вашей рукописи, убедитесь, что собрали дело с переработкой `cargo build --release` и проверяете исполняемый файл из папки *target/release*.

### Cargo как Условие

В простых делах Cargo не даёт больших преимуществ по сравнению с использованием `rustc`, но он проявит себя, когда ваши программы станут более сложными. Когда программы вырастают до нескольких файлов или нуждаются в зависимостях, гораздо проще позволить Cargo согласовывать сборку.

Не смотря на то, что дело `hello_cargo` простой, теперь он  использует большую часть существующего набора средств, который вы будете повседневно использовать в вашем развитии, связанной с Ржавчиной. Когда потребуется работать над делами размещёнными в сети, вы сможете просто использовать следующую последовательность приказов для получения рукописи с помощью Git, перехода в папку дела, сборку дела:

```console
$ git clone example.org/someproject
$ cd someproject
$ cargo build
```

Для получения дополнительных сведений о Cargo ознакомьтесь с [его пособием] .

## Итоги

Теперь вы готовы начать своё Ржавчина путешествие! В данной главе вы изучили как:

- установить последнее безотказное исполнение Ржавчины, используя `rustup`,
- обновить Ржавчина до последней исполнения,
- открыть местно установленную пособие,
- написать и запустить программу вида "Hello, world!", используя напрямую сборщик `rustc`,
- создать и запустить новое дело, используя соглашения и приказы Cargo.

Это отличное время для создания более существенной программы, чтобы привыкнуть читать и писать рукопись на языке Ржавчина. Итак, в главе 2 мы построим программу для игры в угадай число. Если вы предпочитаете начать с изучения того, как работают общие подходы программирования в Ржавчине, обратитесь к главе 3, а затем вернитесь к главе 2.


["Установка"]: ch01-01-installation.html#installation
[Приложении E]: appendix-05-editions.html
[его пособием]: https://doc.rust-lang.org/cargo/