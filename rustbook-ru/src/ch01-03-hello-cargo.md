## Привет, Cargo!

Cargo - это средство сборки и управленец дополнений Ржавчины. Большая часть разработчиков используют данное средство для управления делами, потому что Cargo использует за вас множество задач, таких как сборка рукописи, загрузка библиотек, от которых зависит ваша рукопись, и создание этих библиотек. (Мы называем библиотеки, которые нужны вашей рукописи, *дополнениями*.)

Самые простые приложения на Ржавчине, подобные той, которую мы написали, не имеют никаких дополнений. Если бы мы сделали дело «Здравствуй мир!» с Cargo, он бы использовал только ту часть Cargo, которая отвечает за сборку вашей рукописи. По мере написания более сложных приложений на Ржавчине вы будете добавлять дополнения, а если вы начнёте дело с использованием Cargo, добавлять дополнения станет намного проще.

Поскольку значительное Число дел, написанных на языке Ржавчина используют Cargo, оставшаяся часть книги подразумевает, что вы тоже используете Cargo. Cargo входит в состав поставки Ржавчины если вы скачали установочный набор напрямую от разрабочиков, рассмотрен в разделе ["Установка"]<!-- ignore -->. Если вы установили Ржавчину другим способом, проверьте, установлен ли Cargo, введя в окне вызова следующее:

```console
$ cargo --version
```

Если приказ выдал номер исполнения, то значит Cargo установлен. Если вы видите ошибку, вроде `command not found` ("приказ не найден"), загляните в пособие для использованного вами способа установки, чтобы выполнить установку Cargo отдельно.

### Создание своего приложения с помощью Cargo

Давайте создадим новое дело с помощью Cargo и посмотрим, как оно отличается от нашего начального приложения "Здравствуй мир!". Перейдите обратно в папку *projects* (или любую другую, где вы решили сохранять рукопись). Затем, в любой операционной системе, запустите приказ:

```console
$ cargo new hello_cargo
$ cd hello_cargo
```

Первый приказ создаёт новую папку и дело с именем *hello_cargo*. Мы назвали наше дело  *hello_cargo*, и Cargo создаёт свои файлы в папке с тем же именем.

Перейдём в папку *hello_cargo* и посмотрим файлы. Увидим, что Cargo создал два файла и одну папку: файл  *Cargo.toml* и папка *src* с файлом *main.rs* внутри.

Кроме того, cargo объявил новое хранилище Git вместе с файлом *.gitignore*. Файлы Git не будут созданы, если вы запустите `cargo new` в существующем хранилище Git; вы можете изменить это поведение, используя `cargo new --vcs=git`.

> Примечание. Git — это распространённое средство управления исполнениями. Вы можете изменить `cargo new`, чтобы использовать другую устройство управления исполнений или не использовать устройство управления исполнений, используя клеймо `--vcs`. Запустите `cargo new --help`, чтобы увидеть доступные свойства.

Откройте файл *Cargo.toml* в любом письменном редакторе. Он должен выглядеть как рукопись в приложении 1-2.

<span class="filename">Файл: Cargo.toml</span>

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
```

<span class="caption">Приложение 1-2: Содержимое файла <em>Cargo.toml</em>, созданное приказом <code>cargo new</code></span>

Это файл в виде[*TOML*](https://github.com/toml-lang/toml)<!--  --> (*Tom’s Obvious, Minimal Language*), который является видом настроек Cargo.

Первая строка, `[package]`, является заголовочным разделом, которая указывает что следующие указания настраивают дополнение. По мере добавления больше сведений в данный файл, будет добавляться больше разделов и указаний (строк).

Следующие три строки задают сведения о настройке, необходимую Cargo для сборки вашего приложения: имя, исполнение и издание Ржавчина, который будет использоваться. Мы поговорим о ключе `edition` в [Приложении E]<!-- ignore -->.

Последняя строка, `[dependencies]` является началом раздела для списка любых дополнений вашего дела. В Ржавчине, это внешние дополнения рукописи, на которые ссылаются ключевым словом *crate*. Нам не нужны никакие дополнения в данном деле, но мы будем использовать их в первом деле Главы 2, так что нам пригодится данный раздел дополнений потом.

Откройте файл *src/main.rs* и загляните в него:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    println!("Здравствуй мир!");
}
```

Cargo создал для вас программу "Здравствуй мир!", подобную той, которую мы написали в Приложении 1-1! Пока что различия между нашим предыдущим делом и делом, созданным при помощи Cargo, заключаются в том, что Cargo поместил исходную рукопись в папку *src*, и у нас есть настроечный файл *Cargo.toml* в верхней папке дела.

Cargo ожидает, что ваши исходные файлы находятся внутри папки *src*. Папка верхнего уровня приложения предназначена только для файлов README, сведений о лицензии, файлы настроек и чего то ещё не относящего к вашей рукописи. Использование Cargo помогает создавать дело. Есть место для всего и все находится на своём месте.

Если вы создали дело без использования Cargo, как мы делали для "Здравствуй мир!" приложения, то можно преобразовывать его в дело с использованием Cargo. Один из простых способов получить этот файл *Cargo.toml* — запустить `cargo init`, который автоматически его создаст.

### Сборка и запуск приложения через Cargo

Посмотрим, в чем разница при сборке и запуске приложения "Здравствуй мир!" с помощью Cargo. В папке *hello_cargo* соберите дело следующим приказом:

```console
$ cargo build
   Сборка hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```

Этот приказ создаёт исполняемый файл в *target/debug/hello_cargo* (или *target\debug\hello_cargo.exe* в Windows), а не в вашем текущем папке. Поскольку обычная сборка является отладочной, Cargo помещает исполняемый файл в папке с именем *debug*. Вы можете запустить исполняемый файл с помощью этого приказа:

```console
$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Здравствуй мир!
```

Если все хорошо, то `Здравствуй мир!` выводится в окне вызова. Запуск приказа `cargo build` в первый раз также приводит к созданию нового файла *Cargo.lock* в папке верхнего уровня. Данный файл хранит сведения о используемых дополнений вашего дела. Так как у нас нет дополнений, то файл пустой. Вы никогда не должны менять этот файл вручную: Cargo сам управляет его содержимым за вас.

Только что мы собрали дело приказом `cargo build` и запустили его из `./target/debug/hello_cargo`. Но мы также можем при помощи приказа `cargo run` сразу и собрать рукопись, и затем запустить полученный исполняемый файл всего лишь одним приказом:

```console
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Здравствуй мир!
```


Использование `cargo run` более удобно, чем необходимость помнить и запускать `cargo build`, а затем использовать весь путь к исполняемому файлу, поэтому большинство разработчиков используют `cargo run`.

Обратите внимание, что на этот раз мы не видели вывода, указывающего на то, что Cargo собирает `здравствуй_cargo`. Cargo выяснил, что файлы не изменились, поэтому не стал пересобирать, а просто запустил исполняемый файл. Если бы вы изменили свой исходную рукопись, Cargo пересобрал бы дело перед его запуском, и вы бы увидели этот вывод:

```console
$ cargo run
   Сборка hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Здравствуй мир!
```

Cargo также предоставляет приказ `cargo check`. Этот приказ быстро проверяет вашу рукопись, чтобы убедиться, что она собирается, но не создаёт исполняемый файл:

```console
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```

Почему вам не нужен исполняемый файл? Часто `cargo check` используется намного быстрее, чем `cargo build`, поскольку пропускает этап создания исполняемого файла. Если вы постоянно проверяете свою работу во время написания рукописи, использование `cargo check` ускорит этап уведомления вас о том, что ваше дело всё ещё собирается! Таким образом, многие участники сообщества Ржавчины периодически запускают `cargo check`, когда пишут свои приложения, чтобы убедиться, что она собирается. Затем они запускают `cargo build`, когда готовы использовать исполняемый файл.

Давайте подытожим, что мы уже узнали о Cargo:

- Мы можем создать дело с помощью `cargo new`.
- можно собирать дело, используя приказ `cargo build`,
- можно одновременно собирать и запускать дело одним приказом `cargo run`,
- можно собрать дело для проверки ошибок с помощью `cargo check`, не тратя время на создание рукописи исполняемого файла,
- cargo сохраняет итоги сборки не в папку с исходной рукописью, а в отдельную папку *target/debug*.

Дополнительным преимуществом использования Cargo является то, что его приказы одинаковы для разных операционных систем. С этой точки зрения, мы больше не будем предоставлять отдельные указания для Linux, macOS или Windows.

### Сборка конечного исполнения (Release)

Когда дело, наконец, готов к исполнению, можно использовать приказ `cargo build --release` для его сборки с переработкой. Данная приказ создаёт исполняемый файл в папке *target/release* в отличии от папки *target/debug*. Переработки делают так, что Ржавчина рукопись работает быстрее, но их включение увеличивает время сборки. По этой причине есть два отдельных режима: один для разработки, когда нужно осуществлять сборку быстро и часто, и другой, для сборки конечной приложения, которую будете отдавать пользователям, которая готова к работе и будет выполняться сверх быстро. Если вы замеряете время выполнения вашей рукописи, убедитесь, что собрали дело с переработкой `cargo build --release` и проверяете исполняемый файл из папки *target/release*.

### Cargo как Условие

В простых делах Cargo не даёт больших преимуществ по сравнению с использованием `rustc`, но он проявит себя, когда ваши приложения станут более сложными. Когда приложения вырастают до нескольких файлов или нуждаются в зависимостях, гораздо проще позволить Cargo согласовывать сборку.

Не смотря на то, что дело `здравствуй_cargo` простой, теперь он  использует большую часть существующего набора средств, который вы будете повседневно использовать в вашем развитии, связанной с Ржавчиной. Когда потребуется работать над приложениями размещёнными в сети, вы сможете просто использовать следующую последовательность приказов для получения рукописи с помощью Git, перехода в папку приложения, сборку дела:

```console
$ git clone example.org/someproject
$ cd someproject
$ cargo build
```

Для получения дополнительных сведений о Cargo ознакомьтесь с [его пособием] .

## Итоги

Теперь вы готовы начать своё Ржавчина путешествие! В данной главе вы изучили как:

- установить последнее безотказное исполнение Ржавчины, используя `rustup`,
- обновить Ржавчина до последней исполнения,
- открыть своё установленную пособие,
- написать и запустить программу вида "Здравствуй мир!", используя напрямую сборщик `rustc`,
- создать и запустить новое дело, используя соглашения и приказы Cargo.

Это отличное время для создания более существенной приложения, чтобы привыкнуть читать и писать рукопись на языке Ржавчина. Итак, в главе 2 мы построим программу для игры в угадай число. Если вы предпочитаете начать с изучения того, как работают общие подходы программирования в Ржавчине, обратитесь к главе 3, а затем вернитесь к главе 2.


["Установка"]: ch01-01-installation.html#installation
[Приложении E]: appendix-05-editions.html
[его пособием]: https://doc.rust-lang.org/cargo/