## Работа с любым количеством фьючерсов

Когда мы перешли с использования двух фьючерсов на три в предыдущем разделе, нам также пришлось переключиться с использования `join` на использование `join3`. Было бы раздражающе вызывать другую способ (функцию) каждый раз, когда мы меняем количество фьючерсов, которые
хотим объединить. К счастью, у нас есть макроформа `join`, которой мы можем передать
произвольное количество аргументов. Она также обрабатывает ожидание самих фьючерсов.
Таким образом, мы могли бы переписать код из приложения 17-13, чтобы использовать `join!` вместо `join3`, как в приложении 17-14.

<Listing number="17-14" caption="Использование `join!` для ожидания нескольких будущих событий" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-14/src/main.rs:here}}
```

</Listing>

Это определенно улучшение по сравнению с заменой `join` на `join3` и `join4` и т. д.! Однако даже эта форма макроса работает только
когда мы знаем количество будущих событий заранее. В реальном Ржавчина, однако,
помещение будущих событий в коллекцию и затем ожидание завершения некоторых или
всех их будущих событий является распространенной схемой.

Чтобы проверить все будущие события в какой-то коллекции, нам нужно будет выполнить итерацию и
присоединиться ко всем_ из них. Способ (функция) `trpl::join_all` принимает любой вид,
который использует сущность `Iterator`, о которой вы узнали еще в [Триггер Iterator и способ `next`][iterator-trait]<!-- ignore --> Глава 13, так что
это кажется просто билетом. Давайте попробуем поместить наши будущие события в вектор и
заменить `join!` на `join_all`, как показано в Приложении 17-15.

<Listing  number="17-15" caption="Сохранение безымянных будущих событий в векторе и вызов `join_all`">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch17-async-await/listing-17-15/src/main.rs:here}}
```

</Listing>

К сожалению, эта рукопись не собирается. Вместо этого мы получаем такую ​​ошибку:

<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-15/
cargo build
copy just the compiler error
-->

```text
ошибка[E0308]: не соответствие видов данных
  --> src/main.rs:45:37
   |
10 |         let tx1_fut = async move {
   |                       ---------- the expected `async` block
...
24 |         let rx_fut = async {
   |                      ----- the found `async` block
...
45 |         let futures = vec![tx1_fut, rx_fut, tx_fut];
   |                                     ^^^^^^ expected `async` block, found a different `async` block
   |
   = note: expected `async` block `{async block@src/main.rs:10:23: 10:33}`
              found `async` block `{async block@src/main.rs:24:22: 24:27}`
   = note: no two async blocks, even if identical, have the same type
   = помощь: consider pinning your async block and casting it to a trait object
```

Это может быть удивительно. В конце концов, ни один из несогласованных разделов ничего не возвращает,
поэтому каждый из них создает `Future<Output = ()>`. Помните, что `Future` — это сущность,
и что сборщик создает уникальное перечисление для каждого несогласованного блока. Вы
не можете поместить две разные рукописные структуры в `Vec`, и то же правило
применяется к разным перечислениям, сгенерированным сборщиком.

Чтобы это работало, нам нужно использовать _объекты черт_, как мы делали в [«Возврат
ошибок из способы (функции) run»][dyn]<!-- ignore --> в Главе 12. (Мы подробно рассмотрим
объекты черт в Главе 18.) Использование объектов черт позволяет нам рассматривать каждое
из безымянных будущих, созданных этими видами, как один и тот же вид, потому что все
они воплощают сущность `Future`.

> Примечание: в разделе главы 8 [Использование перечисления для хранения нескольких
> значений][enum-alt]<!-- ignore --> мы обсуждали другой способ включения нескольких
> видов в `Vec`: использование перечисления для представления каждого вида, который может появиться в
> векторе. Однако здесь мы этого сделать не можем. Во-первых, у нас нет возможности назвать
> различные виды данных, поскольку они безымянны. Во-вторых, причина, по которой мы
> изначально обратились к вектору и `join_all`, заключалась в том, чтобы иметь возможность работать
> с динамической коллекцией будущих событий, где нас интересует только то,
> что они имеют одинаковый вид выходных данных.

Начнем с того, что обернем каждое будущее в `vec!` в `Box::new`, как показано в приложении 17-16.

<Listing number="17-16" caption="Использование `Box::new` для выравнивания видов будущих событий в `Vec`" file-name="src/main.rs">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch17-async-await/listing-17-16/src/main.rs:here}}
```

</Listing>

К сожалению, эта рукопись все еще не собирается. Фактически, мы получаем ту же самую базовую
ошибку, которую мы получили ранее для второго и третьего вызовов `Box::new`, а также
новые ошибки, относящиеся к черте `Unpin`. Мы вернемся к ошибкам `Unpin`
через минуту. Сначала исправим ошибки вида в вызовах `Box::new`,
явно аннотируя вид переменной `futures` (см. приложение 17-17).

<Listing number="17-17" caption="Исправление остальных ошибок несоответствия видов с помощью явного объявления вида" file-name="src/main.rs">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch17-async-await/listing-17-17/src/main.rs:here}}
```

</Listing>

Это объявление вида немного запутанное, поэтому давайте разберемся с ним:

1. Самый внутренний вид — это само будущее. Мы явно отмечаем, что выход
будущего — это разновидность единицы `()`, записывая `Future<Output = ()>`.
2. Затем мы аннотируем сущность `dyn`, чтобы отметить ее как динамическую.
3. Вся ссылка на сущность заключена в `Box`.
4. Наконец, мы явно заявляем, что `futures` — это `Vec`, содержащий эти
элементы.

Это уже имело большое значение. Теперь, когда мы запускаем сборщик, мы получаем только
ошибки, упоминающие `Unpin`. Хотя их три, их содержание
очень похоже.

<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-17
cargo build
# copy *only* the errors
# fix the paths
-->

```text
ошибка[E0277]: `dyn Future<Output = ()>` cannot be unpinned
   --> src/main.rs:49:24
    |
49  |         trpl::join_all(futures).await;
    |         -------------- ^^^^^^^ the trait `Unpin` is not implemented for `dyn Future<Output = ()>`
    |         |
    |         required by a bound introduced by this call
    |
    = note: consider using the `pin!` macro
            consider using `Box::pin` if you need to access the pinned value outside of the current scope
    = note: required for `Box<dyn Future<Output = ()>>` to implement `Future`
note: required by a bound in `join_all`
   --> file:///home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/futures-util-0.3.30/src/future/join_all.rs:105:14
    |
102 | pub fn join_all<I>(iter: I) -> JoinAll<I::Item>
    |        -------- required by a bound in this function
...
105 |     I::Item: Future,
    |              ^^^^^^ required by this bound in `join_all`

ошибка[E0277]: `dyn Future<Output = ()>` cannot be unpinned
  --> src/main.rs:49:9
   |
49 |         trpl::join_all(futures).await;
   |         ^^^^^^^^^^^^^^^^^^^^^^^ the trait `Unpin` is not implemented for `dyn Future<Output = ()>`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box<dyn Future<Output = ()>>` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --> file:///home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll<F>
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`

ошибка[E0277]: `dyn Future<Output = ()>` cannot be unpinned
  --> src/main.rs:49:33
   |
49 |         trpl::join_all(futures).await;
   |                                 ^^^^^ the trait `Unpin` is not implemented for `dyn Future<Output = ()>`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box<dyn Future<Output = ()>>` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --> file:///home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll<F>
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`

Для получения более подробных сведений об этом ошибке, попробуйте выполнить `rustc --explain E0277`.
ошибка: не могу собрать исходную рукопись в приложение `async_await` (bin "async_await") due to 3 предыдущая ошибкаs
```

Это _много_ для усвоения, поэтому давайте разберем это. Первая часть сообщения
сообщает нам, что первый несогласованный раздел (`src/main.rs:8:23: 20:10`) не
использует сущность `Unpin` и предлагает использовать `pin!` или `Box::pin` для ее
решения. Позже в этой главе мы рассмотрим еще несколько деталей о `Pin` и
`Unpin`. Однако на данный момент мы можем просто следовать совету сборщика, чтобы
выйти из застревания. В приложении 17-18 мы начинаем с импорта `Pin` из `std::pin`. Затем мы
обновляем аннотацию вида для `futures`, с `Pin`, обертывающим каждый `Box`.
Наконец, мы используем `Box::pin`, чтобы закрепить сами фьючерсы.

<Listing number="17-18" caption="Использование `Pin` и `Box::pin` для проверки вида `Vec`" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-18/src/main.rs:here}}
```

</Listing>

If we compile and run this, we finally get the output we hoped for:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
received 'hi'
received 'more'
received 'from'
received 'messages'
received 'the'
received 'for'
received 'future'
received 'you'
```

Уф!

Здесь есть еще кое-что для изучения. Во-первых, использование `Pin<Box<T>>` добавляет
небольшое количество накладных расходов от помещения этих будущих объектов в кучу с `Box` — и
мы делаем это только для того, чтобы выровнять виды данных. В конце концов, нам на самом деле _не нужно_ выделение кучи: эти будущие объекты являются локальными для этой конкретной способы (функции).
Как отмечалось ранее, `Pin` сам по себе является видом-оберткой, поэтому мы можем получить преимущество от
наличия одного вида в `Vec` — изначальной причины, по которой мы пришли к
`Box` — без выделения кучи. Мы можем использовать `Pin` напрямую с каждым будущим объектом, используя макрос `std::pin::pin`.

Однако мы все равно должны явно указывать вид закрепленной ссылки;
иначе Ржавчина все равно не будет знать, что их следует интерпретировать как динамические объекты-характеристики,
а это то, что нам нужно, чтобы они были в `Vec`. Поэтому мы добавляем `pin` в наш
список импорта из `std::pin`. Затем мы можем `pin!` каждый future, когда мы его определяем, и определяем `futures` как `Vec`, содержащий закрепленные изменяемые ссылки на
динамический вид future, как в приложении 17-19.

<Listing number="17-19" caption="Использование `Pin` напрямую с макросом `pin!` для избежания ненужного выделения памяти в куче" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-19/src/main.rs:here}}
```

</Listing>

Мы зашли так далеко, игнорируя то обстоятельство, что у нас могут быть разные виды данных `Output`. Например, в приложении 17-20 безымянное будущее для `a` использует `Future<Output = u32>`, безымянное будущее для `b` использует `Future<Output =
&str>`, а безымянное будущее для `c` использует `Future<Output = bool>`.

<Listing number="17-20" caption="Три варианта будущего с различными видами" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-20/src/main.rs:here}}
```

</Listing>

Мы можем использовать `trpl::join!` для их ожидания, потому что это позволяет нам передавать несколько видов будущих событий и создает кортеж этих видов. Мы _не можем_ использовать
`trpl::join_all`, потому что это требует, чтобы все переданные будущие события имели
один и тот же вид. Помните, эта ошибка заставила нас начать это приключение с
`Pin`!

Это фундаментальный компромисс: мы можем либо иметь дело с динамическим числом
будущих событий с `join_all`, пока они все имеют один и тот же вид, либо мы можем иметь дело с заданным числом будущих событий с способами (функциями) `join` или макросом `join!`,
даже если у них разные виды данных. Это тот же сценарий, с которым мы сталкиваемся при работе с любыми другими видами в Ржавчине. Будущие события не являются чем-то особенным, хотя у нас
есть хороший правила написания для работы с ними, и это хорошо.

### Гонки будущего

Когда мы «соединяем» будущие с помощью семейства функций и макросов `join`, нам
требуется, чтобы _все_ из них завершились, прежде чем мы двинемся дальше. Иногда, однако, нам
нужно только _некоторое_ будущее из набора, чтобы завершиться, прежде чем мы двинемся дальше — что-то вроде
гонки одного будущего против другого.

В приложении 17-21 мы снова используем `trpl::race` для запуска двух будущих событий, `slow` и `fast`, друг против друга.

<Listing number="17-21" caption="Using `race` to get the итог of whichever future finishes first" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-21/src/main.rs:here}}
```

</Listing>

Каждый фьючерс печатает сообщение, когда он начинает работать, останавливается на некоторое время, вызывая и ожидая `sleep`, а затем печатает другое сообщение, когда он
завершается. Затем мы передаем `slow` и `fast` в `trpl::race` и ждем, пока один из них
завершит работу. (Результат здесь не слишком удивителен: `fast` побеждает.) В отличие от того,
когда мы использовали `race` в [“Our First Async Program”][async-program]<!--
ignore -->, мы просто игнорируем образец `Either`, который он возвращает здесь, потому что все
интересное поведение происходит в теле несогласованных разделов.

Обратите внимание, что если вы измените порядок аргументов на `race`, порядок
«запущенных» сообщений изменится, даже несмотря на то, что `fast` фьючерс всегда завершается
первым. Это потому, что реализация этой конкретной способы (функции) `race`
несправедлива. Он всегда запускает фьючерсы, переданные в качестве аргументов, в том порядке, в котором они были переданы. Другие реализации _являются_ справедливыми и будут случайным образом выбирать
какой фьючерс опрашивать первым. Независимо от того, справедлива ли реализация race,
которую мы используем, _один_ из фьючерсов добежит до первого
`await` в своем теле, прежде чем сможет начаться другая задача.

Вспомним из [Наша первая несогласованная приложение][async-program]<!-- ignore -->, что в каждой точке ожидания Ржавчина дает среде выполнения возможность приостановить задачу и переключиться на
другую, если ожидаемый фьючерс не готов. Обратное также верно:
Ржавчина _только_ приостанавливает несогласованные блоки и возвращает управление среде выполнения в точке ожидания. Все между точками ожидания является согласованным.

Это означает, что если вы выполняете кучу работы в несогласованном блоке без точки ожидания,
это будущее заблокирует выполнение любых других фьючерсов. Иногда вы можете слышать, как это называют, когда одно будущее _голодает_ другим будущим. В некоторых случаях это может быть не так уж и важно. Однако, если вы делаете какую-то дорогостоящую
настройку или долгосрочную работу, или если у вас есть будущее, которое будет продолжать выполнять
некую
конкретную задачу бесконечно, вам нужно будет подумать о том, когда и где вернуть
управление среде выполнения.

По той же причине, если у вас есть долгосрочные блокирующие действия, async может быть
полезным средством для предоставления способов для различных частей приложения взаимодействовать друг с другом.

Но _как_ вернуть управление среде выполнения в этих случаях?

<!-- Old headings. Do not remove or links may break. -->

<a id="yielding"></a>

### Передача управления среде выполнения

Давайте смоделируем длительную действие. Приложение 17-22 представляет `медленную`
способ (функцию).

<Listing number="17-22" caption="Использование `thread::sleep` для имитации медленных действий" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-22/src/main.rs:slow}}
```

</Listing>

Этот код использует `std::thread::sleep` вместо `trpl::sleep`, так что вызов
`slow` заблокирует текущий поток на некоторое количество миллисекунд. Мы можем использовать
`slow` для замены реальных действий, которые являются как длительными, так и
блокирующими.

В приложении 17-23 мы используем `slow` для эмуляции выполнения такого рода работы, связанной с ГЛАВНЫЙ ВЫЧИСЛИТЕЛЬ, в
паре фьючерсов.

<Listing number="17-23" caption="Использование `thread::sleep` для имитации медленных действий" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-23/src/main.rs:slow-futures}}
```

</Listing>

Для начала, каждое будущее только возвращает управление среде выполнения _после_ выполнения кучи медленных действий. 
Если вы запустите эта рукопись, вы увидите такой вывод:

<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-23/
cargo run
copy just the output
-->

```text
'a' started.
'a' ran for 30ms
'a' ran for 10ms
'a' ran for 20ms
'b' started.
'b' ran for 75ms
'b' ran for 10ms
'b' ran for 15ms
'b' ran for 350ms
'a' finished.
```

Как и в нашем предыдущем примере, `race` все еще завершается, как только `a` завершается.
Однако между двумя будущими событиями нет чередования. Будущее `a` выполняет всю
свою работу, пока не будет ожидаться вызов `trpl::sleep`, затем будущее `b` выполняет всю
свою работу, пока не будет ожидаться его собственный вызов `trpl::sleep`, и, наконец, будущее `a` завершается. Чтобы позволить обоим будущим событиям выполняться между их медленными
задачами, нам нужны точки ожидания, чтобы мы могли вернуть управление среде выполнения. Это
означает, что нам нужно что-то, что мы можем ожидать!

Мы уже можем видеть, как происходит такая передача в приложении 17-23: если мы
удалим `trpl::sleep` в конце будущего `a`, оно завершится
без запуска будущего `b` _вообще_. Давайте попробуем использовать способ (функцию) `sleep` в качестве отправной точки для отключения действий в этапе выполнения, как показано в
Приложении 17-24.

<Listing number="17-24" caption="Использование `sleep` для отключения действий в целях достижения выполнения" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-24/src/main.rs:here}}
```

</Listing>

В приложении 17-24 мы добавляем вызовы `trpl::sleep` с точками ожидания между каждым вызовом
в `slow`. Теперь работа двух фьючерсов чередуется:

<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-24
cargo run
copy just the output
-->

```text
'a' started.
'a' ran for 30ms
'b' started.
'b' ran for 75ms
'a' ran for 10ms
'b' ran for 10ms
'a' ran for 20ms
'b' ran for 15ms
'a' finished.
```

Будущее `a` все еще выполняется некоторое время, прежде чем передать управление `b`, потому что
оно вызывает `slow` до вызова `trpl::sleep`, но после этого будущие
переключаются туда-сюда каждый раз, когда одно из них достигает точки ожидания. В этом случае мы
делали это после каждого вызова `slow`, но мы могли бы разбить работу
любым способом, который имеет для нас наибольший смысл.

Но на самом деле мы не хотим _спать_ здесь: мы хотим продвигаться так быстро,
как только можем. Нам просто нужно вернуть управление среде выполнения. Мы можем сделать это
напрямую, используя способ (функцию) `yield_now`. В приложении 17-25 мы заменяем все эти
вызовы `sleep` на `yield_now`.

<Listing number="17-25" caption="Использование `yield_now` для отключения действий при достижении выполнения" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-25/src/main.rs:yields}}
```

</Listing>

Этот код и более понятен в отношении фактического намерения, и может быть значительно
быстрее, чем при использовании `sleep`, потому что таймеры, такие как тот, который используется `sleep`, часто
имеют ограничения на то, насколько детальными они могут быть. Версия `sleep`, которую мы используем,
например, всегда будет спать не менее миллисекунды, даже если мы передадим ей `Duration` в одну наносекунду. Опять же, современные компьютеры _быстрые_: они могут сделать
многое за одну миллисекунду!

Вы можете убедиться в этом сами, настроив небольшой бенчмарк, такой как тот,
что в приложении 17-26. (Это не особенно строгий способ тестирования производительности, но его достаточно, чтобы показать разницу здесь.)

<Listing number="17-26" caption="Сравнение производительности `sleep` и `yield_now`" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-26/src/main.rs:here}}
```

</Listing>

Здесь мы пропускаем всю печать статуса, передаем однонаносекундную `Duration` в
`trpl::sleep` и позволяем каждому future работать самому по себе, без переключения между
futures. Затем мы запускаем 1000 итераций и смотрим, сколько времени занимает future с использованием
`trpl::sleep` по сравнению с future с использованием `trpl::yield_now`.

Версия с `yield_now` _намного_ быстрее!

Это означает, что async может быть полезен даже для задач, связанных с вычислениями, в зависимости от того,
что еще делает ваша приложение, потому что он предоставляет полезный средство для
структурирования отношений между различными частями приложения. Это
форма _кооперативной многозадачности_, ​​где каждое future имеет право определять,
когда оно передает управление через точки ожидания. Поэтому каждое future также несет
ответственность за то, чтобы не допустить слишком длительной блокировки. В некоторых встроенных операционных системах на основе Ржавчина это _единственный_ вид многозадачности!

В реальном коде вы, конечно, обычно не будете чередовать вызовы функций с точками ожидания
на каждой строке. Хотя передача управления таким образом
относительно недорога, это не бесплатно. Во многих случаях попытка разбить
вычислительно ограниченную задачу может значительно замедлить ее, поэтому иногда лучше
для _общей_ производительности позволить действия ненадолго заблокироваться. Всегда
измеряйте, чтобы увидеть, каковы в действительностие узкие места производительности вашей рукописи. Однако, если вы _видите_,
много работы выполняется последовательно, а вы ожидали, что она будет выполняться одновременно, важно помнить о
базовой динамике!

### Создание собственных несогласованных абстракций

Мы также можем составлять будущие события вместе, чтобы создавать новые шаблоны. Например, мы можем
построить способ (функцию) `timeout` с несогласованными строительными блоками, которые у нас уже есть. Когда
мы закончим, итогом будет еще один строительный блок, который мы могли бы использовать для создания
еще большего количества несогласованных абстракций.

Приложение 17-27 показывает, как мы ожидаем, что этот `timeout` будет работать с медленным будущим.

<Listing number="17-27" caption="Использование нашего воображаемого `тайм-аута` для запуска медленной действия с ограничением по времени" file-name="src/main.rs">

```rust,ignore
{{#rustdoc_include ../listings/ch17-async-await/listing-17-27/src/main.rs:here}}
```

</Listing>

Давайте реализуем это! Для начала давайте подумаем об API для `timeout`:

- Она должна быть несогласованной функцией, чтобы мы могли ее ожидать.
- Ее первым свойством должно быть будущее для запуска. Мы можем сделать его универсальным, чтобы позволить
ему работать с любым будущим.
- Ее вторым свойством будет максимальное время ожидания. Если мы используем `Duration`,
это облегчит передачу в `trpl::sleep`.
- Она должна возвращать `Result`. Если будущее завершится успешно, `Result` будет `Ok` со значением, выданным будущим. Если время ожидания
истечет первым, `Result` будет `Err` с длительностью, которую время ожидания
ожидало.

Это объявление показано в приложении 17-28.

<!-- This is not tested because it intentionally does not compile. -->

<Listing number="17-28" caption="Определение сигнатуры `timeout`" file-name="src/main.rs">

```rust,ignore
{{#rustdoc_include ../listings/ch17-async-await/listing-17-28/src/main.rs:declaration}}
```

</Listing>

Это удовлетворяет нашим целям для видов. Теперь давайте подумаем о _поведении_, которое нам
нужно: мы хотим гонять будущее, переданное в длительности. Мы можем использовать
`trpl::sleep`, чтобы создать будущее таймера из длительности, и использовать `trpl::race`, чтобы
запустить этот таймер с будущим, переданным вызывающей стороной.

Мы также знаем, что `race` несправедливо, опрашивая аргументы в том порядке, в котором они
передаются. Таким образом, мы передаем `future_to_try` в `race` первым, чтобы он
получил шанс завершиться, даже если `max_time` - очень короткая длительность. Если `future_to_try` завершится первым, `race` вернет `Left` с выходом из
`future_to_try`. Если `timer` завершится первым, `race` вернет `Right` с выходом таймера `()`.

В приложении 17-29 мы сопоставляем итог ожидания `trpl::race`.

<Listing number="17-29" caption="Определение `timeout` с помощью `race` и `sleep`" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-29/src/main.rs:implementation}}
```

</Listing>

Если `future_to_try` успешно выполнено и мы получаем `Left(output)`, мы возвращаем
`Ok(output)`. Если вместо этого истекает таймер сна и мы получаем `Right(())`, мы
игнорируем `()` с `_` и вместо этого возвращаем `Err(max_time)`.

При этом у нас есть работающий `timeout`, построенный из двух других несогласованных помощников. Если
мы запустим наш код, он выведет режим сбоя после тайм-аута:

```text
Failed after 2 seconds
```

Поскольку фьючерсы объединяются с другими фьючерсами, вы можете создавать действительно мощные средства,
используя меньшие несогласованные строительные блоки. Например, вы можете использовать этот же подход,
чтобы объединить тайм-ауты с повторами, и, в свою очередь, использовать их с такими действиями, как
сетевые вызовы (один из примеров из начала главы).

На практике вы обычно будете работать напрямую с `async` и `await`, а
во вторую очередь с способами (функциями) и макросами, такими как `join`, `join_all`, `race` и т. д.

Вам нужно будет только время от времени обращаться к `pin`, чтобы использовать фьючерсы с этими
API.

Теперь мы увидели несколько способов работать с несколькими фьючерсами одновременно. Далее мы рассмотрим, как мы можем работать с несколькими фьючерсами в
последовательности с течением времени с _streams_. Вот еще пара вещей, которые вы, возможно, захотите
рассмотреть в первую очередь:

- Мы использовали `Vec` с `join_all`, чтобы дождаться завершения всех фьючерсов в некоторой группе. Как можно было бы использовать `Vec` для обработки группы фьючерсов в
последовательности вместо этого? Каковы компромиссы этого?

- Взгляните на вид `futures::stream::FuturesUnordered` из дополнения `futures`
. Чем его использование будет отличаться от использования `Vec`? (Не беспокойтесь о том,
что он из части `stream` дополнения; он отлично работает
с любой коллекцией фьючерсов.)

[dyn]: ch12-03-improving-error-handling-and-modularity.html
[enum-alt]: ch08-01-vectors.html#using-an-enum-to-store-multiple-types
[async-program]: ch17-01-futures-and-syntax.html#our-first-async-program
[iterator-trait]: ch13-02-iterators.html#the-iterator-trait-and-the-next-method
