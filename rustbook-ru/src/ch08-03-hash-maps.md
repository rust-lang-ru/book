## Хранение ключей со связанными значениями в хэш-картах

Последняя коллекция, которую мы рассмотрим в нашей книге будет *hash map* (хэш-карта). `HashMap<K, V>` сохраняет ключи типа `K` и значения типа `V`. Данная структура организует и хранит данные с помощью *функции хэширования*. Во множестве языков программирования реализована данная структура, но часто с разными наименованиями: такими как hash, map, object, hash table, dictionary или ассоциированный массив.

Хеш-карты полезны, когда нужно искать данные не используя индекс, по типу того, как это можно делать в векторах, но с помощью ключа, который может быть любого типа. Например, в игре вы можете отслеживать счёт каждой команды в хэш-карте, в которой каждый ключ - это название команды, а значение - счет команды. Для имени команды, вы можете получить ее счёт.

В этом разделе мы рассмотрим базовый API хеш-карт, но ещё много полезных функций скрывается в объявлении типа `HashMap<K, V>` из стандартной библиотеки. Как всегда, обратитесь к документации стандартной библиотеки для получения дополнительной информации.

### Создание новой хэш-карты

Можно создать пустую хеш-карту с помощью `new` и добавить элементы с помощью `insert` . В листинге 8-20 мы отслеживаем счёт двух команд, имена которых синяя (Blue) и желтая (Yellow).  Синяя команда стартует с 10 очками, а жёлтая команда с 50.

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);
```

<span class="caption">Листинг 8-20. Создание новой хэш-карты и вставка в неё некоторых ключей и начальных значений</span>

Обратите внимание, что нужно сначала указать строку `use` `HashMap` для её подключения из коллекций стандартной библиотеки. Из трех коллекций данная является наименее используемой, поэтому она не подключается в область видимости функцией автоматического импорта прелюдии. Хеш-карты также имеют меньшую поддержку со стороны стандартной библиотеки; например, нет встроенного макроса для их конструирования.

Подобно векторам, хеш-карты хранят свои данные в куче. Здесь тип `HashMap` имеет ключи типа `String` и значения типа `i32` . Как и векторы, хэш-карты однородны: все ключи должны иметь одинаковый тип и все значения должны иметь тоже одинаковый тип.

Еще один способ построения хеш-карты - использование метода `collect` на векторе кортежей, где каждый кортеж состоит из ключа и его значения. Метод `collect` собирает данные в несколько типов коллекций, включая `HashMap` . Например, если бы у нас были названия команд и начальные результаты в двух отдельных векторах, то мы могли бы использовать метод `zip` для создания вектора кортежей, где имя «Синяя» спарено с числом 10, и так далее. Тогда мы могли бы использовать метод `collect`, чтобы превратить этот вектор кортежей в хэш-карту, как показано в листинге 8-21.

```rust
use std::collections::HashMap;

let teams  = vec![String::from("Blue"), String::from("Yellow")];
let initial_scores = vec![10, 50];

let scores: HashMap<_, _> = teams.iter().zip(initial_scores.iter()).collect();
```

<span class="caption">Листинг 8-21. Создание хэш-карты из списка команд и списка результатов</span>

Здесь нужна аннотация типа `HashMap<_, _>` , поскольку с помощью метода `collect` данные можно собрать во множество различных структур данных и Rust не знает, в какую именно вы хотите собрать, пока вы не укажете это явно. Для параметров типа ключа и значения, мы используем подчеркивания и Rust может вывести типы, которые хеш содержит на основе типов данных из двух векторов.

### Хеш-карты и владение

Для типов, которые реализуют типаж `Copy`, например `i32`, значения копируются в хэш-карту. Для значений с владением, таких как `String`, значения  будут перемещены в хеш-карту и она станет владельцем этих значений, как показано в листинге 8-22.

```rust
use std::collections::HashMap;

let field_name = String::from("Favorite color");
let field_value = String::from("Blue");

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name and field_value are invalid at this point, try using them and
// see what compiler error you get!
```

<span class="caption">Листинг 8-22. Показывает, что ключи и значения находятся во владении хэш-карты, как только они были вставлены</span>

Мы не можем использовать переменные `field_name` и `field_value` после того, как их значения были перемещены в хэш-карту вызовом метода `insert`.

Если мы вставим в хэш-карту ссылки на значения, то они не будут перемещены в хэш-карту. Значения, на которые указывают ссылки, должны быть действительными хотя бы до тех пор, пока хеш-карта действительна. Мы поговорим об этих вопросах подробнее в разделе [«Проверка ссылок с помощью времени жизни»](ch10-03-lifetime-syntax.html#validating-references-with-lifetimes)<comment> главы 10.</comment>

### Доступ к данным в HashMap

Можно получить значение из хэш-карты предоставляя ключ с помощью метода `get`, как показано в листинге 8-23:

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

let team_name = String::from("Blue");
let score = scores.get(&team_name);
```

<span class="caption">Листинг 8-23. Доступ к счету "Blue" команды сохраненному в хэш-карте</span>

Здесь `score` будет иметь значение, связанное с командой Blue, результат будет `Some(&10)`. Результат обернут в вариант перечисления `Some` потому что `get` возвращает `Option<&V>`; если для этого ключа нет значения в хэш-карте, `get` вернет `None`. Программа должна будет обрабатывать `Option` в одним из способов, которые мы рассмотрели в главе 6.

Мы можем перебирать каждую пару ключ/значение в хэш-карте таким же образом, как мы делали с векторами используя цикл `for`:

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

for (key, value) in &scores {
    println!("{}: {}", key, value);
}
```

Этот код будет печатать каждую пару в произвольном порядке:

```text
Yellow: 50
Blue: 10
```

### Обновление данных

Хотя количество ключей и значений может увеличиваться в хэш-карте, каждый ключ может иметь только одно значение, связанное с ним в один момент времени. Когда вы хотите изменить данные в хеш-карте, необходимо решить, как обрабатывать случай, когда ключ уже имеет назначенное значение. Можно заменить старое значение новым, полностью игнорируя старое. Можно сохранить старое значение и игнорировать новое и добавлять новое значение, если только ключ *ещё не* имел значения. Или можно было бы объединить старое значение и новое значение. Давайте посмотрим, как сделать каждый из вариантов!

#### Перезаписывание старых данных

Если мы вставим ключ и значение в хэш-карту, а затем вставим тот же ключ с другим значением, то значение связанное с этим ключом, будет заменено. Даже несмотря на то, что код в листинге 8-24 вызывает `insert` дважды, хеш-карта будет содержит только одну пару ключ/значение, потому что мы вставляем значение для ключа Blue команды оба раза.

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Blue"), 25);

println!("{:?}", scores);
```

<span class="caption">Листинг 8-24. Замена значения, хранимого конкретным ключом</span>

Код напечатает `{"Blue": 25}`. Начальное значение 10 будет перезаписано.

#### Только вставка значения, если ключ не имеет значения

Обычно проверяют, имеется ли значение для конкретного ключа и если нет, то значение для него вставляется. Хеш-карты имеют для этого специальный API  называемый `entry`, который принимает ключ для проверки в качестве входного параметра. Возвращаемое значение метода `entry` - это перечисление `Entry`, представляющее значение, которое может существовать или может отсутствовать. Допустим, мы хотим проверить, имеет ли ключ для Yellow команды связанное с ним значение. Если не имеет то, мы хотим вставить значение 50, и то же самое для Blue команды. Используя API `entry`, код выглядит в листинге 8-25.

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);

scores.entry(String::from("Yellow")).or_insert(50);
scores.entry(String::from("Blue")).or_insert(50);

println!("{:?}", scores);
```

<span class="caption">Листинг 8-25. Использование метода <code>entry</code> для вставки, только если ключ ещё не имеет значения</span>

Метод `or_insert` в `Entry` определен как возвращающий изменяемую ссылку на значение соответствующее ключу `Entry` , когда этот ключ существует, а если его нет, то вставляет параметр в качестве нового значения этого ключа и возвращает изменяемую ссылку на новое значение. Эта техника намного чище, чем написание логики самостоятельно и кроме того, более безопасны и согласуются с правилами заимствования.

При выполнении кода листинга 8-25 будет напечатано `{"Yellow": 50, "Blue": 10}` . Первый вызов метода `entry` вставит ключ для Yellow команды со значением 50, потому что для желтой команды ещё не имеется значения в хэш-карте. Второй вызов `entry` не изменит хеш-карту, потому что для ключа Blue команды уже имеется значение 10.

#### Обновление значения основанное на предыдущих данных

Другим распространенным вариантом использования хеш-карт является поиск значения по ключу, а затем обновление этого значения на основе старого значения. Например, в листинге 8-26 показан код, который подсчитывает, сколько раз определенное слово появляется в каком-либо тексте. Мы используем хэш-карту со словом в качестве ключа и увеличиваем соответствующее ему значение, чтобы отслеживать, сколько раз в тексте мы увидели слово. Если мы впервые увидели слово, сначала вставляем значение 0.

```rust
use std::collections::HashMap;

let text = "hello world wonderful world";

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!("{:?}", map);
```

<span class="caption">Листинг 8-26. Подсчет вхождений слов с использованием хеш-карты, которая хранит слова и счетчики</span>

Будет напечатано `{"world": 2, "hello": 1, "wonderful": 1}`. Метод `or_insert` возвращает изменяемую ссылку на значение (`&mut V`) по ключу. Мы сохраняем изменяемую ссылку в переменной `count`. Для того, чтобы присвоить переменной значение, необходимо произвести разименование с помощью звёздочки (`*`). Изменяемая ссылка удаляется сразу же после выхода из области видимости цикла `for`. Все эти изменения безопасны и согласуются с правилами заимствования.

### Функция хэширования

По умолчанию `HashMap` использует "криптографически сильную" функцию хэширования [^siphash](%5Bhttps://www.131002.net/siphash/siphash.pdf%5D(https://www.131002.net/siphash/siphash.pdf)) , которая может противостоять Denial of Service (DoS) атакам. В этой реализации используется не самый быстрый алгоритм хэширования, но данный компромисс, который идет с падением производительности, стоит того для лучшей безопасности. Если после профилирования вашего кода окажется, что хэш функция по умолчанию очень медленная, вы можете её заменить на другую подобную функцию с помощью указания другой (*hasher*). Эта функция реализует типаж `BuildHasher`. Подробнее о типажах вы узнаете в главе 10. Вам совсем не обязательно реализовывать свою собственную функцию хэширования, [crates.io](https://crates.io/) имеет достаточное количество библиотек, предоставляющих реализации для hasher с множеством общих алгоритмов хэширования.

## Итоги

Векторы, строки и хэш-карты предоставят большое количество функционала для программ, когда необходимо сохранять, получать доступ и модифицировать данные. Теперь вы готовы решить следующие учебные задания:

- Есть список целых чисел. Создайте функцию, используйте вектор и верните из списка: среднее значение; медиану (значение элемента из середины списка после его сортировки); mode значение (то которое встречается в списке наибольшее количество раз; хэш-карта будет полезна в данном случае)
- Сконвертируюйте строку в Pig Latin кодировку, где первая согласная каждого слова перемещается в конец и к ней добавляется окончание “ay”. Пример, “first” - “irst-fay”. Если слово начинается на гласную, то в конец слова добавляется суффикс “hay”. Пример, “apple” - “apple-hay”.
- Используя хеш-карту и векторы, создайте текстовый интерфейс позволяющий пользователю добавлять имена сотрудников к названию отдела компании. Например, “Add Sally to Engineering” or “Add Amir to Sales”. Затем нужно получит список всех людей из отдела или всех людей в компании отсортированным в алфавитном порядке по отделам.

Документация API стандартной библиотеки описывает методы у векторов, строк и хэш-карт, что будет вам помогать в решении упражнений.

Мы входим в более сложные программы, в которых операции могут потерпеть неудачу, так что это идеальное время для обсуждения обработки ошибок. Мы сделаем это дальше!
