## Хранение ключей со связанными значениями в HashMap

Последний вид собрания, который мы рассмотрим, будет *hash map* (хеш-карта). Вид данных `HashMap<K, V>` хранит ключи вида данных `K` и значения к ним вида данных `V`. Данный вид собрания согласует и хранит данные с помощью *функции хеширования*. Во множестве языков программирования существуют такие виды данных, но часто с разными названиями: такими как hash, map, object, hash table, dictionary или связанный массив.

Хеш-карты полезны, когда нужно искать данные не используя порядковый указатель, как это например делается в векторах. Здесь применяется ключ, который может быть любого вида данных. Например, в игре вы можете отслеживать счёт каждого игрока в хеш-карте, в которой каждый `ключ` - это имя игрока, а `значение` - его счёт. Зная имя игрока, вы можете получить его счёт из хеш-карты.

В этом разделе мы рассмотрим основной API хеш-карт. Остальной набор полезных функций скрывается в объявлении вида данных собрания -  `HashMap<K, V>`. Как и прежде, советуем обратиться к пособию по встроенной библиотеке для получения дополнительных сведений.

### Создание новой хеш-карты

Создать пустую хеш-карту можно с помощью `new`, а добавить в неё переменные - с помощью `insert`. В приложении 8-20 мы отслеживаем счёт двух игроков, синего *Blue* и жёлтого *Yellow*. Синий игрок набрал 10 очков, а жёлтый игрок - 50.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-20/src/main.rs:here}}
```

<span class="caption">Приложение 8-20: Создание новой хеш-карты и вставка в неё пары ключ-значение</span>

Обратите внимание, что нужно сначала указать использование библиотеки `use std::collections::HashMap;` для её подключения из встроенной библиотеки. Из трёх собраний,  данный вид собрания является наименее используемым, поэтому он не подключается в область видимости функцией самостоятельного подключения (prelude). Хеш-карты также имеют меньшую поддержку со стороны встроенной библиотеки; например, нет встроенного макроса для их разработки.

Подобно векторам, хеш-карты хранят свои данные в куче. Здесь вид данных `HashMap` имеет в качестве вида ключа значение вида данных строка -  `String`, а в качестве значения - целочисленный вид данных `i32`. Как и векторы, HashMap строго однородны: все ключи должны иметь одинаковый вид данных и все значения должны иметь тоже одинаковый вид данных.

### Доступ к данным в HashMap<a name="accessing-values-in-a-hash-map"></a>

Мы можем получить значение из HashMap по ключу, с помощью способа `get`, как показано в приложении 8-21.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-21/src/main.rs:here}}
```

<span class="caption">Приложение 8-21: Доступ к очкам игрока "Blue", которые хранятся в хеш-карте</span>

Здесь переменной `score` присваивается количество очков, связанное с игроком "Blue", итог будет значение `10`. Способ `get` возвращает `Option<&V>`; если для какого-то ключа нет значения в HashMap, `get` вернёт `None`. Из-за такого подхода программе следует обрабатывать `Option`, вызывая `copied` для получения `Option<i32>` вместо `Option<&i32>`, затем `unwrap_or` для установки `score` в ноль, если scores не содержит данных по этому ключу.

Мы можем перебирать каждую пару ключ/значение в HashMap таким же образом, как мы делали с векторами, используя круговорот `for`:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/no-listing-03-iterate-over-hashmap/src/main.rs:here}}
```

Эта рукопись будет выводить каждую пару в произвольном порядке:

```text
Yellow: 50
Blue: 10
```

### Хеш-карты и владение

Для видов данных, которые используют сущность `Copy`, например `i32`, значения повторяются в HashMap. Для значений с владением, таких как вид данных `String`, значения  будут перемещены в хеш-карту и она станет владельцем этих значений, как показано в приложении 8-22.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-22/src/main.rs:here}}
```

<span class="caption">Приложение 8-22: Показывает, что ключи и значения находятся во владении HashMap, как только они были вставлены</span>

Мы не можем использовать переменные `field_name` и `field_value` после того, как их значения были перемещены в HashMap вызовом способа `insert`.

Если мы вставим в HashMap ссылки на значения, то они не будут перемещены в HashMap. Значения, на которые указывают ссылки, должны быть действительными хотя бы до тех пор, пока хеш-карта действительна. Мы поговорим подробнее об этих вопросах в разделе ["Проверка действительности ссылок при помощи времён жизни"](ch10-03-lifetime-syntax.html#validating-references-with-lifetimes)<!-- ignore --> Главы 10.

### Обновление данных в HashMap

Хотя количество ключей и значений может увеличиваться в HashMap, каждый ключ может иметь только одно значение, связанное с ним в одно мгновение времени (обратное утверждение неверно: игроки "Blue" и "Yellow" могут хранить в хеш-карте `scores` одинаковое количество очков, например 10).

Когда вы хотите изменить данные в хеш-карте, необходимо решить, как обрабатывать случай, когда ключ уже имеет назначенное значение. Можно заменить старое значение новым, полностью пренебрегая старым. Можно сохранить старое значение и пренебрегать новым, или добавлять новое значение, если только ключ *ещё не* имел значения. Или можно было бы объединить старое значение и новое значение. Давайте посмотрим, как сделать каждый из исходов!

#### Перезапись старых значений

Если мы вставим ключ и значение в HashMap, а затем вставим тот же ключ с новым значением, то старое значение связанное с этим ключом, будет заменено на новое. Даже несмотря на то, что рукопись в приложении 8-23 вызывает `insert` дважды, хеш-карта будет содержать только одну пару ключ/значение, потому что мы вставляем значения для одного и того же ключа - ключа игрока "Blue".

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-23/src/main.rs:here}}
```

<span class="caption">Приложение 8-23: Замена значения, хранимого в определенном ключе</span>

Рукопись выведет `{"Blue": 25}`. Начальное значение `10` было перезаписано.

<!-- Old headings. Do not remove or links may break. -->

<a id="only-inserting-a-value-if-the-key-has-no-value"></a>

#### Вставка значения только в том случае, когда ключ не имеет значения

Обычно проверяют, существует ли определенный ключ в хеш-карте со значением, а затем предпринимаются следующие действия: если ключ существует в хеш-карте, существующее значение должно оставаться таким, какое оно есть. Если ключ не существует, то вставляют его и значение для него.

Хеш-карты имеют для этого особый API, называемый `entry` , который принимает ключ для проверки в качестве входного свойства. Возвращаемое значение способа `entry` - это перечисление `Entry`, с двумя исходами: первый представляет значение, которое может существовать, а второй говорит о том, что значение отсутствует. Допустим, мы хотим проверить, имеется ли ключ и связанное с ним значение для игрока "Yellow". Если хеш-карта не имеет значения для такого ключа, то мы хотим вставить значение 50. То же самое мы хотим проделать и для игрока "Blue". Используем API `entry` в рукописи приложения 8-24.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-24/src/main.rs:here}}
```

<span class="caption">Приложение 8-24: Использование способа <code>entry</code> для вставки значения только в том случае, когда ключ не имеет значения. Есть ключ отсутствует - то вставляется пара ключ-значение</span>

Способ `or_insert` определён в `Entry` так, чтобы возвращать изменяемую ссылку на соответствующее значение ключа внутри исхода перечисления `Entry`, когда этот ключ существует, а если его нет, то вставлять свойство в качестве нового значения этого ключа и возвращать изменяемую ссылку на новое значение. Эта техника намного чище, чем самостоятельное написание хода мыслей и, кроме того, она более безопасна и согласуется с правилами заимствования.

При выполнении рукописи приложения 8-24 будет выведено `{"Yellow": 50, "Blue": 10}`. Первый вызов `способа entry` вставит ключ для игрока "Yellow" со значением 50, потому что для жёлтого игрока ещё не имеется значения в HashMap. Второй вызов `entry` не изменит хеш-карту, потому что для ключа игрока "Blue" уже имеется значение 10.

#### Создание нового значения на основе старого значения

Другим распространённым исходом использования хеш-карт является поиск значения по ключу, а затем обновление этого значения на основе старого значения. Например, в приложении 8-25 показана рукопись, которая подсчитывает, сколько раз определённое слово встречается в некотором  писании. Мы используем HashMap со словами в качестве ключей и увеличиваем соответствующее слову значение, чтобы отслеживать, сколько раз мы встретили это слово. Если мы впервые встретили слово, то сначала вставляем значение 0.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-25/src/main.rs:here}}
```

<span class="caption">Приложение 8-25: Подсчёт количества вхождений слов с использованием хеш-карты, которая хранит слова и счётчики</span>

Эта рукопись выведет `{"world": 2, "hello": 1, "wonderful": 1}`. Если вы увидите, что пары ключ/значение выводятся в другом порядке, то вспомните, что мы писали в разделы ["Доступ к данным в HashMap"]<!-- ignore -->, что повторение по хеш-карте происходит в произвольном порядке.

Способ `split_whitespace` возвращает повторитель по срезам строки, разделённых пробелам, для строки  `text`. Способ `or_insert` возвращает изменяемую ссылку (`&mut V`) на значение ключа. Мы сохраняем изменяемую ссылку в переменной `count`, для этого, чтобы присвоить переменной значение, необходимо произвести разыменование с помощью звёздочки (*). Изменяемая ссылка удаляется сразу же после выхода из области видимости круговорота `for`, поэтому все эти изменения безопасны и согласуются с правилами заимствования.

### Функция хеширования

По умолчанию `HashMap` использует функцию хеширования *SipHash*, которая может противостоять нападениям класса отказ в обслуживании, Denial of Service (DoS) с использованием хеш-таблиц [siphash](https://en.wikipedia.org/wiki/SipHash)<!-- ignore -->. Это не самый быстрый из возможных распорядков хеширования, в данном случае производительность идёт на соглашение с обеспечением лучшей безопасности. Если после рассмотрения вашей рукописи окажется, что хеш-функция, используемая по умолчанию, очень медленная, вы можете заменить её используя другой hasher. *Hasher* - это способ, выполняющий сущность `BuildHasher`. Подробнее о особенностях мы поговорим в Главе 10. Вам совсем не обязательно создавать свою собственную функцию хеширования; [crates.io](https://crates.io/)<!-- ignore --> имеет достаточное количество библиотек, предоставляющих разные исполнения hasher с множеством общих распорядков хеширования.

## Итоги

Векторы, строки и хеш-карты предоставят большое количество возможностей для программ, когда необходимо сохранять, получать доступ и изменять данные. Теперь вы готовы решить следующие учебные задания:

- Есть список целых чисел. Создайте функцию, используйте вектор и верните из списка: среднее значение; медиану (значение переменной из середины списка после его упорядочивания); режиму списка (mode of list, то значение которое встречается в списке наибольшее количество раз; HashMap будет полезна в данном случае).
- Преобразуйте строку в представлении "поросячьей латыни" (Pig Latin). Первая согласная каждого слова перемещается в конец и к ней добавляется окончание "ay", так "first" станет "irst-fay". Слову, начинающемуся на гласную, в конец добавляется "hay" ("apple" становится "apple-hay"). Помните о подробностях работы с представлением UTF-8!
- Используя хеш-карту и векторы, создайте внешнюю оболочку через рукопись, позволяющую пользователю добавлять имена сотрудников к названию отдела предприятия. Например, "Add Sally to Engineering" или "Add Amir to Sales". Затем позвольте пользователю получить список всех людей из отдела или всех людей в предприятия, упорядоченных по отделам в алфавитном порядке.

Пособие API встроенной библиотеки описывает способы у векторов, строк и HashMap. Советуем воспользоваться ей при решении упражнений.

Потихоньку мы переходим к более сложным программам, в которых действия могут потерпеть неудачу. Наступило наилучшее время для обсуждения обработки ошибок.


["Доступ к данным в HashMap"]: #accessing-values-in-a-hash-map