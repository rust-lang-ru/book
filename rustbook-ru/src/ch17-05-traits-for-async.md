## Более подробный взгляд на особенности несогласованности

<!-- Old headings. Do not remove or links may break. -->

<a id="digging-into-the-traits-for-async"></a>

На протяжении всей главы мы использовали сущности `Future`, `Pin`, `Unpin`, `Stream` и
`StreamExt` различными способами. Однако до сих пор мы избегали слишком
глубоко вдаваться в подробности того, как они работают или как они сочетаются друг с другом, что вполне подходит
для вашей повседневной работы Ржавчина. Иногда, однако, вы
столкнетесь с ситуациями, когда вам нужно будет понять еще несколько из этих
деталей. В этом разделе мы углубимся ровно настолько, чтобы помочь в этих сценариях,
все еще оставляя _действительно_ глубокое погружение для другой документации.

<!-- Old headings. Do not remove or links may break. -->

<a id="future"></a>

### Сущность `Future` Trait

Давайте начнем с более подробного рассмотрения того, как работает сущность `Future`. Вот как ее определяет Ржавчина:

```rust
use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}
```

Это определение сущности включает в себя множество новых видов, а также некоторый правила написания, который мы
раньше не видели, поэтому давайте разберем определение по частям.

Во-первых, ассоциированный вид `Future` `Output` говорит, во что разрешается будущее.
Это аналогично ассоциированному виду `Item` для сущности `Iterator`.

Во-вторых, `Future` также имеет способ `poll`, который принимает специальную ссылку `Pin` для своего свойства `self` и изменяемую ссылку на вид `Context`,
и возвращает `Poll<Self::Output>`. Мы поговорим подробнее о `Pin` и
`Context` чуть позже. А пока сосредоточимся на том, что возвращает способ,

виде `Poll`:

```rust
enum Poll<T> {
    Ready(T),
    Pending,
}
```

Этот вид `Poll` похож на `Option`. У него есть один вариант, который имеет значение, `Ready(T)`, и один, который не имеет значения, `Pending`. `Poll` означает нечто совсем иное, чем `Option`! Вариант `Pending` указывает, что у будущего
еще есть работа, поэтому вызывающему нужно будет проверить еще раз позже. Вариант `Ready`
указывает, что будущее завершило свою работу, и значение `T`
доступно.

> Примечание: для большинства фьючерсов вызывающий не должен вызывать `poll` снова после того, как
> фьючерс вернул `Ready`. Многие фьючерсы впадут в панику, если их снова опросить после того, как они станут готовы. Фьючерсы, которые можно безопасно опрашивать снова, явно сообщат об этом в
> своей документации. Это похоже на то, как ведет себя `Iterator::next`.

Когда вы видите код, который использует `await`, Ржавчина собирает его под капотом в рукопись, который вызывает `poll`. Если вы посмотрите на приложение 17-4, где мы распечатали
заголовок страницы для одного URL после его разрешения, Ржавчина собирает его во что-то вроде (хотя и не совсем) такого:

```rust,ignore
match page_title(url).poll() {
    Ready(page_title) => match page_title {
        Some(title) => println!("The title for {url} was {title}"),
        None => println!("{url} had no title"),
    }
    Pending => {
        // But what goes here?
    }
}
```

Что нам делать, когда будущее все еще `Ожидаемое`? Нам нужен способ попробовать
снова, и снова, и снова, пока будущее не будет окончательно готово. Другими словами,
нам нужен цикл:

```rust,ignore
let mut page_title_fut = page_title(url);
loop {
    match page_title_fut.poll() {
        Ready(value) => match page_title {
            Some(title) => println!("The title for {url} was {title}"),
            None => println!("{url} had no title"),
        }
        Pending => {
            // continue
        }
    }
}
```

Однако если Ржавчина ссобирает его именно в эта рукопись, каждый `await` будет
блокирующим — прямо противоположно тому, что мы собирались сделать! Вместо этого Ржавчина гарантирует,
что цикл может передать управление чему-то, что может приостановить работу над этим
future, чтобы поработать над другими future, а затем снова проверить этот позже. Как мы
увидели, это что-то является несогласованной средой выполнения, и эта работа по планированию и взаимодействия
является одной из ее основных задач.

Ранее в этой главе мы описали ожидание `rx.recv`. Вызов `recv`
возвращает future, а ожидание future опрашивает его. Мы отметили, что среда выполнения
приостанавливает future, пока он не будет готов с `Some(сообщение)` или `None`, когда
канал закрывается. С нашим более глубоким пониманием сущности `Future`, и
в частности `Future::poll`, мы можем увидеть, как это работает. Среда выполнения знает, что
будущее не готово, когда возвращает `Poll::Pending`. С другой стороны, среда выполнения
знает, что будущее _готово_, и продвигает его вперед, когда `poll` возвращает
`Poll::Ready(Some(сообщение))` или `Poll::Ready(None)`.

Точные детали того, как среда выполнения это делает, выходят за рамки этой книги,
но ключ в том, чтобы увидеть базовую механику будущих событий: среда выполнения _опрашивает_ каждое
будущее, за которое она отвечает, возвращая будущее в режим сна, когда оно еще не готово.

<!-- Old headings. Do not remove or links may break. -->

<a id="pinning-and-the-pin-and-unpin-traits"></a>

###  `Pin` и `Unpin` сущности

Когда мы представили идею закрепления в приложении 17-16, мы столкнулись с очень грубым сообщением об ошибке. Вот его соответствующая часть еще раз:

<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-16
cargo build
copy *only* the final `error` block from the errors
-->

```text
error[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned
  --> src/main.rs:48:33
   |
48 |         trpl::join_all(futures).await;
   |                                 ^^^^^ the trait `Unpin` is not implemented for `{async block@src/main.rs:10:23: 10:33}`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box<{async block@src/main.rs:10:23: 10:33}>` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --> file:///home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll<F>
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`
```

Это сообщение об ошибке говорит нам не только о том, что нам нужно закрепить значения, но и о том, почему закрепление необходимо. Функция `trpl::join_all` возвращает структуру с именем `JoinAll`. Эта структура является общей для вида `F`, который ограничен для реализации сущности `Future`. Прямое ожидание будущего с помощью `await` закрепляет
будущее неявно. Вот почему нам не нужно использовать `pin!` везде, где мы хотим
ожидать будущие.

Однако мы не ожидаем будущего напрямую. Вместо этого мы создаем новое будущее `JoinAll`, передавая коллекцию будущих функций в функцию `join_all`. Сигнатура для `join_all` требует, чтобы виды данных элементов в
коллекции все реализовывали сущность `Future`, а `Box<T>` использует
`Future` только в том случае, если `T`, который он оборачивает, является будущим, реализующим сущность `Unpin`.

Это очень много для усвоения! Чтобы действительно понять это, давайте немного углубимся в то, как на самом деле работает сущность `Future`, в частности, в _закрепление_.

Еще раз взглянем на определение сущности `Future`:

```rust
use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    // Required method
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}
```

Свойство `cx` и его вид `Context` являются ключом к тому, как среда выполнения на самом деле
узнает, когда проверять любое заданное будущее, оставаясь при этом ленивой. Опять же, подробности того,
как это работает, выходят за рамки этой главы, и вам, как правило,
нужно думать об этом только при написании пользовательской реализации `Future`. Вместо этого мы
сосредоточимся на виде для `self`, поскольку это
первый раз, когда мы увидели способ, где `self` имеет аннотацию вида. Аннотация вида для `self` работает
как аннотации вида для других свойств функции, но с двумя ключевыми
различиями:

- Он сообщает Ржавчина, какой вид `self` должен быть для вызова способа.

- Он не может быть просто любым видом. Он ограничен видом, на котором способ
реализован, ссылкой или умным указателем на этот вид или `Pin`, оборачивающим
ссылку на этот вид.

Мы рассмотрим этот правила написания подробнее в [Главе 18][ch-18]<!-- ignore -->. На данный момент достаточно знать, что если мы хотим опросить future, чтобы проверить, является ли он
`Pending` или `Ready(Output)`, нам нужна `Pin`-обернутая изменяемая ссылка на
вид.

`Pin` — это оболочка для видов, подобных указателям, таких как `&`, `&mut`, `Box` и `Rc`.

(Технически `Pin` работает с видами, которые воплощают свойства `Deref` или `DerefMut`, но это в действительности равноценно работе только с указателями.) `Pin`
сам по себе не является указателем и не имеет никакого собственного поведения, как `Rc` и
`Arc` с подсчетом ссылок; это просто средство, который сборщик может использовать для
обеспечения ограничений на использование указателей.

Напоминание о том, что `await` реализовано в терминах вызовов `poll`, начинает
объяснять сообщение об ошибке, которое мы видели ранее, но это было в терминах `Unpin`, а не `Pin`. Так как же именно `Pin` соотносится с `Unpin`, и почему `Future` нужно `self`, чтобы быть в виде `Pin`, чтобы вызвать `poll`?

Помните, ранее в этой главе ряд точек ожидания в будущем
собирается в конечный автомат, и сборщик гарантирует, что конечный автомат
следует всем обычным правилам Ржавчина относительно безопасности, включая заимствование и
владение. Чтобы это работало, Ржавчина смотрит, какие данные нужны между одной
точкой ожидания и либо следующей точкой ожидания, либо концом несогласованного блока. Затем он
создает соответствующий вариант в скомпилированном конечном автомате. Каждый вариант
получает необходимый ему доступ к данным, которые будут использоваться в этом разделе
исходной рукописи, либо путем получения права собственности на эти данные, либо путем получения изменяемой или
неизменяемой ссылки на них.

Пока все хорошо: если мы что-то неправильно поняли относительно права собственности или ссылок в
данном несогласованном блоке, проверка заимствований нам сообщит. Когда мы хотим переместить
будущее, соответствующее этому блоку, например, переместить его в `Vec` для передачи в `join_all`, все становится сложнее.

Когда мы перемещаем будущее, будь то путем помещения его в структуру данных для использования в качестве повторителя с `join_all` или путем возврата его из функции, это в действительности означает
перемещение конечного автомата, который Ржавчина создает для нас. И в отличие от большинства других видов в
Ржавчина, будущие состояния Ржавчина, создаваемые для несогласованных разделов, могут оказаться со ссылками на
себя в полях любого заданного варианта, как показано на упрощенной иллюстрации на рисунке 17-4.

<figure>

<img alt="Таблица из одного столбца и трех строк, представляющая будущее, fut1, в первых двух строках которой содержатся значения данных 0 и 1, а также стрелка, указывающая из третьей строки обратно во вторую строку, представляющая внутреннюю ссылку в будущем." src="img/trpl17-04.svg" class="center" />

<figcaption>Рисунок 17-4: Самореферентный вид данных.</figcaption>

</figure>

Однако по умолчанию любой объект, имеющий ссылку на себя, небезопасно перемещать,
потому что ссылки всегда указывают на в действительностий адрес памяти того, на что они
ссылаются (см. рис. 17-5). Если вы переместите саму структуру данных, эти
внутренние ссылки останутся указывать на старое местоположение. Однако это
место памяти теперь недействительно. Во-первых, его значение не будет обновляться,
когда вы вносите изменения в структуру данных. Во-вторых, более важно,
компьютер теперь может свободно повторно использовать эту память для других целей! Вы можете в конечном итоге
считывать совершенно несвязанные данные позже.

<figure>

<img alt="Две таблицы, изображающие два будущих состояния, fut1 и fut2, каждое из которых имеет один столбец и три строки, представляющие итог перемещения будущего из fut1 в fut2. Первая, fut1, затенена, с вопросительным знаком в каждом индексе, представляющим неизвестную память. Вторая, fut2, имеет 0 и 1 в первой и второй строках и стрелку, указывающую из третьей строки обратно на вторую строку fut1, представляющую указатель, который ссылается на старое местоположение в памяти будущего до его перемещения." src="img/trpl17-05.svg" class="center" />

<figcaption>Рисунок 17-5: Небезопасный итог перемещения самореферентного вида данных</figcaption>

</figure>

Теоретически сборщик Ржавчина может попытаться обновить каждую ссылку на
объект всякий раз, когда он передаётся, но это может добавить много накладных расходов на производительность,
особенно если требуется обновление целой сети ссылок. Если бы мы могли вместо этого убедиться,
что рассматриваемая структура данных _не передаётся в памяти_, нам не пришлось бы
обновлять никакие ссылки. Это именно то, что требуется для проверки заимствований Ржавчина:
в безопасном коде он не позволяет вам перемещать любой элемент с активной ссылкой на
его.

`Pin` основывается на этом, чтобы дать нам точную гарантию, которая нам нужна. Когда мы _закрепляем_ значение, оборачивая указатель на это значение в `Pin`, оно больше не может перемещаться. Таким образом,
если у вас есть `Pin<Box<SomeType>>`, вы в действительности закрепляете значение `SomeType`, _не_
указатель `Box`. Рисунок 17-6 иллюстрирует этот этап.

<figure>

<img alt="Три поля, разложенные рядом. Первое поле обозначено как «Pin», второе — как «b1», а третье — как «pinned». Внутри «pinned» находится таблица с обозначением «fut» с одним столбцом; она представляет собой будущее с ячейками для каждой части структуры данных. Ее первая ячейка имеет значение «0», из второй ячейки выходит стрелка, указывающая на четвертую и последнюю ячейку, в которой содержится значение «1», а третья ячейка имеет пунктирные линии и многоточие, указывающие на то, что в структуре данных могут быть и другие части. В целом таблица «fut» представляет собой будущее, которое ссылается на себя. Стрелка выходит из поля с обозначением «Pin», проходит через поле с обозначением «b1» и заканчивается внутри поля «pinned» в таблице «fut»." src="img/trpl17-06.svg" class="center" />

<figcaption>Рисунок 17-6: Закрепление «дополнения», указывающего на самореферентный вид будущего.</figcaption>

</figure>

На самом деле указатель `Box` все еще может свободно перемещаться. Помните: мы заботимся о том,
чтобы данные, на которые в конечном итоге ссылаются, оставались на месте. Если указатель
передаётся, _но данные, на которые он указывает, находятся в том же месте_, как на рисунке
17-7, то имеющейся проблемы нет. В качестве независимого упражнения посмотрите документацию
для видов, а также модуль `std::pin` и попробуйте понять,
как бы вы сделали это с `Pin`, оборачивающим `Box`.) Ключ в том, что сам по себе референтный вид
не может перемещаться, потому что он все еще закреплен.
<figure>

<img alt="Четыре блока, разложенные в три грубых столбца, идентичны предыдущей диаграмме с изменением во втором столбце. Теперь во втором столбце есть два блока, помеченные как «b1» и «b2», «b1» затенено, а стрелка от «Pin» проходит через «b2» вместо «b1», указывая на то, что указатель переместился с «b1» на «b2», но данные в «pinned» не переместились." src="img/trpl17-07.svg" class="center" />

<figcaption>Рисунок 17-7: Перемещение «дополнения», указывающего на самореферентный вид будущего.</figcaption>

</figure>

Однако большинство видов совершенно безопасно перемещать, даже если они находятся
за оберткой `Pin`. Нам нужно думать о закреплении только тогда, когда элементы имеют
внутренние ссылки. Примитивные значения, такие как числа и логические значения, безопасны,
потому что у них, очевидно, нет никаких внутренних ссылок. Как и большинство видов,
с которыми вы обычно работаете в Ржавчине. Вы можете перемещать `Vec`,
например,
не беспокоясь. Учитывая только то, что мы видели до сих пор, если у вас есть ``Pin<Vec<String>>`, вам придется делать все через безопасные, но ограничительные
API, предоставляемые `Pin`, даже несмотря на то, что `Vec<String>` всегда безопасно перемещать,
если на него нет других ссылок. Нам нужен способ сообщить сборщику,
что перемещать элементы в таких случаях можно,
и вот тут-то `Unpin` и вступает в игру.

`Unpin` — это сущность-маркер, похожая на сущности `Send` и `Sync`, которые мы видели в
Главе 16, и, таким образом, не имеет собственной функциональности. Черты-маркеры существуют только для того, чтобы сообщить сборщику, что можно безопасно использовать вид, реализующий данную сущность, в
определенном контексте. `Unpin` сообщает сборщику, что данный вид _не_ должен поддерживать какие-либо заверения относительно того, можно ли безопасно перемещать рассматриваемое значение.

<!--
  The inline `<code>` in the next block is to allow the inline `<em>` inside it,
  matching what NoStarch does style-wise, and emphasizing within the text here
  that it is something distinct from a normal type.
-->

Как и в случае с `Send` и `Sync`, сборщик автоматически использует `Unpin` для всех видов, где он может доказать, что это безопасно. Особый случай, опять же похожий на `Send` и `Sync`, — это когда `Unpin` _не_ реализован для вида. Обозначение для этого: <code>impl !Unpin для <em>SomeType</em></code>, где
<code><em>SomeType</em></code> — это имя вида, который _не_ должен поддерживать эти заверения безопасности, когда указатель на этот вид используется в `Pin`.

Другими словами, есть две вещи, которые следует иметь в виду относительно связи между `Pin` и `Unpin`. Во-первых, `Unpin` — это «нормальный» случай, а `!Unpin` — это
особый случай. Во-вторых, использует ли вид `Unpin` или `!Unpin` _имеет значение только
когда вы используете закрепленный указатель на этот вид, например <code>Pin<&mut
<em>SomeType</em>></code>.

Чтобы сделать это конкретным, подумайте о `String`: у него есть длина и символы Unicode, которые его составляют. Мы можем обернуть `String` в `Pin`, как показано на рисунке
17-8. Однако `String` автоматически использует `Unpin`, как и большинство других видов
в Ржавчине.
<figure>

<img alt="Одновременный рабочий этап" src="img/trpl17-08.svg" class="center" />

<figcaption>Рисунок 17-8: Закрепление `Строки`; пунктирная линия указывает, что `Строка` использует сущность `Открепить` и, таким образом, не закреплена.</figcaption>

</figure>

В итоге мы можем делать вещи, которые были бы незаконными, если бы `String` реализовал
`!Unpin` вместо этого, например, заменять одну строку другой в том же самом месте памяти,
как на рисунке 17-9. Это не нарушает контракт `Pin`,
потому что `String` не имеет внутренних ссылок, которые делают его небезопасным для перемещения!
Именно поэтому он использует `Unpin`, а не `!Unpin`.

<figure>

<img alt="Одновременный рабочий этап" src="img/trpl17-09.svg" class="center" />

<figcaption>Рисунок 17-9: Замена `Строки` на совершенно другую `Строку` в памяти.</figcaption>

</figure>

Теперь мы знаем достаточно, чтобы понять ошибки, сообщаемые для вызова `join_all`
из приложения 17-17. Изначально мы пытались переместить будущие события,
создаваемые несогласованными блоками, в `Vec<Box<dyn Future<Output = ()>>>`, но, как мы видели,
эти будущие события могут иметь внутренние ссылки, поэтому они не воплощают `Unpin`.

Их нужно закрепить, а затем мы можем передать вид `Pin` в `Vec`,
уверенные в том, что базовые данные в будущих событиях _не_ будут перемещены.

`Pin` и `Unpin` в основном важны для построения низкоуровневых библиотек или
когда вы создаете саму среду выполнения, а не для повседневной рукописи Ржавчина.
Однако, когда вы видите эти сущности в сообщениях об ошибках, теперь вы будете лучше понимать,
как исправить свой код!

> Примечание: эта комбинация `Pin` и `Unpin` позволяет безопасно
> воплотить целый класс сложных видов в Ржавчине, которые в противном случае оказались бы
> сложными, поскольку они ссылаются на себя. Типы, требующие `Pin`,
> чаще всего встречаются в несогласованном Ржавчина сегодня, но время от времени вы можете
> увидеть их и в других контекстах.
>
> Особенности работы `Pin` и `Unpin`, а также правила, которые они должны
> соблюдать, подробно описаны в документации API для `std::pin`, поэтому
> если вам интересно узнать больше, это отличное место для начала.
>
> Если вы хотите еще подробнее понять, как все работает под капотом,
> см. главы [2][under-the-hood] и [4][pinning] книги [_Asynchronous
> Programming in Ржавчина_][async-book].

### `Stream` сущность

Теперь, когда вы глубже поняли сущности `Future`, `Pin` и `Unpin`, мы можем обратить внимание на сущность `Stream`. Как вы узнали ранее в этой главе, потоки похожи на несогласованные повторители. В отличие от `Iterator` и
`Future`, однако, `Stream` не имеет определения в стандартной библиотеке на момент написания этой
статьи, но есть _очень_ общее определение из дополнения `futures`, используемого
во всей экосистеме.

Давайте рассмотрим определения черт `Iterator` и `Future`, прежде чем
рассмотреть, как сущность `Stream` может объединить их вместе. Из `Iterator` у нас
есть идея последовательности: его способ `next` предоставляет `Option<Self::Item>`.
Из `Future` у нас есть идея готовности с течением времени: его способ `poll`
предоставляет `Poll<Self::Output>`. Чтобы представить последовательность элементов, которые становятся готовыми с течением времени, мы определяем сущность `Stream`, которая объединяет эти характеристики:

```rust
use std::pin::Pin;
use std::task::{Context, Poll};

trait Stream {
    type Item;

    fn poll_next(
        self: Pin<&mut Self>,
        cx: &mut Context<'_>
    ) -> Poll<Option<Self::Item>>;
}
```

Черта `Stream` определяет связанный вид, называемый `Item`, для вида
элементов, производимых потоком. Это похоже на `Iterator`, где может быть от нуля до множества элементов, и в отличие от `Future`, где всегда есть один `Output`, даже если это разновидность единицы `()`.

`Stream` также определяет способ для получения этих элементов. Мы называем его `poll_next`, чтобы
понять, что он опрашивает так же, как `Future::poll`, и
производит последовательность элементов так же, как `Iterator::next`. Его возвращаемый вид
объединяет `Poll` с `Option`. Внешний вид - `Poll`,
потому что его нужно проверить на готовность, как это делает future. Внутренний вид - `Option`,
потому что ему нужно сообщить, есть ли еще сообщения, как это делает повторитель.

Что-то очень похожее на это определение, скорее всего, окажется частью стандартной библиотеки Ржавчина. В то же время, это часть средств большинства сред выполнения, поэтому
вы можете положиться на него, и все, что мы рассмотрим далее, должно в целом применяться!

В примере, который мы видели в разделе о потоковой передаче, мы не использовали
`poll_next` _или_ `Stream`, а вместо этого использовали `next` и `StreamExt`. Мы _могли_
работать напрямую с API `poll_next`, вручную написав наши собственные машины состояний `Stream`, конечно, так же, как мы _могли_ работать с будущими событиями напрямую через
их способ `poll`. Однако использование `await` гораздо приятнее, и свойство `StreamExt`
предоставляет способ `next`, поэтому мы можем сделать именно это:

```rust
{{#rustdoc_include ../listings/ch17-async-await/no-listing-stream-ext/src/lib.rs:here}}
```

<!--
TODO: update this if/when tokio/etc. update their MSRV and switch to using async functions
in traits, since the lack thereof is the reason they do not yet have this.
-->

> Примечание: Фактическое определение, которое мы использовали ранее в этой главе, выглядит немного
> иначе, чем это, поскольку оно поддерживает исполнения Ржавчина, которые еще
> не поддерживали использование несогласованных функций в видажах. В итоге оно выглядит так:
>
> ```rust,ignore
> fn next(&mut self) -> Next<'_, Self> где Self: Unpin;
> ```
>
> Этот вид `Next` является `struct`, которая использует `Future` и позволяет нам называть
> время жизни ссылки на `self` с помощью `Next<'_, Self>`, так что `await`
> может работать с этим способом.

Черта `StreamExt` также является домом для всех интересных способов, доступных
для использования с потоками. `StreamExt` автоматически используется для каждого вида,
который использует `Stream`, но эти сущности определяются отдельно, чтобы позволить
сообществу итерировать удобные API, не затрагивая основную сущность.

В исполнения `StreamExt`, используемой в дополнении `trpl`, сущность не только
определяет способ `next`, но и предоставляет реализацию по умолчанию `next`,
которая правильно обрабатывает детали вызова `Stream::poll_next`. Это означает,
что даже когда вам нужно написать свой собственный вид потоковых данных, вам _только_ нужно
воплотить `Stream`, и тогда любой, кто использует ваш вид данных, сможет использовать `StreamExt` и его способы с ним автоматически.

Это все, что мы собираемся рассмотреть для более низкоуровневых деталей этих черт. В заключение давайте рассмотрим, как фьючерсы (включая потоки), задачи и потоки
сочетаются друг с другом!

[ch-18]: ch18-00-oop.html
[async-book]: https://rust-lang.github.io/async-book/
[under-the-hood]: https://rust-lang.github.io/async-book/02_execution/01_chapter.html
[pinning]: https://rust-lang.github.io/async-book/04_pinning/01_chapter.html
[first-async]: ch17-01-futures-and-syntax.html#our-first-async-program
[any-number-futures]: ch17-03-more-futures.html#working-with-any-number-of-futures
