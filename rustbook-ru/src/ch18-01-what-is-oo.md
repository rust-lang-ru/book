## Свойства предметно-направленных языков

В сообществе разработчиков ПО нет единого мнения о том, какими свойствами должен обладать язык, чтобы считаться предметно-направленным. На Ржавчину повлияли многие воззрения и подходы программирования, включая ООП - например, в главе 13 мы изучали сущности, пришедшие из функционального программирования. Однозначно можно утверждать, что ООП-языкам соответствуют следующие сущности: предметы, сокрытие (инкапсуляция) и наследование. Давайте рассмотрим, что каждая сущность из них означает и поддерживает ли их Ржавчина.

### Предметы содержат данные и поведение

Книга *Приёмы предметно-направленной разработки. Образцы разработки* Erich Gamma, Richard Helm, Ralph Johnson, и John Vlissides (Addison-Wesley Professional, 1994), в просторечии называемая *Книга банды четырёх*, представляет собой сборник примеров предметно-направленной разработки. В ней даётся следующее определение ООП:

> Предметно-направленные приложения состоят из предметов. *Предмет* представляет собой сущность, своего рода дополнение, с данными и процедурами, которые работают с этими данными. Процедуры обычно называются *способами* или *действиями*.

В соответствии с этим определением Ржавчина является предметно-направленным языком - в стопках и перечислениях содержатся данные, а в х `impl` определяются способами и действия для них. Хотя стопки и перечисления, имеющие способы и действия, не *называются* предметами, они обеспечивают  возможность, соответствующую определению предметов в книге банды четырёх.

### Сокрытие (инкапсуляция) подробностей исполнения

Другой особенностью, обычно связанной с предметно-направленным программированием, является мысль *сокрытия (инкапсуляции)*: подробности выполнения предмета недоступны для рукописи, использующей этот предмет. Единственный способ взаимодействия с предметом — через его открытую внешнюю оболочку; рукопись, использующая этот предмет, не должна иметь возможности взаимодействовать с внутренними свойствами предметами напрямую изменять его данные или поведение. Сокрытие (инкапсуляция) позволяет изменять и пересоздавать внутренние свойства предмета без необходимости изменять саму рукопись, которая использует предмет.

В главе 7 мы уже говорили о том, как управлять сокрытием (инкапсуляцией): мы можем использовать ключевое слово `pub`, чтобы определить, какие разделы, виды данных, способы (функции) и другое содержимое в нашей рукописи будут открытым, а всё остальное по умолчанию будет закрытым (частным). Например, мы можем определить стопку `AveragedCollection`, в которой есть поле, содержащее вектор значений вида данных `i32`. Также, стопка будет иметь поле, содержащее среднее арифметическое чисел этого вектора, таким образом, среднее не нужно будет вычислять каждый раз, когда оно кому-то понадобится. Другими словами, `AveragedCollection` будет кэшировать вычисленное среднее для нас. В приложении 17-1 приведено определение стопки `AveragedCollection`:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-17-01/src/lib.rs}}
```

<span class="caption">Приложение 17-1: Стопка <code>AveragedCollection</code> содержит список целых чисел и их среднее арифметическое.</span>

Обратите внимание, что стопка помечена ключевым словом `pub`, что позволяет другому рукописи её использовать, однако, поля стопки остаются недоступными. Это важно, потому что мы хотим обеспечить обновление среднего значения при добавлении или удалении переменной из списка. Мы можем получить нужное поведение, определив в стопке способов `add`, `remove` и `average`, как показано в примере 17-2:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-17-02/src/lib.rs:here}}
```

<span class="caption">Приложение 17-2: Выполнение открытых способов <code>add</code>,<code>remove</code>, и <code>average</code> для <code>AveragedCollection</code></span>

Открытые способы `add`, `remove` и `average` являются единственным способом получить или изменить данные в образце `AveragedCollection`. Когда переменная добавляется в `список` способом `add`, или удаляется с помощью способа `remove`, рукопись выполнения каждого из этих способов вызывает закрытый способ `update_average`, который позаботится об обновлении поля `average`.

Мы оставляем поля `список` и `average` закрытыми, чтобы внешняя рукопись не могла добавлять или удалять переменные непосредственно в поле `список`; в противном случае поле `average` может оказаться не согласовано при подобном вмешательстве. Способ `average` возвращает значение в поле `average`, что позволяет внешней рукописи читать значение `average`, но не изменять его.

Поскольку мы скрыли (использовали инкапсуляцию) подробностей исполнения стопки `AveragedCollection`, мы можем легко изменить такие особенности, как вида данных, в будущем. Например, мы могли бы использовать `HashSet<i32>` вместо `Vec<i32>` для поля `список`. Благодаря тому, что ярлыки открытых способов `add`, `remove` и `average` остаются неизменными, рукопись, использующая `AveragedCollection`, также не будет нуждаться в изменении. У нас бы не получилось этого достичь, если бы мы сделали поле `список` доступным внешней рукописи: `HashSet<i32>` и`Vec<i32>` имеют разные способы для добавления и удаления переменных, поэтому внешняя рукопись, вероятно, должна измениться, если она изменяет `список` напрямую.

Если сокрытие (инкапсуляция) является обязательным требованием для определения языка как предметно-направленного, то Ржавчина соответствует этому требованию. Возможность использовать или не использовать изменитель доступа `pub` для различных частей рукописи позволяет скрыть подробности выполнения.

### Наследование как перечень видов данных и способ совместного использования рукописи

*Наследование* — это рычаг, с помощью которого предмет может унаследовать переменные из определения другого предмета. то есть получить данные и поведение родительского предмета без необходимости повторно их определять.

Если язык должен иметь наследование, чтобы быть предметно-направленным, то Ржавчина таким не является. Здесь нет способа определить вид данных, наследующий поля и выполнения способов родительского вид данных, без использования макроса.

Однако, если вы привыкли иметь наследование в своём наборе средств для программирования, вы можете использовать другие решения в Ржавчине, в зависимости от того, по какой причине вы изначально хотите использовать наследование.

Вы могли бы выбрать наследование по двум основным причинам. Одна из них - возможность повторного использования рукописи: вы можете использовать определённое поведение для одного вида данных, а наследование позволит вам повторно использовать эту выполнение для другого вида данных. В Ржавчине для этого есть ограниченный способ, использующий использование способа сущности по умолчанию, который вы видели в приложении 10-14, когда мы добавили выполнение по умолчанию в способе `подвести_итог` сущности `КраткоеСодержание`. Любой вид данных, использующий свойство `КраткоеСодержание` будет иметь доступный способ `подвести_итог` без дополнительного рукописи. Это похоже на то, как родительский предмет имеет использование способа, и предмет-наследник тоже имеет использование способа. Мы также можем переопределить выполнение по умолчанию для способа `подвести_итог`, когда используем сущность `КраткоеСодержание`, что похоже на дочерний предмет, переопределяющий использование способа, унаследованного от родительского предмета.

Вторая причина использования наследования относится к перечню видов данных: чтобы иметь возможность использовать дочерний вид данных в тех же места, что и родительский. Эта возможность также называется *полиморфизм* и означает возможность подменять предметы во время исполнения, если они имеют одинаковые свойства.

> ### Полиморфизм
>
> Для многих людей полиморфизм является родственным наследования. Но на самом деле это более общий подход, относящаяся к рукописи, которая может работать с данными нескольких видов данных. Обычно такими видами данных выступают подпредметы при наследовании.
>
> Вместо этого Ржавчина использует обобщённые виды данных для абстрагирования от видов данных, и ограничения сущностей (trait bounds) для указания того, какие возможности эти виды данных должны предоставлять. Это иногда называют *ограниченным присущем только ему полиморфизмом*.

Наследование, как подход к разработке, в последнее время утратило распространенность во многих языках программирования, поскольку часто существует риск, что мы будем наследовать рукопись чаще, чем это необходимо. Подпредметы не всегда должны обладать всеми свойствами родительского предмета, но при использовании наследования другого исхода нет. Это может сделать внешний вид приложения менее гибким. Кроме этого, появляется возможность вызова у подпредметов способов, которые не имеют смысла или вызывают ошибки, потому что эти способы неприменимы к подпредмету. Кроме того, в некоторых языках разрешается только одиночное наследование (т.е. подпредмет может наследоваться только от одного предмета), что ещё больше ограничивает гибкость разработки приложения.

По этим причинам в Ржавчине применяется иной подход, с использованием сущностей-предметов вместо наследования. Давайте посмотрим как сущности-предметы выполняют полиморфизм в Ржавчине.
