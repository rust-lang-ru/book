## Применение одновременности с помощью несогласованности

<!-- Old headings. Do not remove or links may break. -->

<a id="concurrency-with-async"></a>

В этом разделе мы применим несогласованность к некоторым из тех же проблем одновременности, которые мы решали с помощью потоков в главе 16. 
Поскольку мы уже говорили о многих ключевых идеях там, в этом разделе мы сосредоточимся на том, чем отличаются
потоки и фьючерсы.

Во многих случаях API для работы с одновременностью с использованием несогласованности очень
похожи на API для использования потоков. В других случаях они оказываются совсем
другими. Даже когда API потоков и несогласованности _выглядят_ похожими, они
часто ведут себя по-разному — и почти всегда имеют разные
характеристики производительности.

<!-- Old headings. Do not remove or links may break. -->

<a id="counting"></a>

### Создание новой задачи с помощью `spawn_task`

Первая действие, которую мы рассмотрели в [Создание нового потока с помощью
Spawn][thread-spawn]<!-- ignore -->, заключалась в подсчете двух отдельных потоков.
Давайте сделаем то же самое с помощью async. Контейнер `trpl` предоставляет функцию `spawn_task`,
которая очень похожа на API `thread::spawn`, и функцию `sleep`,
которая является несогласованной исполнением API `thread::sleep`. Мы можем использовать их вместе,
чтобы воплотить пример подсчета, как показано в приложении 17-6.

<Listing number="17-6" caption="Создание новой задачи для печати чего-то одного, пока основная задача печатает что-то другое" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-06/src/main.rs:all}}
```

</Listing>

В качестве отправной точки мы настраиваем нашу функцию `main` с `trpl::run`, чтобы
наша функция верхнего уровня могла быть несогласованной.

> Примечание: начиная с этого момента в главе каждый пример будет включать этот
> точно такой же код оборачивания с `trpl::run` в `main`, поэтому мы часто будем его пропускать,
> как и с `main`. Не забудьте включить его в свой код!

Затем мы пишем два круговорота внутри этого блока, каждый из которых содержит вызов `trpl::sleep`,
который ждет полсекунды (500 миллисекунд) перед отправкой следующего
сообщения. Мы помещаем один цикл в тело `trpl::spawn_task`, а другой в цикл `for` верхнего уровня. Мы также добавляем `await` после вызовов `sleep`.

Этот код ведет себя аналогично реализации на основе потоков, включая то обстоятельство, что вы можете увидеть, что сообщения появляются 
в другом порядке в вашем собственном терминале, когда вы его запускаете:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
Число 1 вызвано как второстепенная задача!
Число 1 вызвано как главная задача!
Число 2 вызвано как главная задача!
Число 2 вызвано как второстепенная задача!
Число 3 вызвано как главная задача!
Число 3 вызвано как второстепенная задача!
Число 4 вызвано как главная задача!
Число 4 вызвано как второстепенная задача!
Число 5 вызвано как главная задача!
```

Это исполнение останавливается, как только цикл `for` в теле основного несогласованного блока
завершается, потому что задача, порожденная `spawn_task`,
завершается, когда функция `main`
завершается. Если вы хотите, чтобы она работала до завершения задачи, вам
нужно будет использовать дескриптор соединения, чтобы дождаться завершения первой задачи. С потоками мы использовали способ `join`, 
чтобы «блокировать», пока поток не завершит работу.
В приложении 17-7 мы можем использовать `await`, чтобы сделать то же самое, потому что сам дескриптор задачи
является будущим. Его вид `Output` является `Result`, поэтому мы также разворачиваем его
после ожидания.

<Listing number="17-7" caption="Использование `await` с дескриптором соединения для запуска задачи до завершения" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-07/src/main.rs:handle}}
```

</Listing>

Это обновленное исполнение работает до тех пор, пока не завершатся _оба_ круговорота.

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
Число 1 вызвано как второстепенная задача!
Число 1 вызвано как главная задача!
Число 2 вызвано как главная задача!
Число 2 вызвано как второстепенная задача!
Число 3 вызвано как главная задача!
Число 3 вызвано как второстепенная задача!
Число 4 вызвано как главная задача!
Число 4 вызвано как второстепенная задача!
Число 5 вызвано как главная задача!
Число 6 вызвано как главная задача!
Число 7 вызвано как главная задача!
Число 8 вызвано как главная задача!
Число 9 вызвано как главная задача!
```

Пока что похоже, что несогласованность и потоки дают нам одинаковые базовые итоги, просто
с разными правилами написания: использование `await` вместо вызова `join` на дескрипторе соединения и ожидание вызовов `sleep`.

Большая разница в том, что нам не нужно было порождать еще один поток операционной системы, чтобы сделать это. Фактически, нам даже не нужно порождать задачу здесь. Поскольку
несогласованные блоки компилируются в безымянные будущие, мы можем поместить каждый цикл в несогласованный
раздел и заставить среду выполнения выполнить их оба до завершения с помощью функции `trpl::join`
.

В разделе [Ожидание завершения всех потоков с использованием `join`
Handles][join-handles]<!-- ignore --> мы показали, как использовать способ `join` для вида `JoinHandle`, возвращаемого при вызове `std::thread::spawn`. Функция `trpl::join` похожа, но для фьючерсов. Когда вы передаете ей два фьючерса,
она создает один новый фьючерс, выход которого представляет собой кортеж, содержащий выход
каждого переданного вами фьючерса, как только они _оба_ завершатся. Таким образом, в приложении 17-8 мы
используем `trpl::join` для ожидания завершения `fut1` и `fut2`. Мы _не_ ждем `fut1` и `fut2`, а вместо этого ждем новый фьючерс, созданный `trpl::join`. Мы игнорируем
выход, потому что это просто кортеж, содержащий два значения единиц.

<Listing number="17-8" caption="Используя `trpl::join` ожидание await двух безымянных futures" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-08/src/main.rs:join}}
```

</Listing>

При запуске мы видим, что оба фьючерса выполняются до завершения:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
Число 1 вызвано как главная задача!
Число 1 вызвано как второстепенная задача!
Число 2 вызвано как главная задача!
Число 2 вызвано как второстепенная задача!
Число 3 вызвано как главная задача!
Число 3 вызвано как второстепенная задача!
Число 4 вызвано как главная задача!
Число 4 вызвано как второстепенная задача!
Число 5 вызвано как главная задача!
Число 6 вызвано как главная задача!
Число 7 вызвано как главная задача!
Число 8 вызвано как главная задача!
Число 9 вызвано как главная задача!
```

Теперь вы увидите один и тот же порядок каждый раз, что сильно отличается от того, что мы видели с потоками. Это потому, что функция `trpl::join` является _честной_,
то есть она проверяет каждое будущее одинаково часто, чередуя их, и никогда
не позволяет одному вырваться вперед, если другой готов. С потоками операционная система
решает, какой поток проверять и как долго ему позволять работать. С несогласованным Ржавчина
среда выполнения решает, какую задачу проверять. (На практике детали усложняются,
потому что несогласованная среда выполнения может использовать потоки операционной системы под капотом как часть того,
как она управляет одновременностью, поэтому обеспечение справедливости может быть более
трудным для среды выполнения — но это все еще возможно!) Среды выполнения не должны гарантировать
честность для любой заданной действия, и они часто предлагают разные API,
чтобы позволить вам выбрать, нужна ли вам справедливость.

Попробуйте некоторые из этих вариантов ожидания будущего и посмотрите, что они делают:

- Удалите несогласованный раздел вокруг одного или обоих круговоротов.
- Ожидайте каждый несогласованный раздел сразу после его определения.
- Оберните только первый цикл в несогласованный раздел и ожидайте полученное будущее
после тела второго круговорота.

Для дополнительной сложности попробуйте выяснить, какой будет вывод в каждом случае _до_ запуска рукописи!

<!-- Old headings. Do not remove or links may break. -->

<a id="передача сообщений"></a>

### Подсчет двух задач с использованием передачи сообщений

Обмен данными между фьючерсами также будет знаком: мы снова воспользуемся передачей сообщений, но на этот раз с несогласованными исполнениями видов и функций. Мы пойдем немного другим путем, чем в [Использование передачи сообщений для передачи данных
между потоками][message-passing-threads]<!-- ignore -->, чтобы проиллюстрировать некоторые из
ключевых различий между одновременностью на основе потоков и фьючерсов. В
Приложении 17-9 мы начнем всего с одного несогласованного раздела — _не_ порождая
отдельную задачу, поскольку мы породили отдельный поток.

<Listing number="17-9" caption="Создание несогласованного канала и назначение двух его половин `tx` и `rx`" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-09/src/main.rs:channel}}
```

</Listing>

Здесь мы используем `trpl::channel`, несогласованную исполнение API с несколькими производителями и одним потребителем, которую мы использовали с потоками в Главе 16. Несогласованное
исполнение API лишь немного отличается от исполнения на основе потоков: она
использует изменяемый, а не неизменяемый получатель `rx`, а ее способ `recv`
создает будущее, которое нам нужно ожидать, а не производить значение напрямую. Теперь
мы можем отправлять сообщения от отправителя получателю. Обратите внимание, что нам не нужно
создавать отдельный поток или даже задачу; нам просто нужно дождаться вызова `rx.recv`.

Синхронный способ `Receiver::recv` в `std::mpsc::channel` блокируется, пока не получит сообщение. Метод `trpl::Receiver::recv` этого не делает, потому что он
несогласованный. Вместо блокировки он возвращает управление среде выполнения до тех пор, пока не будет получено сообщение или не закроется сторона отправки канала. Напротив, мы не ждем вызова `send`, потому что он не блокируется. Это не нужно,
потому что канал, в который мы его отправляем, не ограничен.

> Примечание: поскольку весь этот несогласованный код выполняется в несогласованном блоке в вызове `trpl::run`
>, все внутри него может избежать блокировки. Однако код _вне_ него
> будет блокироваться при возврате функции `run`. В этом весь смысл функции `trpl::run`: она позволяет вам _выбирать_, где блокировать некоторый набор несогласованного
> рукописи, и, таким образом, где переходить между согласованным и несогласованным кодом. В большинстве несогласованных
> сред выполнения `run` на самом деле называется `block_on` именно по этой причине.

Обратите внимание на две вещи в этом примере. Во-первых, сообщение придет немедленно.
Во-вторых, хотя мы используем здесь future, пока нет одновременности. Все
в приложении происходит последовательно, как если бы не было future.

Давайте рассмотрим первую часть, отправив последовательность сообщений и уснув между ними, как показано в приложении 17-10.

<!-- We cannot test this one because it never stops! -->

<Listing number="17-10" caption="Отправка и получение нескольких сообщений по несогласованному каналу и сон с `await` между каждым сообщением" file-name="src/main.rs">

```rust,ignore
{{#rustdoc_include ../listings/ch17-async-await/listing-17-10/src/main.rs:many-messages}}
```

</Listing>

Помимо отправки сообщений, нам нужно их получать. В этом случае,
поскольку мы знаем, сколько сообщений поступает, мы могли бы сделать это вручную,
вызвав `rx.recv().await` четыре раза. Однако в реальном мире мы обычно
будем ждать некоторого _неизвестного_ количества сообщений, поэтому нам нужно продолжать ждать,
пока не определим, что сообщений больше нет.

В приложении 16-10 мы использовали цикл `for` для обработки всех элементов,
полученных из согласованного канала. Однако в Ржавчине пока нет способа написать цикл `for` для
_несогласованной_ последовательности элементов, поэтому нам нужно использовать цикл, который мы
раньше не видели: условный цикл `while let`. Это замкнутое исполнение конструкции `if let`, которую мы видели в разделе [Краткий поток управления с `if
let` и `let else`][if-let]<!-- ignore -->. Цикл будет продолжать выполняться до тех пор, пока заданный им шаблон будет соответствовать значению.

Вызов `rx.recv` создает future, который мы ожидаем. Среда выполнения приостановит
future, пока он не будет готов. Как только придет сообщение, future будет разрешен в `Some(message)` столько раз, сколько придет сообщение. Когда канал закрывается,
независимо от того, поступили ли _какие-либо_ сообщения, future будет вместо этого разрешен в `None`, чтобы указать, что больше нет значений, и поэтому нам следует
прекратить опрос, то есть прекратить ожидание.

Цикл `while let` объединяет все это. Если итогом вызова `rx.recv().await` является `Some(message)`, мы получаем доступ к сообщению и можем
использовать его в теле круговорота, как и с `if let`. Если итогом является `None`, цикл заканчивается. Каждый раз, когда цикл завершается, он снова достигает точки ожидания, поэтому среда выполнения снова приостанавливает его до тех пор, пока не придет следующее сообщение.

Теперь код успешно отправляет и получает все сообщения. К сожалению,
есть еще пара проблем. Во-первых, сообщения не приходят с интервалом в полсекунды. Они приходят все сразу, через 2 секунды (2000
миллисекунд) после запуска программы. Во-вторых, эта программа никогда не завершается!
Вместо этого она вечно ждет новых сообщений. Вам нужно будет завершить ее с помощью
<span class="keystroke">ctrl-c</span>.

Начнем с изучения того, почему сообщения приходят все сразу после полной
задержки, а не приходят с задержками между каждым. В заданном несогласованном
блоке порядок, в котором ключевые слова `await` появляются в рукописье, также является порядком, в котором они выполняются при запуске программы.

В приложении 17-10 есть только один несогласованный блок, поэтому все в нем выполняется
линейно. По-прежнему нет одновременности. Все вызовы `tx.send` происходят,
перемежаясь со всеми вызовами `trpl::sleep` и связанными с ними точками ожидания. Только тогда цикл `while let` может пройти через все точки `await`
в вызовах `recv`.

Чтобы получить желаемое поведение, когда задержка сна происходит между каждым сообщением,
нам нужно поместить действия `tx` и `rx` в их собственные несогласованные блоки, как показано
в приложении 17-11. Затем среда выполнения может выполнить каждую из них отдельно, используя `trpl::join`, как в примере с подсчетом. И снова мы ждем итог
вызова `trpl::join`, а не отдельные фьючерсы. Если бы мы ждали
отдельных будущих событий последовательно, мы бы просто вернулись в последовательный
поток — именно то, чего мы пытаемся _не_ делать.

<!-- We cannot test this one because it never stops! -->

<Listing number="17-11" caption="Разделение `send` и `recv` на отдельные `async` блоки и ожидание будущих событий для этих разделов" file-name="src/main.rs">

```rust,ignore
{{#rustdoc_include ../listings/ch17-async-await/listing-17-11/src/main.rs:futures}}
```

</Listing>

С обновленным кодом в приложении 17-11 сообщения выводятся с интервалом в 500 миллисекунд, а не все в спешке через 2 секунды.

Однако программа по-прежнему никогда не завершается из-за способа взаимодействия круговорота `while let` с `trpl::join`:

- Future, возвращаемый из `trpl::join`, завершается только после завершения _обе_ futures,переданных ему.
- Future `tx` завершается после завершения сна после отправки последнего сообщения в `vals`.
- Future `rx` не завершится, пока не закончится цикл `while let`.
- Цикл `while let` не завершится, пока ожидание `rx.recv` не вернет `None`.
- Ожидание `rx.recv` вернет `None` только после закрытия другого конца канала.
Канал закроется, только если мы вызовем `rx.close` или когда сторона-отправитель,
`tx`, будет удалена.- Мы нигде не вызываем `rx.close`, и `tx` не будет удален, пока не закончится
внешний несогласованный блок, переданный `trpl::run`.
- Блок не может закончиться, поскольку он блокируется при завершении `trpl::join`, что возвращает нас к началу этого списка.

Мы могли бы вручную закрыть `rx`, вызвав `rx.close` где-нибудь, но это не имеет особого смысла. Остановка после обработки произвольного количества сообщений
заставит программу завершить работу, но мы можем пропустить сообщения. Нам нужен какой-то другой способ,
чтобы убедиться, что `tx` будет удален _до_ конца функции.

Прямо сейчас несогласованный блок, в который мы отправляем сообщения, заимствует только `tx`,
потому что отправка сообщения не требует владения, но если бы мы могли переместить `tx` в этот
несогласованный блок, он был бы удален, как только этот раздел закончится. В разделе Главы 13
[Получение ссылок или перемещение владения][capture-or-move]<!-- ignore --> вы
узнали, как использовать ключевое слово `move` с замыканиями, и, как обсуждалось в разделе
Главы 16 [Использование замыканий `move` с потоками][move-threads]<!-- ignore
-->, нам часто нужно перемещать данные в замыкания при работе с потоками.
Та же основная динамика применяется к несогласованным блокам, поэтому ключевое слово `move` работает с несогласованными блоками так же, как и с замыканиями.

В приложении 17-12 мы меняем блок, используемый для отправки сообщений, с `async` на
`async move`. Когда мы запускаем _эту_ исполнение рукописи, она корректно завершает работу
после отправки и получения последнего сообщения.

<Listing number="17-12" caption="Пересмотр рукописи из приложения 17-11, который корректно завершает работу после завершения" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-12/src/main.rs:with-move}}
```

</Listing>

Этот несогласованный канал также является каналом с несколькими производителями, поэтому мы можем вызвать `clone`
на `tx`, если мы хотим отправлять сообщения из нескольких будущих событий, как показано в приложении
17-13.

<Listing number="17-13" caption="Использование нескольких производителей с несогласованными блоками" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-13/src/main.rs:here}}
```

</Listing>

Сначала мы клонируем `tx`, создавая `tx1` вне первого несогласованного блока. Мы перемещаем
`tx1` в этот раздел так же, как мы делали это раньше с `tx`. Затем, позже, мы перемещаем
исходный `tx` в _новый_ несогласованный блок, где мы отправляем больше сообщений с
немного меньшей задержкой. Мы случайно помещаем этот новый несогласованный раздел после несогласованного
раздела для получения сообщений, но он мог бы идти и перед ним. Ключевым является
порядок, в котором ожидаются фьючерсы, а не порядок, в котором они создаются.

Оба несогласованных раздела для отправки сообщений должны быть блоками `async move`,
чтобы и `tx`, и `tx1` были удалены, когда эти блоки закончатся. В противном случае мы
вернемся в тот же бесконечный цикл, с которого начали. Наконец, мы переключаемся с
`trpl::join` на `trpl::join3`, чтобы обработать дополнительный фьючерс.

Теперь мы видим все сообщения от обоих отправляющих фьючерсов, и поскольку отправляющие фьючерсы используют немного разные задержки после отправки, 
сообщения также принимаются с этими разными интервалами.

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
received 'hi'
received 'more'
received 'from'
received 'the'
received 'messages'
received 'future'
received 'for'
received 'you'
```

Это хорошее начало, но оно ограничивает нас всего несколькими будущими вариантами: двумя с `join` или тремя с `join3`. 
Давайте посмотрим, как мы можем работать с большим количеством будущих вариантов.

[thread-spawn]: ch16-01-threads.html#creating-a-new-thread-with-spawn
[join-handles]: ch16-01-threads.html#waiting-for-all-threads-to-finish-using-join-handles
[message-passing-threads]: ch16-02-message-passing.html
[if-let]: ch06-03-if-let.html
[capture-or-move]: ch13-01-closures.html#capturing-references-or-moving-ownership
[move-threads]: ch16-01-threads.html#using-move-closures-with-threads
