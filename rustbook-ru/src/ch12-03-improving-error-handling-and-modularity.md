## Переработка рукописи для с целью выделения на разделы и возможности обработки ошибок

Для улучшения приложения мы исправим 4 имеющихся сбоя, связанных с устройством приложения и тем как обрабатываются вероятные ошибки. Во-первых, функция `main` на данное мгновение решает две задачи:  рассматривает переменные приказной строки и считывает файлы. По мере роста приложения будет увеличиваться количество отдельных задач, которые обрабатывает функция `main`, будет увеличиваться. Поскольку эта функция исполняет больше действий, то становится все труднее понимать её, труднее проверять и труднее изменять, не сломав одну из её частей. Лучше всего разделить её на разделы, чтобы каждая функция отвечала за одну задачу.

Эта неполадка также связана со второй неполадкой: хотя переменные `query` и `file_path` являются заданными значениями при запуске нашей приложения, переменная `contents` вида данных `String` используются хранения содержимого считываемого файла. Чем длиннее становится `main`, тем больше переменных нам нужно будет добавить в область видимости. Чем больше у нас переменных в области видимости, тем сложнее будет отслеживать назначение каждой переменной. Лучше всего объединять переменные настройки в одну `стопку`, чтобы сделать их назначение понятным.

Третья неполадка заключается в том, что мы используем `expect` для вывода сведений об ошибке при неполадке с чтением файла, но сообщение об ошибке просто выведет сообщение `Файл не доступен для чтения`. Чтение файла может не сработать по разным причинам, например: 1)файл не найден; 2)нет разрешения на его чтение. Сейчас же, независимо от причины ошибки, будет выведено сообщение по умолчанию, в котором нет никаких подробностей для пользователя - какая именно причина ошибки!

В-четвёртых, мы используем `expect` неоднократно для обработки различных ошибок и если пользователь запускает нашу программу без указания достаточного количества переменных он получит ошибку `index out of bounds` из Ржавчины, что не совсем понятно описывает неполадку. Было бы лучше, если бы вся рукопись обработки ошибок находилась в одном месте, чтобы тем, кто будет поддерживать нашу рукопись в дальнейшем, нужно было бы вносить изменения только здесь, если потребуется изменить ход мыслей обработки ошибок. Наличие всей рукописи обработки ошибок в одном месте заверяет, что мы выведем сообщения, которые будут иметь смысл для наших конечных пользователей.

Давайте решим эти четыре сбоя путём переработки рукописи нашего дела.

### <a name="separation-of-concerns-for-binary-projects"></a>Разделение ответственности для двоичных дел

Внутренняя неполадка распределения ответственности за выполнение нескольких задач функции `main`  является общей для многих двоичных дел. В итоге  сообщество Ржавчины разработало этап для использования в качестве руководства по разделению ответственности двоичной приложения, когда рукопись в `main` начинает увеличиваться. Этап имеет следующие шаги:

- Разделите рукопись приложения на два файла *main.rs* и *lib.rs*. Перенесите все действия работы приложения в файл *lib.rs*.
- Пока ваши знания правил написания оценки приказной строки находятся на начальном уровне, вся рукопись может оставаться в файле *main.rs*.
- Когда ход мыслей согласно правил написания оценки приказной строки становится сложным, извлеките её из *main.rs* и переместите в *lib.rs.*

Необходимые действия, которые остаются в функции `main` после этого этапа должно быть ограничено следующими:

- Вызов приказной строки со значениями переменных
- Определение всех настроек
- Вызов функции `run` в *lib.rs*
- Обработка ошибки, если `run` возвращает ошибку

Этот образец о разделении ответственности: *main.rs* занимается запуском приложения, а *lib.rs* обрабатывает все остальные этапы поставленной задачи. Поскольку нельзя проверить функцию `main` напрямую, то такое устройство позволяет проверить все этапы приложения путём перемещения её в функции внутри *lib.rs*. Единственная рукопись, которая остаётся в *main.rs* будет достаточно маленькой, чтобы проверить ее на предмет соблюдение правил, прочитав рукопись. Давайте переработаем нашу программу, следуя этому подходу.

#### Извлечение обработчика переменных

Мы выделим действия по получению переменных в функцию, которую вызовет `main` для подготовки к перемещению значений, полученных из приказной строки в файл *src/lib.rs*. Приложение 12-5 показывает новый запуск `main`, который вызывает новую функцию `parse_config`, которую мы определим сначала в *src/main.rs.*

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-05/src/main.rs:here}}
```

<span class="caption">Приложение 12-5: Выделение функции <code>parse_config</code> из <code>main</code></span>

Мы все ещё собираем переменные приказной строки в вектор, но вместо присваивания значение переменной с порядковым указателем 1 переменной `query` и значение переменной с порядковым указателем 2 переменной с именем `file_path` в функции `main`, мы передаём весь вектор в функцию `parse_config`. Функция `parse_config` затем определяет следующее: какой переменной присваивается указатель на тот или иной этаж `Vec<String>` с дальнейшей передачей значений обратно в `main` в виде составного ряда. Мы все ещё создаём переменные `query` и `file_path` в `main`, но `main` больше не определяет напрямую значения, полученные из приказной строки.

Эта доработка может показаться излишней для нашей маленькой приложения, но мы проводим переработку рукописи небольшими, постепенными шагами. После внесения этого изменения снова запустите программу и убедитесь, что получение и определение переменных все ещё работает. Важно часто и тщательно проверять все этапы, чтобы помочь определить причину неполадок. когда они возникают.

#### Объединение настроечных переменных

Мы можем сделать ещё один маленький шаг для улучшения функции `parse_config`. На данное мгновение мы возвращаем составной ряд, но затем мы немедленно разделяем его снова на отдельные части. Это признак того, что, возможно,  пока у нас нет правильного представления и знаний.

Ещё один показатель, который явно указывает, что есть место для улучшения, это часть `config` из `parse_config`, что подразумевает, что два значения, которые мы возвращаем, связаны друг с другом и оба являются частью одного настроечного значения. В настоящее время мы не отражаем этого смысла в стопке данных, кроме объединения двух значений в составной ряд; мы могли бы поместить оба значения в один вид данных - стопку и дать каждому из полей стопки понятное имя. Это облегчит будущую поддержку этой рукописи, чтобы понять, как различные значения относятся друг к другу и какое их назначение.

В приложении 12-6 показаны улучшения функции `parse_config` .

<span class="filename">Файл: src/main.rs</span>

```rust,should_panic,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-06/src/main.rs:here}}
```

<span class="caption">Приложение 12-6: Переработка рукописи функции <code>parse_config</code>, чтобы возвращать образец данных стопки <code>Config</code></span>

Мы добавили стопку с именем `Config` объявленную с полями назваными как `query` и `file_path`. Ярлык на функцию `parse_config` теперь указывает, что она возвращает значение в виде стопки `Config`. В теле `parse_config`, где мы возвращали срезы строк, которые ссылаются на значения `String` в `args`, теперь мы определяем `Config` как содержащие `String` значения без ссылок. Переменная `args` в `main` является владельцем значений и позволяют функции `parse_config` только одалживать их без права владения, что означает, что мы бы нарушили правила заимствования Ржавчины, если бы `Config` попытался бы взять во владение значения из `args` .

Мы можем владеть видом данных `String` разным количеством способов, но самый простой, хотя и отчасти неразумный это способ `clone`. Он сделает полный повтор данных для образца `Config` с целью владения, что занимает больше времени и памяти, чем сохранение ссылки на строку данных. Однако удваивание данных также делает нашу рукопись очень простой, потому что нам не нужно управлять временем жизни ссылок; в этом обстоятельстве, отказ от небольшой производительности, чтобы получить простоту, стоит небольших соглашений.

> ### Использование способа `clone`
> Существует установка в среде разработчиков ПО Ржавчины избегать использования `clone`, т.к. это понижает производительность работы рукописи. В [главе 13]<!-- ignore --> , вы изучите более производительные способы, 
> которые могут подойти в подобном случае. Но сейчас можно воспроизвести несколько строк, чтобы продолжить работу, потому что вы сделаете эти повторы только один раз, а ваше имя файла и строка запроса будут очень 
> маленькими. Лучше иметь работающую программу, которая немного непроизводительна, чем пытаться заранее перерабатывать рукопись при первом написании. По мере приобретения опыта работы с Ржавчиной вам будет проще 
> начать с наиболее качественного решения, но сейчас вполне приемлемо вызвать `clone`.
>

Мы обновили рукопись в `main`, поэтому он помещает образец данных `Config` возвращённый из `parse_config` в переменную с именем `config`, и мы обновили рукопись, в которой ранее использовались отдельные переменные `query` и `file_path`, так что теперь используется вместо этого 2 поля в стопке `Config`.

Теперь наша рукопись более чётко передаёт то, что `query` и `file_path` связаны и что цель из использования состоит в том, чтобы настроить, как приложение будет работать. Любая рукопись, которая использует эти значения знает, что может найти их в именованных полях стопки `config` по их назначению.

#### Создание строителя для стопки `Config`

Пока что мы выполнили этап, отвечающий за связанную оценку переменных приказной строки из `main` и поместили его в функцию `parse_config`. Это помогло нам увидеть, что значения `query` и `file_path` были связаны и что их отношения должны быть отражены в нашей рукописи. Затем мы добавили стопку `Config` для связки значений `query` и `file_path` и для возврата их как имён полей стопки из функции `parse_config`.

Итак, теперь целью функции `parse_config` является создание образца данных `Config`, мы можем изменить `parse_config` из простой функции на функцию названную `new`, которая связана со `стопкой`  `Config`. Выполняя это изменение мы сделаем рукопись более краткой. Можно создавать образцы видов данных во встроенной библиотеке, такие как `String` с помощью вызова `String::new`. Точно так же, изменив название `parse_config` на название функции `new`, связанную с `Config`, мы будем сможем создавать стопку `Config`, вызывая `Config::new`. Приложение 12-7 показывает изменения, которые мы должны сделать.

<span class="filename">Файл: src/main.rs</span>

```rust,should_panic,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-07/src/main.rs:here}}
```

<span class="caption">Приложение 12-7: Переименование <code>parse_config</code> в <code>Config::new</code></span>

Мы обновили `main`, где вызывали `parse_config`, чтобы вместо этого вызывалась `Config::new`. Мы изменили имя `parse_config` на `new` и перенесли её внутрь раздела `impl`, который связывает функцию `new` с `Config`. Попробуйте снова собрать рукопись, чтобы убедиться, что она работает.

### Исправление ошибок обработки

Теперь мы поработаем над исправлением обработки ошибок. Напомним, что попытки получить доступ к значениям в векторе `args` с порядковым указателем 1 или порядковым указателем 2 приведут к сбою, если вектор содержит менее трёх переменных. Попробуйте запустить программу без каких-либо переменных; это будет выглядеть так:

```console
{{#include ../listings/ch12-an-io-project/listing-12-07/output.txt}}
```

Строка `index out of bounds: the len is 1 but the index is 1` является сообщением об ошибке, предназначенной для разработчиков ПО. Она не поможет нашим конечным пользователям понять, что случилось и что они должны сделать вместо этого. Давайте исправим это сейчас.

#### Более подробный вывод сообщения об ошибке

В приложении 12-8 мы добавляем проверку в функцию `new`, которая будет проверять, что срез достаточно длинный, перед попыткой доступа по порядковым указателям 1 и 2. Если срез не достаточно длинный, приложение вызывает сбой и отображает более подробное сообщение об ошибке.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-08/src/main.rs:here}}
```

<span class="caption">Приложение 12-8: Добавление проверки количества переменных</span>

Эта рукопись похожа на [функцию `Guess::new` написанную в приложении 9-13], где мы вызывали `panic!`, когда `value` переменной вышло за пределы допустимых значений. Здесь вместо проверки на ряд значений, мы проверяем, что длина `args` не менее 3 и остальная часть функции будет выполнена если это условие было выполнено. Если в `args` меньше трёх переменных, это условие будет истинным и мы вызываем макрос `panic!` для немедленного завершения приложения.

Имея нескольких лишних строк рукописи в `new`, давайте запустим программу снова без переменных, чтобы увидеть, как выглядит ошибка:

```console
{{#include ../listings/ch12-an-io-project/listing-12-08/output.txt}}
```

Этот вывод более понятен: у нас теперь есть четкое сообщение о причине ошибки. Тем не менее, мы также имеем излишние сведения, которые совершенно не нужны нашим пользователям. Возможно, использованное средство, которое мы использовали в приложении 9-13, не является лучшим способом для решения задачи. Вызов `panic!` больше подходит для указания на тот или иной сбой, чем решения их решения, как обсуждалось в [главе 9]<!-- ignore -->. Вместо этого мы можем использовать другое средство, о котором вы узнали возвращая `Result` в [главе 9]<!-- ignore -->, которое указывает на успех, либо на ошибку.

<!-- Old headings. Do not remove or links may break. -->

<a id="returning-a-result-from-new-instead-of-calling-panic"></a>

#### Возвращение `Result` вместо вызова `panic!`

Мы можем вернуть значение `Result`, которое будет содержать образец данных `Config` в успешном случае и опишет неполадку в случае ошибки. Мы так же изменим имя функции `new` на `build` потому, что многие программисты ожидают, что `new` никогда не завершится неудачей. Когда `Config::build` взаимодействует с `main`, мы можем использовать вид данных `Result` как знак возникновения сбоев. Затем мы можем изменить `main`, чтобы преобразовать исход `Err` в более понятную ошибку для наших пользователей без окружающего писания вроде `thread 'main'` и `RUST_BACKTRACE`, что происходит при вызове `panic!`.

Приложение 12-9 показывает изменения, которые нужно внести в возвращаемое значения функции `Config::build`, и в тело функции, необходимые для возврата вида данных `Result`. Заметьте, что эта рукопись не собирается, пока мы не обновим `main`, что мы и сделаем в следующем приложении.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-09/src/main.rs:here}}
```

<span class="caption">Приложение 12-9: Возвращение вида данных <code>Result</code> из <code>Config::build</code></span>

Наша функция `build` теперь возвращает `Result` с образцом `Config` в случае успеха и `&'static str` в случае ошибки. Значения ошибок всегда будут строковыми записями, которые имеют время жизни `'static`.

Мы внесли два изменения в тело функции `build`: вместо вызова `panic!`, когда пользователь не передаёт достаточно переменных, мы теперь возвращаем ошибку `Err` в виде строковой ссылки. В случае успеха возвращаемое значение в виде стопки `Config` в <code>Ok</code> . Эти изменения заставят функцию соответствовать описанию в ярлыке.

Возвращение значения `Err` из `Config::build` позволяет функции `main` обработать значение `Result`, возвращённое из функции `build` и в случае ошибки закончить более правильно.

<!-- Old headings. Do not remove or links may break. -->

<a id="calling-confignew-and-handling-errors"></a>

#### Вызов `Config::build` и обработка ошибок

Чтобы обработать ошибку и вывести более дружественное сообщение о ней , нам нужно обновить рукопись `main` для обработки `Result`, возвращаемого из `Config::build` как показано в приложении 12-10. Мы также возьмём на себя ответственность за выход из приложения приказной строки с ненулевой рукописью ошибки `panic!` и выполняем это вручную. Не нулевое значение выхода - это соглашение, которое указывает этапу, который вызывает нашу программу, что приложение завершилась с ошибкой.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-10/src/main.rs:here}}
```

<span class="caption">Приложение 12-10: Выход с рукописью ошибки если создание новой <code>Config</code> терпит неудачу</span>

В этом приложении мы использовали способ, который мы ещё не рассматривали подробно: `unwrap_or_else`, который во встроенной библиотеке определён как `Result<T, E>`. Использование `unwrap_or_else` позволяет нам определить некоторые пользовательские ошибки обработки, не содержащие `panic!`. Если `Result` является значением `Ok`, поведение этого способа подобно `unwrap`: возвращает внутреннее значение из обёртки `Ok`. Однако, если значение является значением `Err`, то этот способ вызывает рукопись *замыкания*, которое является безымянной функцией, определённой заранее и передаваемую в качестве переменной в `unwrap_or_else`. Мы рассмотрим замыкания более подробно в [главе 13](ch13-00-functional-features.html). В данное мгновение, вам просто нужно знать, что `unwrap_or_else` передаст внутреннее значение `Err`, которое в этом случае является постоянной строкой `не хватает переменных`, которое мы добавили в приложении 12-9, в наше замыкание как переменная `err` указанное между вертикальными линиями. Рукопись в замыкании может затем использовать значение `err` при выполнении.

Мы добавили новую строку `use`, чтобы подключить `process` из встроенной библиотеки в область видимости. Рукопись в замыкании, который будет запущен в случае ошибки содержит только две строчки: мы выводим значение `err` и затем вызываем `process::exit`. Функция `process::exit` немедленно остановит программу и вернёт номер, который был передан в качестве рукописи состояния выхода. Это похоже на обработку с помощью макроса `panic!`, которую мы использовали в приложении 12-8, но мы больше не получаем весь дополнительный вывод. Давай попробуем:

```console
{{#include ../listings/ch12-an-io-project/listing-12-10/output.txt}}
```

Замечательно! Этот вывод намного дружелюбнее для наших пользователей.

### Извлечение хода мыслей из `main`

Теперь, когда мы закончили переработку рукописи разбора настройки, давайте обратимся к ходу мыслей приложения. Как мы указали в разделе [«Разделение ответственности в двоичных делах»](#separation-of-concerns-for-binary-projects)<!-- ignore -->, мы извлечём функцию с именем `run`, которая будет содержать весь ход мыслей, присутствующую в настоящее время в функции `main` и которая не связана с настройкой настройки или обработкой ошибок. Когда мы закончим, то `main` будет краткой, легко проверяемой и мы сможем написать проверки для всего остального хода мыслей.

Рукопись 12-11 отображает извлечённую ход мыслей в функцию `run`. Мы делаем маленькое, инкрементальное приближение к извлечению функции. Рукопись всё ещё сосредоточен в файле *src/main.rs*:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-11/src/main.rs:here}}
```

<span class="caption">Приложение 12-11: Извлечение функции <code>run</code>, содержащей остальную ход мыслей приложения</span>

Функция `run` теперь содержит всю оставшуюся ход мыслей из `main`, начиная от чтения файла. Функция `run` принимает образец данных `Config` как переменная.

#### Возврат ошибок из функции `run`

Оставшаяся ход мыслей приложения выделена в функцию `run`, где мы можем улучшить обработку ошибок как мы уже делали с `Config::build` в приложении 12-9. Вместо того, чтобы позволить программе вызвать сбой с помощью вызова `expect`, функция `run` вернёт `Result<T, E>`, если что-то пойдёт не так. Это позволит далее объединить ход мыслей обработки ошибок в `main` удобным способом. Приложение 12-12 показывает изменения, которые мы должны внести в ярлык и тело `run`.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-12/src/main.rs:here}}
```

<span class="caption">Приложение 12-12: Изменение функции <code>run</code> для возврата <code>Result</code></span>

Здесь мы сделали три значительных изменения. Во-первых, мы изменили вид возвращаемого значения функции `run` на `Result<(), Box<dyn Error>>` . Эта функция ранее возвращала вид данных `()` и мы сохраняли его как значение, возвращаемое в случае `Ok`.

Для вида ошибки мы использовали *предмет сущность* `Box<dyn Error>` (и вверху мы подключили вид данных `std::error::Error` в область видимости с помощью указания `use`). Мы рассмотрим особенности предметов в [главе 17]<!-- ignore -->. Сейчас просто знайте, что `Box<dyn Error>` означает, что функция будет возвращать вид данных использующий сущность `Error`, но не нужно указывать, какой именно будет вид данных возвращаемого значения. Это даёт возможность возвращать значения ошибок, которые могут быть разных видов в разных случаях. Ключевое слово `dyn` сокращение для слова «изменяемый».

Во-вторых, мы убрали вызов `expect` в пользу использования приказчика `?`, как мы обсудили в [главе 9]<!-- ignore -->. Скорее, чем вызывать `panic!` в случае ошибки, приказчик `?` вернёт значение ошибки из текущей функции для вызывающего, чтобы он её обработал.

В-третьих, функция `run` теперь возвращает значение `Ok` в случае успеха. В ярлыке функции `run` успешный вид данных объявлен как `()`, который означает, что нам нужно обернуть значение единичного вида данных в значение `Ok`. Данные правила написания `Ok(())` поначалу может показаться немного странным, но использование `()` выглядит как принятый способ указать, что мы вызываем `run` для его побочных последствий; он не возвращает значение, которое нам нужно.

Когда вы запустите эту рукопись, она собирается, но отобразит предупреждение:

```console
{{#include ../listings/ch12-an-io-project/listing-12-12/output.txt}}
```

Ржавчина говорит, что наша рукопись пренебрегла значением `Result`  и значение `Result` может указывать на то, что произошла ошибка. Но мы не проверяем, была ли ошибка и сборщик напоминает нам, что мы, вероятно, хотели здесь выполнить некоторую рукопись обработки ошибок! Давайте исправим эту неполадку сейчас.

#### Обработка ошибок, возвращённых из `run` в `main`

Мы будем проверять и обрабатывать ошибки используя способику, подобную той, которую мы использовали для `Config::build` в приложении 12-10, но с небольшой разницей:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/no-listing-01-handling-errors-in-main/src/main.rs:here}}
```

Мы используем `if let` вместо `unwrap_or_else` чтобы проверить, возвращает ли `run` значение `Err` и вызывается `process::exit(1)`, если это так. Функция `run` не возвращает значение, которое мы хотим развернуть способом `unwrap`, таким же образом как `Config::build` возвращает образец данных `Config`. Так как `run` возвращает `()` в случае успеха и мы заботимся только об обнаружении ошибки, то нам не нужно вызывать `unwrap_or_else`, чтобы вернуть развёрнутое значение, потому что оно будет только `()`.

Тело функций `if let` и `unwrap_or_else` одинаковы в обоих случаях: мы выводим ошибку и выходим.

### Разделение рукописи на библиотечное дополнение

Наше дело  `minigrep` пока выглядит хорошо! Теперь мы разделим файл *src/main.rs* и поместим некоторую рукопись в файл *src/lib.rs*. Таким образом мы сможем его проверять и чтобы в файле *src/main.rs* было меньшее количество полезных обязанностей.

Давайте перенесём всю рукопись не относящийся к функции `main` из файла *src/main.rs* в новый файл *src/lib.rs*:

- Определение функции `run`
- Соответствующие указания `use`
- Определение стопки `Config`
- Определение функции `Config::build`

Содержимое *src/lib.rs* должно иметь ярлыки, показанное в приложении 12-13 (мы опустили тела функций для краткости). Обратите внимание, что рукопись не будет собираться пока мы не изменим *src/main.rs* в приложении 12-14.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-13/src/lib.rs:here}}
```

<span class="caption">Приложение 12-13: Перемещение <code>Config</code> и <code>run</code> в <em>src/lib.rs</em></span>

Мы добавили определитель доступа `pub` к стопке `Config`, а также её полям, к способу `build` и функции `run`. Теперь у нас есть библиотечное дополнение, который содержит открытый API, который мы можем проверять!

Теперь нам нужно подключить рукопись, которую мы переместили в *src/lib.rs,* в область видимости двоичного дополнения внутри *src/main.rs*, как показано в приложении 12-14.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-14/src/main.rs:here}}
```

<span class="caption">Приложение 12-14: Использование дополнения библиотеки <code>minigrep</code> внутри <em>src/main.rs</em></span>

Мы добавляем `use minigrep::Config` для подключения вида данных `Config` из дополнения библиотеки в область видимости двоичного дополнения и добавляем к имени функции `run` приставка нашего дополнения. Теперь все функции должны быть подключены и должны работать. Запустите программу с `cargo run` и убедитесь, что все работает правильно.

Уф! Было много работы, но мы настроены на будущий успех. Теперь проще обрабатывать ошибки и мы сделали рукопись более состоящим из разделов. С этого времени почти вся наша работа будет выполняться внутри *src/lib.rs*.

Давайте воспользуемся этой новой выделения на разделы, сделав что-то, что было бы трудно со старым рукописью, но легко с новым рукописью: мы напишем несколько проверок!


[главе 13]: ch13-00-functional-features.html
[функцию `Guess::new` написанную в приложении 9-13]: ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation
[главе 9]: ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling
[главе 17]: ch17-00-oop.html
[главе 9]: ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator