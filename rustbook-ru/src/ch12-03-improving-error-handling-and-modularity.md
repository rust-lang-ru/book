## Переработка рукописи для улучшения выделения на разделы и обработки ошибок

Для улучшения программы мы исправим 4 имеющихся сбоя, связанных с устройством программы и тем как обрабатываются вероятные ошибки. Во-первых, функция `main` на данное мгновение решает две задачи:  рассматривает переменные приказной строки и считывает файлы. По мере роста программы количество отдельных задач, которые обрабатывает функция `main`, будет увеличиваться. Поскольку эта функция получает больше обязанностей, то становится все труднее понимать её, труднее проверять и труднее изменять, не сломав одну из её частей. Лучше всего разделить возможность, чтобы каждая функция отвечала за одну задачу.

Эта неполадка также связана со второй неполадкой: хотя переменные `query` и `file_path` являются переменными настройки нашей программы, переменные вида данных `contents` используются для выполнения хода мыслей программы. Чем длиннее становится `main`, тем больше переменных нам нужно будет добавить в область видимости; чем больше у нас переменных в области видимости, тем сложнее будет отслеживать назначение каждой переменной. Лучше всего объединять переменные настройки в одну `стопку`, чтобы сделать их назначение понятным.

Третья неполадка заключается в том, что мы используем `expect` для вывода сведений об ошибке при неполадке с чтением файла, но сообщение об ошибке просто выведет сообщение `Should have been able to read the file`. Чтение файла может не сработать по разным причинам, например: файл не найден или у нас может не быть разрешения на его чтение. Сейчас же, независимо от случая, мы выведем одно и то же сообщение об ошибке, что не даст пользователю никакие сведений!

В-четвёртых, мы используем `expect` неоднократно для обработки различных ошибок и если пользователь запускает нашу программу без указания достаточного количества переменных он получит ошибку `index out of bounds` из Ржавчины, что не совсем понятно описывает неполадку. Было бы лучше, если бы вся рукопись обработки ошибок находилась в одном месте, чтобы тем, кто будет поддерживать нашу рукопись в дальнейшем, нужно было бы вносить изменения только здесь, если потребуется изменить ход мыслей обработки ошибок. Наличие всего рукописи обработки ошибок в одном месте заверяет, что мы выведем сообщения, которые будут иметь смысл для наших конечных пользователей.

Давайте решим эти четыре сбоя путём переработки рукописи нашего дела.

### <a name="separation-of-concerns-for-binary-projects"></a>Разделение ответственности для двоичных дел

Внутренняя неполадка распределения ответственности за выполнение нескольких задач функции `main`  является общей для многих двоичных дел. В итоге Ржавчина сообщество разработало этап для использования в качестве руководства по разделению ответственности двоичной программы, когда рукопись в `main` начинает увеличиваться. Этап имеет следующие шаги:

- Разделите рукопись программы на два файла *main.rs* и *lib.rs*. Перенесите весь ход мыслей работы программы в файл *lib.rs*.
- Пока ваши знания правил написания оценки приказной строки находятся на начальном уровне, вся рукопись может оставаться в файле *main.rs*.
- Когда ход мыслей согласно правил написания оценки приказной строки становится сложным, извлеките её из *main.rs* и переместите в *lib.rs.*

Полезные  обязанности, которые остаются в функции `main` после этого этапа должно быть ограничено следующим:

- Вызов хода мыслей разбора приказной строки со значениями переменных
- Настройка любой другой настройки
- Вызов функции `run` в *lib.rs*
- Обработка ошибки, если `run` возвращает ошибку

Этот образец о разделении ответственности: *main.rs* занимается запуском программы, а *lib.rs* обрабатывает весь ход мыслей задачи. Поскольку нельзя проверить функцию `main` напрямую, то такое устройство позволяет проверить весь ход мыслей программы путём перемещения её в функции внутри *lib.rs*. Единственная рукопись, которая остаётся в *main.rs* будет достаточно маленькой, чтобы проверить ее соблюдение правил прочитав рукопись. Давайте переработаем нашу программу, следуя этому этапу.

#### Извлечение обработчика переменных

Мы извлечём возможность для разбора переменных в функцию, которую вызовет `main` для подготовки к перемещению хода мыслей разбора приказной строки в файл *src/lib.rs*. Приложение 12-5 показывает новый запуск `main`, который вызывает новую функцию `parse_config`, которую мы определим сначала в *src/main.rs.*

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-05/src/main.rs:here}}
```

<span class="caption">Приложение 12-5: Выделение функции <code>parse_config</code> из <code>main</code></span>

Мы все ещё собираем переменные приказной строки в вектор, но вместо присваивания значение переменной с порядковым указателем 1 переменной `query` и значение переменной с порядковым указателем 2 переменной с именем `file_path` в функции `main`, мы передаём весь вектор в функцию `parse_config`. Функция `parse_config` затем содержит ход мыслей, который определяет, какой переменная идёт в какую переменную и передаёт значения обратно в `main`. Мы все ещё создаём переменные `query` и `file_path` в `main`, но `main` больше не несёт ответственности за определение соответствия переменной приказной строки и соответствующей переменной.

Эта доработка может показаться излишней для нашей маленькой программы, но мы проводим переработка рукописи небольшими, постепенными шагами. После внесения этого изменения снова запустите программу и убедитесь, что оценка переменных все ещё работает. Также хорошо часто проверять все этапы, чтобы помочь определить причину неполадок. когда они возникают.

#### Объединение настроечных переменных

Мы можем сделать ещё один маленький шаг для улучшения функции `parse_config`. На данное мгновение мы возвращаем упорядоченный ряд, но затем мы немедленно разделяем его снова на отдельные части. Это признак того, что, возможно,  пока у нас нет правильной абстракции.

Ещё один показатель, который показывает, что есть место для улучшения, это часть `config` из `parse_config`, что подразумевает, что два значения, которые мы возвращаем, связаны друг с другом и оба являются частью одного настроечного значения. В настоящее время мы не отражаем этого смысла в стопке данных, кроме объединения двух значений в упорядоченный ряд; мы могли бы поместить оба значения в один вид данных - стопку и дать каждому из полей стопки понятное имя. Это облегчит будущую поддержку этой рукописи, чтобы понять, как различные значения относятся друг к другу и какое их назначение.

В приложении 12-6 показаны улучшения функции `parse_config` .

<span class="filename">Файл: src/main.rs</span>

```rust,should_panic,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-06/src/main.rs:here}}
```

<span class="caption">Приложение 12-6: Переработка рукописи функции <code>parse_config</code>, чтобы возвращать образец данных стопки <code>Config</code></span>

Мы добавили стопку с именем `Config` объявленную с полями назваными как `query` и `file_path`. Ярлык `parse_config` теперь указывает, что она возвращает значение `Config`. В теле `parse_config`, где мы возвращали срезы строк, которые ссылаются на значения `String` в `args`, теперь мы определяем `Config` как содержащие собственные `String` значения. Переменная `args` в `main` является владельцем значений переменной и позволяют функции `parse_config` только одалживать их, что означает, что мы бы нарушили правила заимствования Ржавчина, если бы `Config` попытался бы взять во владение значения в `args` .

Мы можем управлять данными `String` разным количеством способов, но самый простой, хотя и отчасти неразумный это вызвать способ `clone` у значений. Он сделает полный повтор данных для образца данных `Config` для владения, что занимает больше времени и памяти, чем сохранение ссылки на строку данных. Однако удваивание данных также делает наша рукопись очень простой, потому что нам не нужно управлять временем жизни ссылок; в этом обстоятельстве, отказ от небольшой производительности, чтобы получить простоту, стоит небольших соглашений.

>  <h>К при использовании способа <code>clone</code></h>Существует тенденция в среде программистов Ржавчине избегать использования `clone`, т.к. это понижает производительность работы рукописи. В [Главе 13]<!-- ignore -->, вы изучите более производительные способы, которые могут подойти в подобном случае. Но сейчас можно воспроизвести несколько строк, чтобы продолжить работу, потому что вы сделаете эти повторы только один раз, а ваше имя файла и строка запроса будут очень маленькими. Лучше иметь работающую программу, которая немного непроизводительна, чем пытаться заранее перерабатывать рукопись при первом написании. По мере приобретения опыта работы с Ржавчиной вам будет проще начать с наиболее качественного решения, но сейчас вполне приемлемо вызвать `clone`.
>

Мы обновили рукопись в `main` поэтому он помещает образец данных `Config` возвращённый из `parse_config` в переменную с именем `config`, и мы обновили рукопись, в котором ранее использовались отдельные переменные `query` и `file_path`, так что теперь он использует вместо этого поля в стопке `Config`.

Теперь наша рукопись более чётко передаёт то, что `query` и `file_path` связаны и что цель из использования состоит в том, чтобы настроить, как программа будет работать. Любая рукопись, которая использует эти значения знает, что может найти их в именованных полях образца данных `config` по их назначению.

#### Создание строителя для стопки `Config`

Пока что мы извлекли ход мыслей, отвечающую за связанную оценкупеременных приказной строки из `main` и поместили его в функцию `parse_config`. Это помогло нам увидеть, что значения `query` и `file_path` были связаны и что их отношения должны быть отражены в нашей рукописи. Затем мы добавили стопку `Config` в качестве названия связанных общей целью `query` и `file_path` и чтобы иметь возможность вернуть именованные значения как имена полей стопки из функции `parse_config`.

Итак, теперь целью функции `parse_config` является создание образца данных `Config`, мы можем изменить `parse_config` из простой функции на функцию названную `new`, которая связана со `стопкой`  `Config`. Выполняя это изменение мы сделаем рукопись более идиоматичным. Можно создавать образцы видов данных во встроенной библиотеке, такие как `String` с помощью вызова `String::new`. Точно так же изменив название `parse_config` на название функции `new`, связанную с `Config`, мы будем уметь создавать образцы `Config`, вызывая `Config::new`. Приложение 12-7 показывает изменения, которые мы должны сделать.

<span class="filename">Файл: src/main.rs</span>

```rust,should_panic,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-07/src/main.rs:here}}
```

<span class="caption">Приложение 12-7: Переименование <code>parse_config</code> в <code>Config::new</code></span>

Мы обновили `main` где вызывали `parse_config`, чтобы вместо этого вызывалась `Config::new`. Мы изменили имя `parse_config` на `new` и перенесли его внутрь раздела `impl`, который связывает функцию `new` с `Config`. Попробуйте снова собрать рукопись, чтобы убедиться, что она работает.

### Исправление ошибок обработки

Теперь мы поработаем над исправлением обработки ошибок. Напомним, что попытки получить доступ к значениям в векторе `args` с порядковым указателем 1 или порядковым указателем 2 приведут к сбою, если вектор содержит менее трёх переменных. Попробуйте запустить программу без каких-либо переменных; это будет выглядеть так:

```console
{{#include ../listings/ch12-an-io-project/listing-12-07/output.txt}}
```

Строка `index out of bounds: the len is 1 but the index is 1` является сообщением об ошибке предназначенной для программистов. Она не поможет нашим конечным пользователям понять, что случилось и что они должны сделать вместо этого. Давайте исправим это сейчас.

#### Улучшение сообщения об ошибке

В приложении 12-8 мы добавляем проверку в функцию `new`, которая будет проверять, что срез достаточно длинный, перед попыткой доступа по порядковым указателям 1 и 2. Если срез не достаточно длинный, программа вызывает сбой и отображает улучшенное сообщение об ошибке.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-08/src/main.rs:here}}
```

<span class="caption">Приложение 12-8: Добавление проверки количества переменных</span>

Эта рукопись похож на [функцию `Guess::new` написанную в приложении 9-13], где мы вызывали `panic!`, когда `value` переменной вышло за пределы допустимых значений. Здесь вместо проверки на рядзначений, мы проверяем, что длина `args` не менее 3 и остальная часть функции может работать при условии, что это условие было выполнено. Если в `args` меньше трёх переменных, это условие будет истинным и мы вызываем макрос `panic!` для немедленного завершения программы.

Имея нескольких лишних строк рукописи в `new`, давайте запустим программу снова без переменных, чтобы увидеть, как выглядит ошибка:

```console
{{#include ../listings/ch12-an-io-project/listing-12-08/output.txt}}
```

Этот вывод лучше: у нас теперь есть разумное сообщение об ошибке. Тем не менее, мы также имеем посторонние сведения, которые мы не хотим предоставлять нашим пользователям. Возможно, использованная техника, которую мы использовали в приложении 9-13, не является лучшей для использования: вызов `panic!` больше подходит для программирования сбоев, чем решения сбоев, [как обсуждалось в главе 9]<!-- ignore -->. Вместо этого мы можем использовать другую технику, о которой вы узнали в главе 9 [возвращая `Result`]<!-- ignore -->, которая указывает либо на успех, либо на ошибку.

<!-- Old headings. Do not remove or links may break. -->

<a id="returning-a-result-from-new-instead-of-calling-panic"></a>

#### Возвращение `Result` вместо вызова `panic!`

Мы можем вернуть значение `Result`, которое будет содержать образец данных `Config` в успешном случае и опишет неполадку в случае ошибки. Мы так же изменим функцию `new` на `build` потому что многие программисты ожидают что `new` никогда не завершится неудачей. Когда `Config::build` взаимодействует с `main`, мы можем использовать вид данных `Result` как сигнал возникновения сбоев. Затем мы можем изменить `main`, чтобы преобразовать исход `Err` в более применимую ошибку для наших пользователей без окружающего писания вроде `thread 'main'` и `RUST_BACKTRACE`, что происходит при вызове `panic!`.

Приложение 12-9 показывает изменения, которые нужно внести в возвращаемое значения функции `Config::build`, и в тело функции, необходимые для возврата вида данных `Result`. Заметьте, что эта рукопись не собирается, пока мы не обновим `main`, что мы и сделаем в следующем приложении.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-09/src/main.rs:here}}
```

<span class="caption">Приложение 12-9: Возвращение вида данных <code>Result</code> из <code>Config::build</code></span>

Наша функция `build` теперь возвращает `Result` с образцом `Config` в случае успеха и `&'static str` в случае ошибки. Значения ошибок всегда будут строковыми записями, которые имеют время жизни `'static`.

Мы внесли два изменения в тело функции `build`: вместо вызова `panic!`, когда пользователь не передаёт достаточно переменных, мы теперь возвращаем `Err` значение и мы завернули возвращаемое значение `Config` в <code>Ok</code> . Эти изменения заставят функцию соответствовать своей новой ярлыке вида данных.

Возвращение значения `Err` из `Config::build` позволяет функции `main` обработать значение `Result` возвращённое из функции `build` и выйти из этапа более чисто в случае ошибки.

<!-- Old headings. Do not remove or links may break. -->

<a id="calling-confignew-and-handling-errors"></a>

#### Вызов `Config::build` и обработка ошибок

Чтобы обработать ошибку и вывести более дружественное сообщение об ошибке, нам нужно обновить рукопись `main` для обработки `Result`, возвращаемого из `Config::build` как показано в приложении 12-10. Мы также возьмём на себя ответственность за выход из программы приказной строки с ненулевой рукописью ошибки `panic!` и выполняем это вручную. Не нулевое значение выхода - это соглашение, которое указывает этапу, который вызывает нашу программу, что программа завершилась с ошибкой.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-10/src/main.rs:here}}
```

<span class="caption">Приложение 12-10: Выход с рукописью ошибки если создание новой <code>Config</code> терпит неудачу</span>

В этом приложении мы использовали способ, который мы ещё не рассматривали подробно: `unwrap_or_else`, который во встроенной библиотеке определён как `Result<T, E>`. Использование `unwrap_or_else` позволяет нам определить некоторые пользовательские ошибки обработки, не содержащие `panic!`. Если `Result` является значением `Ok`, поведение этого способа подобно `unwrap`: возвращает внутреннее значение из обёртки `Ok`. Однако, если значение является значением `Err`, то этот способ вызывает рукопись *замыкания*, которое является анонимной функцией, определённой заранее и передаваемую в качестве переменной в `unwrap_or_else`. Мы рассмотрим замыкания более подробно в [главе 13](ch13-00-functional-features.html). В данный мгновение, вам просто нужно знать, что `unwrap_or_else` передаст внутреннее значение `Err`, которое в этом случае является постоянной строкой `not enough arguments`, которое мы добавили в приложении 12-9, в наше замыкание как переменная `err` указанное между вертикальными линиями. Рукопись в замыкании может затем использовать значение `err` при выполнении.

Мы добавили новую строку `use`, чтобы подключить `process` из встроенной библиотеки в область видимости. Рукопись в замыкании, который будет запущен в случае ошибки содержит только две строчки: мы выводим значение `err` и затем вызываем `process::exit`. Функция `process::exit` немедленно остановит программу и вернёт номер, который был передан в качестве рукописи состояния выхода. Это похоже на обработку с помощью макроса `panic!`, которую мы использовали в приложении 12-8, но мы больше не получаем весь дополнительный вывод. Давай попробуем:

```console
{{#include ../listings/ch12-an-io-project/listing-12-10/output.txt}}
```

Замечательно! Этот вывод намного дружелюбнее для наших пользователей.

### Извлечение хода мыслей из `main`

Теперь, когда мы закончили переработка рукописи разбора настройки, давайте обратимся к ходу мыслей программы. Как мы указали в разделе [«Разделение ответственности в двоичных делах»](#separation-of-concerns-for-binary-projects)<!-- ignore -->, мы извлечём функцию с именем `run`, которая будет содержать весь ход мыслей, присутствующую в настоящее время в функции `main` и которая не связана с настройкой настройки или обработкой ошибок. Когда мы закончим, то `main` будет краткой, легко проверяемой и мы сможем написать проверки для всего остального хода мыслей.

Рукопись 12-11 отображает извлечённую ход мыслей в функцию `run`. Мы делаем маленькое, инкрементальное приближение к извлечению функции. Рукопись всё ещё сосредоточен в файле *src/main.rs*:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-11/src/main.rs:here}}
```

<span class="caption">Приложение 12-11: Извлечение функции <code>run</code>, содержащей остальную ход мыслей программы</span>

Функция `run` теперь содержит всю оставшуюся ход мыслей из `main`, начиная от чтения файла. Функция `run` принимает образец данных `Config` как переменная.

#### Возврат ошибок из функции `run`

Оставшаяся ход мыслей программы выделена в функцию `run`, где мы можем улучшить обработку ошибок как мы уже делали с `Config::build` в приложении 12-9. Вместо того, чтобы позволить программе вызвать сбой с помощью вызова `expect`, функция `run` вернёт `Result<T, E>`, если что-то пойдёт не так. Это позволит далее объединить ход мыслей обработки ошибок в `main` удобным способом. Приложение 12-12 показывает изменения, которые мы должны внести в ярлык и тело `run`.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-12/src/main.rs:here}}
```

<span class="caption">Приложение 12-12: Изменение функции <code>run</code> для возврата <code>Result</code></span>

Здесь мы сделали три значительных изменения. Во-первых, мы изменили вид возвращаемого значения функции `run` на `Result<(), Box<dyn Error>>` . Эта функция ранее возвращала вид данных `()` и мы сохраняли его как значение, возвращаемое в случае `Ok`.

Для вида ошибки мы использовали *предмет сущность* `Box<dyn Error>` (и вверху мы подключили вид данных `std::error::Error` в область видимости с помощью указания `use`). Мы рассмотрим особенности предметов в [главе 17]<!-- ignore -->. Сейчас просто знайте, что `Box<dyn Error>` означает, что функция будет возвращать вид данных использующий сущность `Error`, но не нужно указывать, какой именно будет вид данных возвращаемого значения. Это даёт возможность возвращать значения ошибок, которые могут быть разных видов в разных случаях. Ключевое слово `dyn` сокращение для слова «изменяемый».

Во-вторых, мы убрали вызов `expect` в пользу использования приказчика `?`, как мы обсудили в [главе 9]<!-- ignore -->. Скорее, чем вызывать `panic!` в случае ошибки, приказчик `?` вернёт значение ошибки из текущей функции для вызывающего, чтобы он её обработал.

В-третьих, функция `run` теперь возвращает значение `Ok` в случае успеха. В ярлыке функции `run` успешный вид данных объявлен как `()`, который означает, что нам нужно обернуть значение единичного вида данных в значение `Ok`. Данные правила написания `Ok(())` поначалу может показаться немного странным, но использование `()` выглядит как принятый способ указать, что мы вызываем `run` для его побочных последствий; он не возвращает значение, которое нам нужно.

Когда вы запустите эту рукопись, она собирается, но отобразит предупреждение:

```console
{{#include ../listings/ch12-an-io-project/listing-12-12/output.txt}}
```

Ржавчина говорит, что наша рукопись пренебрегла значением `Result`  и значение `Result` может указывать на то, что произошла ошибка. Но мы не проверяем, была ли ошибка и сборщик напоминает нам, что мы, вероятно, хотели здесь выполнить некоторую рукопись обработки ошибок! Давайте исправим эту неполадку сейчас.

#### Обработка ошибок, возвращённых из `run` в `main`

Мы будем проверять и обрабатывать ошибки используя способику, подобную той, которую мы использовали для `Config::build` в приложении 12-10, но с небольшой разницей:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/no-listing-01-handling-errors-in-main/src/main.rs:here}}
```

Мы используем `if let` вместо `unwrap_or_else` чтобы проверить, возвращает ли `run` значение `Err` и вызывается `process::exit(1)`, если это так. Функция `run` не возвращает значение, которое мы хотим развернуть способом `unwrap`, таким же образом как `Config::build` возвращает образец данных `Config`. Так как `run` возвращает `()` в случае успеха и мы заботимся только об обнаружении ошибки, то нам не нужно вызывать `unwrap_or_else`, чтобы вернуть развёрнутое значение, потому что оно будет только `()`.

Тело функций `if let` и `unwrap_or_else` одинаковы в обоих случаях: мы выводим ошибку и выходим.

### Разделение рукописи на библиотечный ящик

Наше дело  `minigrep` пока выглядит хорошо! Теперь мы разделим файл *src/main.rs* и поместим некоторую рукопись в файл *src/lib.rs*. Таким образом мы сможем его проверять и чтобы в файле *src/main.rs* было меньшее количество полезных обязанностей.

Давайте перенесём всю рукопись не относящийся к функции `main` из файла *src/main.rs* в новый файл *src/lib.rs*:

- Определение функции `run`
- Соответствующие указания `use`
- Определение стопки `Config`
- Определение функции `Config::build`

Содержимое *src/lib.rs* должно иметь ярлыки, показанное в приложении 12-13 (мы опустили тела функций для краткости). Обратите внимание, что рукопись не будет собираться пока мы не изменим *src/main.rs* в приложении 12-14.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-13/src/lib.rs:here}}
```

<span class="caption">Приложение 12-13: Перемещение <code>Config</code> и <code>run</code> в <em>src/lib.rs</em></span>

Мы добавили определитель доступа `pub` к стопке `Config`, а также её полям, к способу `build` и функции `run`. Теперь у нас есть библиотечный ящик, который содержит открытый API, который мы можем проверять!

Теперь нам нужно подключить рукопись, которую мы переместили в *src/lib.rs,* в область видимости двоичного ящика внутри *src/main.rs*, как показано в приложении 12-14.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-14/src/main.rs:here}}
```

<span class="caption">Приложение 12-14: Использование ящика библиотеки <code>minigrep</code> внутри <em>src/main.rs</em></span>

Мы добавляем `use minigrep::Config` для подключения вида данных `Config` из ящика библиотеки в область видимости двоичного ящика и добавляем к имени функции `run` приставка нашего ящика. Теперь все функции должны быть подключены и должны работать. Запустите программу с `cargo run` и убедитесь, что все работает правильно.

Уф! Было много работы, но мы настроены на будущий успех. Теперь проще обрабатывать ошибки и мы сделали рукопись более состоящим из разделов. С этого времени почти вся наша работа будет выполняться внутри *src/lib.rs*.

Давайте воспользуемся этой новой выделения на разделы, сделав что-то, что было бы трудно со старым рукописью, но легко с новым рукописью: мы напишем несколько проверок!


[Главе 13]: ch13-00-functional-features.html
[функцию `Guess::new` написанную в приложении 9-13]: ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation
[как обсуждалось в главе 9]: ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling
[главе 17]: ch17-00-oop.html
[главе 9]: ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator