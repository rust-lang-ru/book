## Краткое управление потоком выполнения с `if let`

Правила написания `if let` позволяют сочетать `if` и `let` в менее многословное устройство, и затем обработать значения соответствующе только одному образцу данных, одновременно пренебрегая все остальные. Рассмотрим программу в приложении 6-6, которая обрабатывает сопоставление значения `Option<u8>` в переменной `config_max`, но хочет выполнить рукопись только в том случае, если значение является исходом `Some`.

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-06/src/main.rs:here}}
```

<span class="caption">Приложение 6-6: Выражение <code>match</code>, которое выполнит рукопись только при значении равном <code>Some</code></span>

Если значение равно `Some`, мы выводим значение в исходе `Some`, привязывая значение к переменной `max` в образце. Мы не хотим ничего делать со значением `None`. Чтобы удовлетворить выражение `match`, мы должны добавить `_ => ()` после обработки первой и единственной ветки, и добавление образцовой рукописи раздражает.

Вместо этого, мы могли бы написать это более коротким способом, используя `if let`. Следующая рукопись ведёт себя так же, как выражение `match` в приложении 6-6:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-12-if-let/src/main.rs:here}}
```

Согласно Правил написания `if let` принимает образец данных и выражение, разделённые знаком равенства. Он работает так же, как `match`, когда в него на вход передадут выражение и подходящим образцом для этого выражения окажется первая ветка. В данном случае образцом является `Some(max)`, где `max` привязывается к значению внутри `Some`. Затем мы можем использовать `max` в теле раздела `if let` так же, как мы использовали `max` в соответствующей ветке `match`. Рукопись в разделе `if let` не запускается, если значение не соответствует образцу данных.

Используя `if let` мы меньше выводим, меньше делаем отступов и меньше получаем образцовой рукописи. Тем не менее, мы теряем полную проверку всех исходов, предоставляемую выражением `match`. Выбор между `match` и `if let` зависит от того, что вы делаете в вашем определенном случае и является ли получение краткости при потере полноты проверки подходящим решением.

Другими словами, вы можете думать о стопке `if let` как о <em>связанном сахаре</em> для `match`, который выполнит рукопись если входное значение будет соответствовать единственному образцу данных, и пренебрегает все остальные значения.

Можно добавлять `else` к `if let`. Раздел рукописи, который находится внутри `else` подобен по смыслу разделу рукописи ветки связанной с образцом `_` выражения `match` (которое равнозначно сборной стопки `if let` и `else`). Вспомним объявление перечисления `Coin` в приложении 6-4, где исход `Quarter` также содержит внутри значение штата вида данных `UsState`. Если бы мы хотели посчитать все монеты не являющиеся четвертями, а для четвертей выводить название штата, то мы могли бы сделать это с помощью выражения `match` таким образом:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-13-count-and-announce-match/src/main.rs:here}}
```

Или мы могли бы использовать выражение `if let` и `else` так:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-14-count-and-announce-if-let-else/src/main.rs:here}}
```

Если у вас есть случай в которой ваша программа имеет ход мыслей, который слишком многословен для того чтобы его выражать используя `match`, помните, о том, что также в вашем наборе средств Ржавчине есть `if let`.

## Итоги

Мы рассмотрели как использовать перечисления для создания пользовательских видов данных, которые могут быть одним из наборов перечисляемых значений. Мы показали, как вид данных `Option<T>` из встроенной библиотеки помогает использовать систему видов данных для предотвращения ошибок. А когда значения перечисления имеют данные внутри них, можно использовать `match` или `if let`, чтобы извлечь и пользоваться значением, в зависимости от того, сколько случаев нужно обработать.

Теперь ваши программы на Ржавчине могут выражать подходы вашей предметной области, используя стопки и перечисления. Создание и использование пользовательских видов данных в API обеспечивает <em>безопасность видов данных</em>: сборщик позаботится о том, чтобы функции получали значения только того вида данных, который они ожидают.

Чтобы предоставить вашим пользователям хорошо согласованный API, который прост в использовании и предоставляет только то, что нужно вашим пользователям, надо поговорить о разделах в Ржавчине.
