## Пример использования стопок

Чтобы понять, когда нам может понадобиться использование стопок, давайте напишем программу, которая вычисляет площадь прямоугольника. Мы начнём с использования одиночных переменных, а затем будем улучшать программу до использования стопок.

Давайте создадим новое дело программы при помощи Cargo и назовём его *rectangles*. Наша программа будет получать на вход длину и ширину прямоугольника в точках и затем рассчитывать площадь прямоугольника. Приложение 5-8 показывает один из коротких исходов рукописи, который позволит нам сделать именно то, что надо, в файле дела *src/main.rs*.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-08/src/main.rs:all}}
```

<span class="caption">Приложение 5-8: вычисление площади прямоугольника, заданного отдельными переменными ширины и высоты</span>

Теперь запустим программу, используя `cargo run`:

```console
{{#include ../listings/ch05-using-structs-to-structure-related-data/listing-05-08/output.txt}}
```

Эта рукопись успешно вычисляет площадь прямоугольника, вызывая функцию `area` с каждым измерением, но мы можем улучшить её ясность и удобство чтения.

Неполадка данного способа очевидна из ярлыки `area`:

```rust,ignore
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-08/src/main.rs:here}}
```

Функция `area` должна вычислять площадь одного прямоугольника, но функция, которую мы написали, имеет два свойства, и нигде в нашей программе не ясно, что эти свойства взаимосвязаны. Было бы более удобным для чтения и управляемым объединять ширину и высоту вместе. В разделе [«Упорядоченные ряды»]<!-- ignore --> Главы 3 мы уже обсуждали один из способов сделать это — использовать упорядоченные ряды.

### Переработка рукописи при помощи упорядоченных рядов

Приложение 5-9 — это другое исполнение программы, использующее упорядоченные ряды.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-09/src/main.rs}}
```

<span class="caption">Приложение 5-9: Определение ширины и высоты прямоугольника с помощью упорядоченного ряда</span>

С одной стороны, эта программа лучше. Упорядоченные ряды позволяют добавить немного стопке, и теперь мы передаём только одну переменную. Но с другой стороны, это исполнение менее понятно: упорядоченные ряды не называют свои переменные, поэтому нам приходится упорядочивать части упорядоченного ряда, что делает наше вычисление менее очевидным.

Если мы перепутаем местами ширину с высотой при расчёте площади, то это не имеет значения. Но если мы хотим нарисовать прямоугольник на экране, то это уже будет важно! Мы должны помнить, что ширина  `width` находится в упорядоченном ряде с порядковым указателем `0`, а высота `height` — с порядковым указателем `1`. Если кто-то другой поработал бы с рукописью, ему бы пришлось разобраться в этом и также помнить про порядок. Легко забыть и перепутать эти значения — и это вызовет ошибки, потому что данная рукопись не передаёт наши намерения.

### Переработка рукописи при помощи стопок: добавим больше смысла

Мы используем стопки, чтобы добавить смысл данным при помощи назначения им осмысленных имён . Мы можем переделать используемый упорядоченный ряд в стопка с единым именем для сущности и частными названиями её частей, как показано в приложении 5-10.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-10/src/main.rs}}
```

<span class="caption">Приложение 5-10: Определение стопки <code>Rectangle</code></span>

Здесь мы определили стопку и дали ей имя `Rectangle` (прямоугольник). Внутри узорчатых скобок определили поля как `width` и `height`, оба — вида данных `u32`. Затем в `main` создали определенный образец данных `Rectangle` (прямоугольник) с шириной в `30` и высотой в `50` единиц.

Наша функция `area` теперь определена с одним свойством, названным `rectangle` (прямоугольник), чей вид данных является неизменяемым заимствованием стопки `Rectangle` (прямоугольник). Как упоминалось в главе 4, необходимо заимствовать стопку, а не передавать её во владение. Таким образом функция `main` сохраняет `rect1` в собственности и может использовать её дальше. По этой причине мы и используем `&` в ярлыке и в месте вызова функции.

Функция `area` получает доступ к полям `width` и `height` образца данных `Rectangle` (обратите внимание, что доступ к полям заимствованного образца данных стопки не приводит к перемещению значений полей, поэтому вы часто видите заимствования стопок). Наш ярлык функции для `area` теперь говорит именно то, что мы имеем в виду: вычислить площадь `Rectangle` (прямоугольник), используя его поля `width` и `height`. Это означает, что ширина и высота связаны друг с другом, и даёт описательные имена значениям, а не использует значения порядкового указателя упорядоченного ряда `0` и `1`. Это торжество ясности.

### Добавление полезной возможности при помощи выводимых сущностей

Было бы полезно иметь возможность выводить образец данных `Rectangle` во время отладки программы и видеть значения всех полей. Приложение 5-11 использует макрос [`println!`](https://doc.rust-lang.org/std/macro.println.html)<!-- ignore -->, который мы уже использовали в предыдущих главах. Тем не менее, это не работает.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-11/src/main.rs}}
```

<span class="caption">Приложение 5-11: Попытка вывести значения образца данных <code>Rectangle</code></span>

При сборке этой рукописи мы получаем ошибку с сообщением:

```text
{{#include ../listings/ch05-using-structs-to-structure-related-data/listing-05-11/output.txt:3}}
```

Макрос `println!` умеет выполнять множество видов разметки, и по умолчанию узорчатые скобки в `println!` означают использование разметки, известного как сущность `Display`. Его вывод предназначен для непосредственного использования конечным пользователем. Простые виды данных, изученные ранее, по умолчанию используют сущность `Display`, потому что есть только один способ отобразить число `1` или любой другой простой вид данных. Но для  сложных видов данных вывод с разметкой через `println!` менее очевиден, потому что есть гораздо больше способов вывода: Вы хотите запятые или нет? Вы хотите выводить узорчатые скобки? Должны ли отображаться все поля? Из-за этой неоднозначности Ржавчина не пытается  угадать, что нам нужно, а сложные виды данных не имеют встроенного использования `Display` для вывода через `println!` с исполнителем `{}`.

Продолжив чтение ошибок нашей рукописи, мы найдём важное замечание:

```text
{{#include ../listings/ch05-using-structs-to-structure-related-data/listing-05-11/output.txt:9:10}}
```

Давайте попробуем! Вызов макроса `println!` теперь будет выглядеть так `println!("rect1 is {:?}", rect1);`. Ввод определетеля `:?` внутри узорчатых скобок говорит макросу `println!`, что мы хотим использовать другой вид вывода, известный как `Debug`. Сущность `Debug` позволяет выводить сложные виды данных способом, удобным для разработчиков, чтобы видеть значение во время отладки рукописи.

Соберем рукопись с этими изменениями. Упс! Мы всё ещё получаем ошибку:

```text
{{#include ../listings/ch05-using-structs-to-structure-related-data/output-only-01-debug/output.txt:3}}
```

Снова сборщик даёт нам важное замечание:

```text
{{#include ../listings/ch05-using-structs-to-structure-related-data/output-only-01-debug/output.txt:9:10}}
```

Ржавчина *использует* возможность для вывода отладочных сведений , но *не включает (не выводит) её по умолчанию*. Мы должны явно включить эту возможность для нашего сложного вида данных (в данном случае стопки). Чтобы это сделать, добавляем внешнее средство `#[derive(Debug)]` сразу перед определением сложного вида данных, как показано в приложении 5-12.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-12/src/main.rs}}
```

<span class="caption">Приложение 5-12: Добавление средства для вывода сущности <code>Debug</code> и выводе образца данных <code>Rectangle</code> с отладочной разметкой
</span>

Теперь при запуске программы мы не получим ошибок и увидим следующий вывод:

```console
{{#include ../listings/ch05-using-structs-to-structure-related-data/listing-05-12/output.txt}}
```

Отлично! Это не самый красивый вывод, но он показывает значения всех полей образца, которые определённо помогут при отладке. Когда у нас более крупные стопки, то полезно иметь более простой для чтения вывод; в таких случаях можно использовать рукопись `{:#?}` вместо `{:?}` в строке макроса `println!`. В этом примере использование исполнения `{:#?}` приведёт к такому выводу:

```console
{{#include ../listings/ch05-using-structs-to-structure-related-data/output-only-02-pretty-debug/output.txt}}
```

Другой способ вывести значение в виде`Debug` — использовать макрос [`dbg!`]<!-- ignore -->, который становится владельцем выражения (в отличие от `println!`, принимающего ссылку), выводит номер файла и строки, где происходит вызов макроса `dbg!`, вместе с итоговым значением этого выражения и возвращает владение на значение.

>  Примечание: при вызове макроса `dbg!` используется вывод в обычный поток ошибок (`stderr`), в отличие от `println!`, который использует обычный поток вывода в окно вывода (`stdout`). Подробнее о `stderr` и `stdout` мы поговорим в разделе [«Запись сообщений об ошибках в обычный вывод ошибок вместо принятого вывода» Главы 12]<!-- ignore -->.

Вот пример, когда нас важно значение, которое присваивается полю `width`, а также значение всей стопки в `rect1`:

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/no-listing-05-dbg-macro/src/main.rs}}
```

Можем написать макрос `dbg!` вокруг выражения `30 * scale`, потому что `dbg!` возвращает владение значения выражения. Поле `width` получит то же значение, как если бы у нас не было вызова `dbg!`. Мы не хотим, чтобы макрос `dbg!` становился владельцем `rect1`, поэтому используем ссылку на `rect1` в следующем вызове. Вот как выглядит вывод этого примера:

```console
{{#include ../listings/ch05-using-structs-to-structure-related-data/no-listing-05-dbg-macro/output.txt}}
```

Мы можем увидеть, что первый отладочный вывод поступил из строки 10 *src/main.rs*, там, где мы отлаживаем выражение `30 * scale`, и его итоговое значение равно 60 (`Debug` разметка, выполненная для целых чисел, заключается в выводе только их значения). Вызов `dbg!` в строке 14 <em>src/main.rs</em> выводит значение <code>&amp;rect1</code>, которое является стопкой `Rectangle`. В этом выводе используется красивая разметка `Debug` вида данных `Rectangle`. Макрос `dbg!` может быть очень полезен, когда вы пытаетесь понять, что делает ваша рукопись!

В дополнение к `Debug`, Ржавчина предоставила нам ряд сущностей, которые мы можем использовать со средством `derive` для добавления полезного поведения к нашим пользовательским видам данных. Эти сущности и их поведение перечислены в [приложении C]<!-- ignore -->. Мы расскажем, как использовать эти сущности с пользовательским поведением, а также как создать свои собственные сущности в главе 10. Кроме того, есть много других средств помимо `derive`; для получения дополнительных сведений смотрите [раздел “Свойства” справочника Ржавчины](https://doc.rust-lang.org/reference/attributes.html).

Функция `area` является довольно отличительной: она считает только площадь прямоугольников. Было бы полезно привязать данное поведение как можно ближе к стопке `Rectangle`, потому что наша отличительная рукопись не будет работать с любым другим видом данных. Давайте рассмотрим, как можно улучшить нашу рукопись превращая функцию `area` в <em>способ</em> <code>area</code>, определённый для вида данных `Rectangle`.


[«Упорядоченные ряды»]: ch03-02-data-types.html#the-tuple-type
[приложении C]: appendix-03-derivable-traits.md
[`dbg!`]: ../std/macro.dbg.html
[«Запись сообщений об ошибках в обычный вывод ошибок вместо принятого вывода» Главы 12]: ch12-06-writing-to-stderr-instead-of-stdout.html