## Запуск рукописи при очистке с помощью сущности `Drop`

Второй важной особенностью умного указателя является Drop, который позволяет управлять, что происходит, когда значение вот-вот выйдет из области видимости. Вы можете использовать сущность Drop для любого вида данных, а также использовать эту рукопись для высвобождения памяти, таких как файлы или сетевые соединения.

Мы рассматриваем `Drop` в среде умных указателей, потому что возможность свойства `Drop` по сути всегда используется при выполнения умного указателя. Например, при сбросе `Box<T>` происходит деаллокация пространства на куче, на которое указывает box.

В ряде языков программирования для некоторых видов данных программист должен каждый раз самостоятельно освобождать память, когда он завершает использование этими переменными, которые занимают память. Примерами могут служить указатели файлов, сокеты или запреты. Если забыть об этом, программа может достичь предела свободной памяти и завершиться со сбоем. В Ржавчине вы можете указать, что определённый отрывок рукописи должен выполняться всякий раз, когда значение выходит из области видимости, и сборщик самостоятельно будет его вставлять. Как следствие, вам не нужно заботиться о очистке памяти неиспользуемых переменных в программе, где завершается работа образца определённого вида данных - утечки памяти все равно не будет!

Вы можете задать определённый ход мыслей, который будет выполняться, когда значение выходит за пределы области видимости, применив сущность `Drop`. Сущность `Drop` требует от вас выполнения одного способа `drop`, который принимает изменяемую ссылку на `self`. Чтобы увидеть, когда Ржавчина вызывает `drop`, давайте выполняем `drop` с помощью указаний `println!`.

В приложении 15-14 показана стопка `CustomSmartPointer`, единственная не имеющая себе подобных, возможностью которой является вывод `Dropping CustomSmartPointer!`, когда образец данных выходит из области видимости, чтобы показать, когда Ржавчина использует функцию `drop`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-14/src/main.rs}}
```

<span class="caption">Приложение 15-14: Стопка <code>CustomSmartPointer</code>, использующая сущность <code>Drop</code>, куда мы поместим нашу рукопись очистки</span>

Сущность `Drop` включена во встроенный набор, поэтому нам не нужно вводить её в область видимости. Мы используем сущность `Drop` для `CustomSmartPointer` и вызываем способ `drop`, который будет вызывать макрос `println!`. Тело функции `drop` - это место, где должен располагаться весь ход мыслей, который вы захотите выполнить, когда образец данных вашего вида данных выйдет из области видимости. Мы выводим здесь писание,  чтобы наглядно отобразить, когда Ржавчина вызовет `drop`.

В `main` мы создаём два образца данных `CustomSmartPointer` и затем выводим `CustomSmartPointers created` . В конце `main` наши образцы `CustomSmartPointer` выйдут из области видимости и Ржавчина вызовет рукопись, которую мы добавили в способ `drop`, который и выведет наше окончательное сообщение. Обратите внимание, что нам не нужно вызывать способ `drop` явно.

Когда мы запустим эту программу, мы увидим следующий вывод:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-14/output.txt}}
```

Ржавчина самостоятельно вызывала `drop` в мгновение выхода наших образцов из области видимости, тем самым выполнив заданную нами рукопись. Переменные удаляются в обратном порядке их создания, поэтому `d` была удалена до `c`. Цель этого примера — дать вам наглядное представление о том, как работает способ `drop`; в обычных случаях вы будете задавать указание очистки, которое должно использовать ваш вид данных, а не выводить сообщение.

### Раннее удаление значения с помощью `std::mem::drop`

К сожалению, отключение функции самостоятельного удаления с помощью `drop` является не простым. Отключение `drop` обычно не требуется; весь смысл сущности `Drop` в том, чтобы о функции позаботились самостоятельно . Иногда, однако, вы можете захотеть очистить значение самостоятельно раньше, чем переменная выйдет из области видимости. Одним из примеров является использование умных указателей, которые управляют запретами: вы могли бы принудительно вызвать способ `drop`, который снимает запрет на очистку памяти, чтобы другая рукопись в той же области видимости могла получить запрет. Ржавчина не позволяет вызвать способ сущности `Drop` вручную; вместо этого вы должны вызвать функцию `std::mem::drop` предоставляемую встроенной библиотекой, если хотите принудительно удалить вид данных или переменную до конца области видимости.

Если попытаться вызвать способ `drop` сущности `Drop` вручную, изменяя функцию `main` приложения 15-14 так, как показано в приложении 15-15, мы получим ошибку сборщика:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-15/src/main.rs:here}}
```

<span class="caption">Приложение 15-15: Попытка вызвать способ <code>drop</code> из сущности <code>Drop</code> вручную для досрочной очистки</span>

Когда мы попытаемся собрать эту рукопись, мы получим ошибку:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-15/output.txt}}
```

Это сообщение об ошибке говорит, что мы не можем явно вызывать `drop`. В сообщении об ошибке используется понятие *уничтожитель (destructor)*, который является общим понятием программирования для функции, которая очищает образец данных. *Уничтожитель* подобен *строителю*, который создаёт образец данных. Функция `drop` в Ржавчине является определённым уничтожителем.

Ржавчина не позволяет обращаться к `drop` напрямую, потому что он все равно самостоятельно вызовет `drop` в конце `main`. Это вызвало бы ошибку *double free*, потому что в этом случае Ржавчина попытался бы дважды очистить одно и то же значение.

Невозможно отключить самостоятельную подстановку вызова `drop`, когда значение выходит из области видимости, и нельзя вызвать способ `drop` напрямую. Поэтому, если нам нужно принудительно избавиться от значения раньше времени, следует использовать функцию `std::mem::drop`.

Функция `std::mem::drop` отличается от способа `drop` сущности `Drop`. Мы вызываем её, передавая в качестве переменной значение, которое хотим принудительно уничтожить. Функция находится во встроенном наборе, поэтому мы можем изменить `main` в приложении 15-15 так, чтобы вызвать функцию `drop`, как показано в приложении 15-16:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-16/src/main.rs:here}}
```

<span class="caption">Приложение 15-16: Вызов <code>std::mem::drop</code> для принудительного удаления значения до того, как оно выйдет из области видимости</span>

Выполнение данной рукописи выведет следующий итог::

```console
{{#include ../listings/ch15-smart-pointers/listing-15-16/output.txt}}
```

Текст `Dropping CustomSmartPointer with data `some data`!`, выведенный между `CustomSmartPointer created.` и писанием `CustomSmartPointer dropped before the end of main.`, показывает, что рукопись способа `drop` вызывается для удаления `c` в этой точке.

Вы можете использовать рукопись, указанную в выполнении сущности `Drop`, чтобы сделать очистку удобной и безопасной: например, вы можете использовать её для создания своего собственного управленца памяти! С помощью сущности `Drop` и системы владения Ржавчины не нужно целенаправленно заботиться о том, чтобы освобождать мощности, потому что Ржавчина делает это самостоятельно .

Также не нужно беспокоиться о неполадках, возникающих в итоге случайной очистки значений, которые всё ещё используются: устройство управления владением, которое заверяет, что ссылки всегда действительны, также заверяет, что `drop` вызывается только один раз, когда значение больше не используется.

После того, как мы познакомились с `Box<T>` и свойствами умных указателей, познакомимся с другими умными указателями, определёнными во встроенной библиотеке.
