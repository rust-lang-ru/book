## Использование сущность-предметов, допускающих значения разных видов данных

В главе 8 мы упоминали, что одним из ограничений векторов является то, что они могут хранить переменные только одного вида данных. Мы создали обходное решение в приложении 8-9, где мы определили перечисление `SpreadsheetCell` в котором были исходы для хранения целых чисел, чисел с плавающей точкой и писания. Это означало, что мы могли хранить разные виды данных в каждой ячейке и при этом иметь вектор, представляющий строку из ячеек. Это очень хорошее решение, когда наши взаимозаменяемые переменные вектора являются видами данных с конечным набором, известными при сборке рукописи.

Однако иногда мы хотим, чтобы пользователь нашей библиотеки мог расширить набор видов данных, которые допустимы в данном случае. Чтобы показать как этого добиться, мы создадим пример средства с внешней оболочкой пользователя (GUI), который просматривает список переменных, вызывает способ `draw` для каждого из них, чтобы нарисовать его на экране - это обычный способ для средств GUI. Мы создадим библиотечное дополнение с именем `gui`, содержащее устройство библиотеки GUI. Это дополнение могло бы включать некоторые готовые виды данных для использования, такие как `Button` или `TextField`. Кроме того, пользователи дополнения `gui` захотят создавать свои собственные виды данных, которые могут быть нарисованы: например, кто-то мог бы добавить вид данных `Image`, а кто-то другой добавить вид данных `SelectBox`.

Мы не будем использовать полноценную библиотеку GUI для этого примера, но покажем, как её части будут подходить друг к другу. На мгновение написания библиотеки мы не можем знать и определить все виды данных, которые могут захотеть создать другие разработчики. Но мы знаем, что `gui` должен отслеживать множество значений различных видов данных и ему нужно вызывать способ `draw` для каждого из этих значений различного вида данных. Ему не нужно точно знать, что произойдёт, когда вызывается способ `draw`, просто у значения будет доступен такой способ для вызова.

Чтобы сделать это на языке с наследованием, можно определить предмет с именем `Component` у которого есть способ с названием `draw`. Другие предметы, такие как `Button`, `Image` и `SelectBox` наследуются от `Component` и следовательно, наследуют способ `draw`. Каждый из них может переопределить использование способа `draw`, чтобы определить своё пользовательское поведение, но средство (дополнение) может обрабатывать все виды данных, как если бы они были образцами данных `Component` и вызывать способ `draw` у них. Но поскольку в Ржавчине нет наследования, нам нужен другой способ внутренне выстроить
 `gui` библиотеку, чтобы позволить пользователям расширять её новыми видами данных.

### Определение сущности для общего поведения

Чтобы использовать поведение, которое мы хотим иметь в `gui`, определим сущность с именем `Draw`, которая будет содержать один способ с названием `draw`. Затем мы можем определить вектор, который принимает *сущность-предмет*. Сущность-предмет указывает как на образец вида данных, выполняющего указанную сущность, так и на внутреннюю таблицу, используемую для поиска способов сущности указанного вида данных во время выполнения. Мы создаём сущность-предмет в таком порядке: используем какой-нибудь вид указателя, например ссылку `&` или умный указатель `Box<T>`, затем ключевое слово `dyn`, а затем указываем соответствующую сущность. (Мы будем говорить о причине того, что сущность-предметы должны использовать указатель в разделе ["Виды данных изменяемого размера и сущность `Sized` "]<!-- ignore --> Главы 19). Мы можем использовать сущность-предметы вместо гибкого или определенного вида данных. Везде, где мы используем сущность-предмет, перечень видов данных Ржавчины проверит во время сборки, что любое значение, используемое в этой среде, будет выполнять нужную сущность у сущность-предмета. Следовательно, нам не нужно знать все возможные виды данных во время сборки.

Мы упоминали, что в Ржавчине мы воздерживаемся называть стопки и перечисления «предметами», чтобы отличать их от предметов в других языках. В стопке или перечислении данные в полях стопки и поведение в разделах `impl` разделены, тогда как в других языках данные и поведение объединены в один подход, часто обозначающийся как предмет. Тем не менее, сущность-предметы *являются* более похожими на предметы на других языках, в том смысле, что они сочетают в себе данные и поведение. Но сущность-предметы отличаются от привычных предметов тем, что не позволяют добавлять данные к имеющимся сущность-предметам. Сущность-предметы обычно не настолько полезны, как предметы в других языках: их определенная цель - обеспечить абстракцию через общее поведение.

В приложении 17.3 показано, как определить сущность с именем `Draw` с помощью одного способа с именем `draw`:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-17-03/src/lib.rs}}
```

<span class="caption">Приложение 17-3: Определение сущности <code>Draw</code></span>

Эти правила написания должны выглядеть знакомым из наших споров о том, как определять сущности в главе 10. Далее следуют новые правила написания: в приложении 17.4 определена стопка с именем `Screen`, которая содержит вектор с именем `components`. Этот вектор имеет вид данных `Box<dyn Draw>`, который и является сущность-предметом; это замена для любого вида данных внутри `Box` который использует сущность `Draw`.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-17-04/src/lib.rs:here}}
```

<span class="caption">Приложение 17-4: Определение стопки <code>Screen</code> с полем <code>components</code>, которая является вектором сущность-предметов, которые используют сущность <code>Draw</code></span>

В стопке `Screen`, мы определим способ `run`, который будет вызывать способ `draw` каждой переменной вектора `components`, как показано в приложении 17-5:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-17-05/src/lib.rs:here}}
```

<span class="caption">Приложение 17-5: Использование способа <code>run</code> у стопки  <code>Screen</code>, который вызывает способ <code>draw</code> каждого составляющих из вектора</span>

Это работает иначе, чем определение стопки, которая использует свойство общего вида данных с ограничениями сущности. Обобщённое свойство вида данных может быть заменён только одним определенным видом данных, тогда как сущность-предметы позволяют нескольким определенным видам данных замещать сущность-предмет во время выполнения. Например, мы могли бы определить стопку `Screen` используя общий вид данных и ограничение сущности, как показано в приложении 17-6:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-17-06/src/lib.rs:here}}
```

<span class="caption">Приложение 17-6: Иное выполнение стопки <code>Screen</code> и способа <code>run</code>, используя обобщённый вид данных и ограничения сущности</span>

Это исход ограничивает нас образцом `Screen`, который имеет список составляющих всех видов данных `Button` или всех видов данных `TextField`. Если у вас когда-либо будут только однородные собрания, использование обобщений и ограничений сущности является предпочтительным, поскольку определения будут мономорфизированы во время сборки для использования с определенными видами данных.

С другой стороны, с помощью способа, использующего сущность-предметы, один образец данных `Screen` может содержать `Vec<T>` который содержит `Box<Button>`, также как и `Box<TextField>`. Давайте посмотрим как это работает, а затем поговорим о влиянии на производительность во время выполнения.

### Выполнения сущности

Теперь мы добавим несколько видов данных, использующих сущность `Draw`. Мы объявим вид данных `Button`. Опять же, действительная выполнение библиотеки GUI выходит за рамки этой книги, поэтому тело способа `draw` не будет иметь никакой полезной выполнения. Чтобы представить, как может выглядеть такая выполнение, стопки `Button` может иметь поля для `width`, `height` и `label`, как показано в приложении 17-7:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-17-07/src/lib.rs:here}}
```

<span class="caption">Приложение 17-7: Стопка <code>Button</code> использует сущность <code>Draw</code></span>

Поля `width`, `height` и `label` стопки `Button` будут отличаться от, например, полей других составляющих вроде вида данных `TextField`, которая могла бы иметь те же поля и дополнительно поле `placeholder`. Каждый из видов данных, который мы хотим нарисовать на экране будет использовать сущность `Draw`, но будет использовать отличающийся рукопись способа `draw` для определения как именно рисовать определенный вид данных, например `Button` в этом примере (без действительного рукописи GUI, который выходит за рамки этой Главы). Например, вид данных `Button` может иметь дополнительный раздел`impl`, содержащий способы, относящиеся к тому, что происходит, когда пользователь нажимает кнопку. Эти исходы способов не будут применяться к видам данных вроде `TextField`.

Если кто-то использующий нашу библиотеку решает использовать стопка `SelectBox`, которая имеет `width`, `height` и поля `options`, он использует также и сущность `Draw` для вида данных `SelectBox`, как показано в приложении 17-8:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch18-oop/listing-17-08/src/main.rs:here}}
```

<span class="caption">Приложение 17-8: Другой дополнение, использующий <code>gui</code> и выполняющий сущность <code>Draw</code> у стопки <code>SelectBox</code></span>

Пользователь нашей библиотеки теперь может написать свою способ (функцию) `main` для создания образца данных `Screen`. К образцу данных `Screen` он может добавить `SelectBox` и `Button`, поместив каждый из них в `Box<T>`, чтобы он стал сущность-предметом. Затем он может вызвать способ `run` у образца данных `Screen`, который вызовет `draw` для каждого из составляющих. Приложение 17-9 показывает эту выполнение:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch18-oop/listing-17-09/src/main.rs:here}}
```

<span class="caption">Приложение 17-9: Использование сущность-предметов для хранения значений разных видов данных, выполняющих одну и ту же сущность</span>

Когда мы писали библиотеку, мы не знали, что кто-то может добавить вид данных `SelectBox`, но наша использование `Screen` могла работать с новым видом данных и рисовать его, потому что `SelectBox` использует сущность `Draw`, что означает, что он использует способ `draw`.

Эта подход, касающаяся только сообщений, на которые значение отвечает, в отличие от определенного вида данных у значения, подобна подходы *duck typing* в изменяемых строго определенных языках: если что-то ходит как утка и крякает как утка, то она должна быть утка! В выполнении способа `run` у `Screen` в приложении 17-5, `run` не нужно знать каким будет определенный вид данных каждого составляющих. Он не проверяет, является ли составляющая образцом `Button` или `SelectBox`, он просто вызывает способ `draw` составляющих. Указав `Box<dyn Draw>` в качестве вида данных значений в векторе `components`, мы определили `Screen` для значений у которых мы можем вызвать способ `draw`.

Преимущество использования сущность-предметов и системы видов данных Ржавчины для написания рукописи, похожего на рукопись с использованием подхода duck typing состоит в том, что нам не нужно во время выполнения  проверять использует ли значение в векторе определенный способ или беспокоиться о получении ошибок, если значение не использует способ, мы все равно вызываем способ. Ржавчина не собирает нашу рукопись, если значения не используют сущность, которой нужен сущность-предмета..

Например, в приложении 17-10 показано, что произойдёт, если мы попытаемся создать `Screen` с `String` в качестве его составляющих:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch18-oop/listing-17-10/src/main.rs}}
```

<span class="caption">Приложение 17-10: Попытка использования вида данных, который не использует сущность для сущность-предмета</span>

Мы получим ошибку, потому что `String` не использует сущность `Draw`:

```console
{{#include ../listings/ch18-oop/listing-17-10/output.txt}}
```

Эта ошибка даёт понять, что либо мы передаём в составляющая `Screen` что-то, что мы не собирались передавать и мы тогда должны передать другой вид данных, либо мы должны исполнить сущность `Draw` у вида данных `String`, чтобы `Screen` мог вызывать `draw` у него.

### Сущность-предметы выполняют изменяемое управление (связывание)

Вспомните, в разделе [«Производительность рукописи, использующего обобщённые виды данных»](ch10-01-syntax.html#performance-of-code-using-generics)<!-- ignore --> в главе 10 наше обсуждение этапа мономорфизации, выполняемого сборщиком, когда мы используем ограничения сущностей для обобщённых видов данных: сборщик порождает частные выполнения способов (функций) и способов для каждого определенного вида данных, который мы применяем для свойства обобщённого вида данных. Рукопись, которая получается в итоге мономорфизации, использует *постоянное управление* , то есть когда сборщик знает, какой способ вы вызываете во время сборки. Это противоположно *изменяемому управлению*, когда сборщик не может определить во время сборки, какой способ вы вызываете. В случае изменяемого управления сборщик создает рукопись, которая во время выполнения определит, какой способ нужно вызвать.

Когда мы используем сущность-предметы, Ржавчина должна использовать изменяемое управление. Сборщик не знает всех видов данных, которые могут быть использованы с рукописью, использующим сущность-предметы, поэтому она не знает, какой способ выполнен для какого вида данных при вызове. Вместо этого, во время выполнения, Ржавчина использует указатели внутри сущность-предмета, чтобы узнать какой способ вызвать. Такой поиск вызывает дополнительные затраты во время исполнения, которые не требуются при постоянном управлении. Изменяемая управление также не позволяет сборщику выбрать встраивание рукописи способа, что в свою очередь делает невозможными некоторые переработки. Однако мы получили дополнительную гибкость в рукописи, которую мы написали в приложении 17-5, и которую смогли поддержать в приложении 17-9, поэтому все "за" и "против" нужно рассматривать в совокупности.


["Виды данных изменяемого размера и сущность `Sized` "]: ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait