## Правила написания способов

*Способы* похожи на способы (функции): мы объявляем их с помощью ключевого слова `fn` и имени, они могут иметь свойства и возвращаемое значение, и они содержат рукопись, запускающуюся в случае вызова способа. В отличие от способов (функций), способы определяются в среде стопки (или предмета перечисления или сущности, которые мы рассмотрим в [главе 6]<!-- ignore --> и [главе 17]<!-- ignore --> соответственно), а их первым свойством всегда является `self`, представляющее собой образец данных стопки, с которым вызывается этот способ.

### Определение способов

Давайте изменим способ (функцию) `area` так, чтобы она имела образец данных `Прямоугольник` в качестве входного свойства и сделаем её способом `area`, определённым для стопки `Прямоугольник`, как показано в приложении 5-13:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-13/src/main.rs}}
```

<span class="caption">Приложение 5-13: Определение способа <code>area</code> для стопки <code>Прямоугольник</code></span>

Чтобы определить способ (функцию) в среде `Прямоугольник`, мы создаём раздел`impl` (implementation - выполнение) для `Прямоугольник`. Всё в `impl` будет связано с видом данных - стопкой `Прямоугольник`. Затем мы перемещаем способ (функцию) `area` внутрь узорчатых скобок `impl` и меняем первое (и в данном случае единственное) свойство на `self` в ярлыке и в теле. В `main`, где мы вызвали способ (функцию) `area` и передали `прямоугольник1` в качестве переменной, теперь мы можем использовать *правила написания способов* для вызова самого способа `area` нашего образца данных `Прямоугольник`. По правилам написания способов указание самого способа следует после образца: после переменной мы добавляем точку, за которой следует имя способа, круглые скобки и любые переменные, пример: `прямоугольник1.area`, где `прямоугольник1` - переменная, а `area`- сам способ.

В ярлыке способа `area` мы используем `&self` вместо `прямоугольник: &Прямоугольник`. Так `&self` на самом деле является сокращением от `self: &Self`. Внутри раздела `impl` вид данных `Self` является ярлыком вида данных, для которого выполнен раздел`impl`. Способы обязаны иметь свойство с именем `self` вида данных `Self`, поэтому Ржавчина позволяет вам сокращать его, используя только имя `self` на месте первого свойства. Обратите внимание, что нам по-прежнему нужно использовать знак заимствования (ссылки) `&` перед сокращением `self`, чтобы указать на то, что этот способ заимствует образец данных `Self`, точно так же, как мы делали это в `прямоугольник: &Прямоугольник`. Как и любое другое свойство, способы могут брать во владение `self`, заимствовать неизменяемый `self`, как мы поступили в данном случае, или заимствовать изменяемый `self`.

Мы выбрали `&self` здесь по той же причине, по которой использовали `&Прямоугольник` в исполнении рукописи с функцией: мы не хотим брать стопку во владение, мы просто хотим получить данные из стопки, а не изменять данные в ней. Если бы мы хотели изменить образец данных,в котором мы вызывали способ силами самого способа, то мы бы использовали `&mut self` в качестве первого свойства. Наличие способа, который берёт образец данных во владение, используя только `self` в качестве первого свойства, является редким; это средство обычно используется, когда способ превращает `self` во что-то ещё, и вы хотите запретить вызывающей стороне использовать исходный образец данных после превращения.

Основная причина использования способов вместо способов (функций), помимо правил написания способа, где нет необходимости повторять вид данных `self` в ярлыке каждого способа, заключается в согласовании рукописи. Мы пометили все, что мы можем сделать с образцом вида данных, в один раздел `impl` вместо того, чтобы заставлять будущих пользователей нашей рукописи искать доступные возможности `Прямоугольник` в разных местах предоставляемой нами библиотеки.

Обратите внимание, что мы можем дать способу то же имя, что и одному из полей стопки. Например, для `Прямоугольник` мы можем определить способ, также названный `width`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/no-listing-06-method-field-interaction/src/main.rs:here}}
```

Здесь мы определили, чтобы способ `width` возвращал значение `true`, если значение в поле `width` образца данных больше `0`, и значение `false`, если значение равно `0`, но мы можем использовать поле в способе с тем же именем для любых целей. В `main`, когда мы ставим после `прямоугольник1.width` круглые скобки `()`, Ржавчина знает, что мы имеем в виду способ `width`. Второй исход - когда мы не используем круглые скобки `()` , Ржавчина понимает, что мы имеем в виду вид данных стопки - а именно поле `width`.

Часто, но не всегда, когда мы создаём способы с тем же именем, что и у поля, мы хотим, чтобы он только возвращал значение одноимённого поля и больше ничего не делал. Подобные способы называются *получателями (getter)*, и Ржавчина не выполняет их самостоятельно для полей стопки, как это делают некоторые другие языки. Получтаели полезны, поскольку вы можете сделать поле закрытым, а способ открытым и, таким образом, включить доступ только для чтения к этому полю как часть общедоступного API вида. Мы обсудим, что такое открытость и закрытость, и как обозначить поле или способ в качестве открытого или закрытого в [главе 7]<!-- ignore -->.

> ### Где используется приказчик `->`?
>
> В языках C и C++, используются два различных приказчика для вызова способов: используется `.`, если вызывается способ непосредственно у образца данных стопки и используется `->`, если вызывается способ для указателя на предмет. Другими словами, если предмет`object` является указателем, то вызовы способа `object->something()` и ` (*object).something()` являются равнозначными.
>
> Ржавчина не имеет равнозначного приказчика `->`, наоборот, в Ржавчине есть возможность называемая *самостоятельное обращение по ссылке и разыменование* (automatic referencing and dereferencing). Вызов способов является одним из немногих мест в Ржавчине, в котором есть такое поведение.
>
> Вот как это работает: когда вы вызываете способ `object.something()`, Ржавчина самостоятельно добавляет `&`, `&mut` или  `*`, таким образом, чтобы предмет `object` соответствовал ярлыку способа. Другими словами, это то же самое:
>
> <!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 -->
>
> ```rust
> # #[derive(Debug,Copy,Clone)]
> # struct Point {
> #     x: f64,
> #     y: f64,
> # }
> #
> # impl Point {
> #    fn distance(&self, other: &Point) -> f64 {
> #        let x_squared = f64::powi(other.x - self.x, 2);
> #        let y_squared = f64::powi(other.y - self.y, 2);
> #
> #        f64::sqrt(x_squared + y_squared)
> #    }
> # }
> # let p1 = Point { x: 0.0, y: 0.0 };
> # let p2 = Point { x: 5.0, y: 6.5 };
> p1.distance(&p2);
> (&p1).distance(&p2);
> ```
>
> Первый пример выглядит намного понятнее. Самостоятельный вывод ссылки работает потому, что способы имеют понятного получателя - вид данных `self`. Учитывая получателя и имя способа, Ржавчина может точно определить, что в данном случае делает рукопись: считывает ли способ (`&self`), делает ли изменение (`&mut self`) или поглощает (`self`). То обстоятельство, что Ржавчина делает заимствование неявным для принимающего способа, в значительной степени способствует тому, чтобы сделать владение удобным на опыте.

### Способы с несколькими свойствами

Давайте применим наши знания по части использовании способов, выполнив второй способ в стопке `Прямоугольник`. На этот раз мы хотим, чтобы образец данных `Прямоугольник` брал другой образец данных `Прямоугольник` и возвращал `true`, если второй `Прямоугольник` может полностью поместиться внутри `self` (первый `Прямоугольник`); в противном случае он должен вернуть `false`. То есть, как только мы определим способ `can_hold`, мы хотим иметь возможность написать программу, показанную в Приложении 5-14.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-14/src/main.rs}}
```

<span class="caption">Приложение 5-14: Использование ещё не написанного способа <code>can_hold</code></span>

Ожидаемый итог будет выглядеть следующим образом, т.к. оба размера в образце `rect2` меньше, чем размеры в образце `прямоугольник1`, а `rect3` больше, чем `прямоугольник1`:

```text
Can прямоугольник1 hold rect2? true
Can прямоугольник1 hold rect3? false
```

Мы знаем, что хотим определить способ, поэтому он будет находится в разделе `impl Прямоугольник` . Имя способа будет `can_hold`, и он будет принимать неизменяемое заимствование на другой `Прямоугольник` в качестве свойства. Мы можем сказать, какой это будет вид свойства, посмотрев на рукопись вызывающего способа `прямоугольник1.can_hold(&rect2)`: сам способ `can_hold` передаёт заимствование на стопку `&rect2` , которое является неизменяемым заимствованием образца данных `rect2` вида данных стопка `Прямоугольник`. В этом есть смысл, потому что нам нужно только получить данные из стопки `rect2` (а не вносить изменения или владеть ими, что означало бы, что нужно изменяемое заимствование), и мы хотим, чтобы `main` сохранила право собственности на образец данных `rect2`, чтобы мы могли использовать его снова после вызова способа `can_hold`. Возвращаемое значение способом `can_hold` имеет разумный вид данных, а его выполнение (вызов способа) проверяет, являются ли ширина и высота `self` больше, чем ширина и высота другого образца данных - стопки `Прямоугольник` соответственно. Давайте добавим новый способ `can_hold` в `impl` раздел из приложения 5-13, как показано в приложении 5-15.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-15/src/main.rs:here}}
```

<span class="caption">Приложение 5-15: Использование способа <code>can_hold</code> для <code>Прямоугольник</code>, принимающего другой образец данных <code>Прямоугольник</code> в качестве свойства</span>

Когда мы запустим рукопись с функцией `main` приложения 5-14, мы получим желаемый вывод. Способы могут принимать несколько свойств, которые мы добавляем в ярлык после первого  свойства `self`, и эти свойства работают так же, как свойства в способ (функция)х.

### Сопряженные способы (функции)

Все способы (функции), определённые в разделе `impl`, называются *сопряженными способами (функциями)*, потому что они сопряжены с видом данных, указанным после ключевого слова `impl`. Мы можем определить сопряженные способы (функции), которые не имеют `self` в качестве первого свойства (и, следовательно, не являются способами), потому что им не нужен образец вида данных для работы. Мы уже использовали одну подобную способ (функцию): вызов `String::from` определённой для вида данных `String`.

Сопряженные способы (функции), не являющиеся способами, часто используются для строителей, возвращающих новый образец данных стопки. Их часто называют `new`, но `new` не является особым именем и не встроена в язык. Например, мы можем предоставить сопряженную способ (функцию) с именем `square`, которая будет иметь одно свойство размера и использовать его как ширину и высоту, что упростит создание квадратного `Прямоугольник`, вместо того, чтобы указывать одно и то же значение дважды:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/no-listing-03-associated-functions/src/main.rs:here}}
```

Ключевые слова `Self` в возвращаемом виде данных и в теле способы (функции) являются ярлыками для вида данных, указанного после ключевого слова `impl`, которым в данном случае является `Прямоугольник`.

Чтобы вызвать эту сопряженную способ (функцию), используются правила написания `::` с именем стопки, например `let sq = Прямоугольник::квадрат(3);`. Эта способ (функция) находится в пространстве имён стопки. Правила написания `::` используются как для сопряженных способов (функций), так и для пространств имён, созданных разделами. Мы обсудим разделы в [главе 7]<!-- ignore -->.

### Несколько разделов `impl`

Каждая стопка может иметь несколько `impl`. Например, Приложение 5-15 равнозначно рукописи, указанной в приложении 5-16, в котором каждый способ находится в своём собственном разделе `impl`.

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-16/src/main.rs:here}}
```

<span class="caption">Приложение 5-16: Переписанное Приложение 5-15 с использованием нескольких <code>impl</code></span>

Здесь нет причин разделять способы на несколько `impl`, но это допустимые правила написания. Мы увидим случай, когда несколько `impl` могут оказаться полезными, в Главе 10, рассматривающей обобщённые виды данных и свойства.

## Итоги

Стопки позволяют создавать собственные виды данных, которые имеют смысл в вашей предметной области. Используя стопки, вы храните сопряженные друг с другом отрывки данных и даёте название частям данных, чтобы ваша рукопись была более понятной. Способы позволяют определить поведение, которое имеют образцы ваших стопок, а сопряженные способы (функции) позволяют привязать возможность к вашей стопке, не обращаясь к её образцу данных.

Но стопки — не единственный способ создавать собственные виды данных: давайте обратимся к перечислениям в Ржавчине, чтобы добавить ещё одно средство в свой набор.


[главе 6]: ch06-00-enums.html
[главе 17]: ch17-02-trait-objects.md
[главе 7]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword
[главе 7]: ch07-02-defining-modules-to-control-scope-and-privacy.html
