## Синтаксис метода

*Методы* похожи на функции: они объявлены с помощью ключевого слова `fn` и его имени. Они могут иметь параметры и возвращаемое значение, могут содержать некоторый код, который выполняется при вызове из другого места. Тем не менее, методы отличаются от функций тем, что они определены внутри контекста структуры (также перечисления или объекта-типажа, которые мы рассмотрим в главе 6 и 17, соответственно), а их первым параметром всегда является `self`, который представляет экземпляр структуры для которого этот метод будет вызван.

### Определение методов

Давайте изменим функцию `area` так, чтобы она имела экземпляр `Rectangle` в качестве параметра и сделаем её методом `area`, определённым для структуры `Rectangle`, как показано в листинге 5-13:

<span class="filename">Файл: src/main.rs</span>

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```

<span class="caption">Пример 5-13: Определение метода <code>area</code> в структуре <code>Rectangle</code></span>

Для определения функции в контексте типа `Rectangle`, мы начинаем блок `impl` (implementation - реализация). Затем переносим функцию `area` внутрь фигурных скобок `impl` и меняем первый (в данном случае единственный) параметр в сигнатуре на `self`, и далее везде в теле метода. В `main`, там где мы вызывали функцию `area` и передавали ей переменную `rect1` в качестве аргумента, теперь можно использовать *синтаксис метода* для вызова метода `area` на экземпляре типа `Rectangle`. Синтаксис метода идёт после экземпляра: мы добавляем точечную нотацию за которой следует название метода, круглые скобки и любые аргументы.

В сигнатуре `area`, используется `&self` вместо `rectangle: &Rectangle` потому что Rust знает, что тип  `self` является типом `Rectangle`, так как данный метод находится внутри `impl Rectangle` контекста. Заметьте, всё ещё нужно использовать `&` перед `self`, как мы делали `&Rectangle`. Методы могут принимать во владение `self`, заимствовать неизменный `self`, как делалось ранее или заимствовать изменяемый `self`, как любые другие параметры.

Мы выбрали `&self` здесь по той же причине, по которой использовали `&Rectangle` в версии кода с функцией: мы не хотим брать структуру во владение, а мы просто хотим прочитать данные в структуре, а не писать в неё. Если бы мы хотели изменить экземпляр, у которого вызываем метод как часть того, что этот метод выполняет, то мы бы использовали `&mut self` в качестве первого параметра. Наличие метода, который берёт экземпляр во владение, используя только `self` в качестве первого параметра является редким; эта техника обычно используется, когда метод превращает `self` во что-то ещё, и вы хотите запретить вызывающей стороне использовать исходный экземпляр после преобразования.

Основным преимуществом использования методов вместо функций, в дополнение к использованию синтаксиса метода, где не нужно повторять тип `self` в каждой сигнатуре метода, является организация кода. Мы собрали все, что мы можем сделать с экземпляром типа в одном блоке `impl`, не заставляя будущих пользователей нашего кода искать предоставленные возможности `Rectangle` в разных местах библиотеки.

> ### Где используется оператор `->`?
> В языках C++, используются два различных оператора для вызова методов: используется `.`, если вызывается метод непосредственно у экземпляра структуры и используется `->`, если вызывается метод из ссылки на объект. Другими словами, если `object` является ссылкой, то вызовы метода `object->something()` и ` (*object).something()` являются аналогичными.
> Rust не имеет эквивалента оператора `->`, наоборот, в Rust есть функциональность, которая называется *автоматическое разыменование ссылки*. Вызов методов является одним из немногих мест в Rust, в котором есть такое поведение.
> Вот как это работает: когда вы вызываете метод `object.something()`, Rust автоматически добавляет `&`, `&mut` или  `*`, таким образом, чтобы `object` соответствовал сигнатуре метода. Другими словами, следующий код является одинаковым:
> ```rust
> #[derive(Debug,Copy,Clone)]
> struct Point {
>    x: f64,
>    y: f64,
> }
>
> impl Point {
>    fn distance(&self, other: &Point) -> f64 {
>       let x_squared = f64::powi(other.x - self.x, 2);
>       let y_squared = f64::powi(other.y - self.y, 2);
>
>       f64::sqrt(x_squared + y_squared)
>    }
> }
>
> fn main() {
>    let p1 = Point { x: 0.0, y: 0.0 };
>    let p2 = Point { x: 5.0, y: 6.5 };
>    p1.distance(&p2);
>    (&p1).distance(&p2);
> }
> ```
> Первый пример выглядит намного яснее. Это автоматическое поведение ссылок работает потому, что методы имеют ясный приёмник - тип `self` . Учитывая получателя и имя метода, Rust может точно определить, является ли метод для чтения (`&self`), для изменения (`&mut self`) или поглощает (`self`). Факт в том, что Rust делает заимствование неявным для принимающего метода, большой частью предназначено для того чтобы сделать владение эргономичным на практике.

### Методы с несколькими параметрами

Давайте попробуем использование методов, реализовав второй метод у структуры `Rectangle`. На этот раз мы хотим, чтобы экземпляр `Rectangle` использовал другой экземпляр типа `Rectangle` и возвращал `true`, если второй `Rectangle` может полностью разместиться внутри площади экземпляра `self` ; в противном случае он должен возвращать `false` . То есть мы хотим иметь возможность написать программу, показанную в листинге 5-14, в которой определили метод `can_hold`.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 10, height: 40 };
    let rect3 = Rectangle { width: 60, height: 45 };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
}
```

<span class="caption">Листинг 5-14: Использование ещё не написанного метода <code>can_hold</code></span>

И ожидаемый результат будет выглядеть следующим образом, потому что оба значения в экземпляре `rect2` меньше, чем размеры в экземпляре `rect1`, то `rect3` шире, чем `rect1` :

```text
Can rect1 hold rect2? true
Can rect1 hold rect3? false
```

Мы знаем, что хотим определить метод, поэтому он будет находится в `impl Rectangle` блоке. Имя метода будет `can_hold` , и оно будет принимать неизменяемое заимствование на другой `Rectangle` в качестве параметра. Мы можем сказать, какой это будет тип параметра, посмотрев на код вызывающего метода: метод `rect1.can_hold(&rect2)` передаёт в него  `&rect2` , который является неизменяемым заимствованием экземпляра `rect2` типа `Rectangle`. В этом есть смысл, потому что нам нужно только читать `rect2` (а не писать, что означало бы, что нужно изменяемое заимствование), и мы хотим, чтобы `main` сохранил право собственности на экземпляр `rect2`, чтобы мы могли использовать его снова после вызов метода `can_hold` . Возвращаемое значение `can_hold` имеет двоичный тип, а реализация проверит, являются ли ширина и высота `self` больше, чем ширина и высота другого `Rectangle` , соответственно. Давайте добавим новый метод `can_hold` в `impl` блок из листинга 5-13, как показано в листинге 5-15.

<span class="filename">Файл: src/main.rs</span>

```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
#
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
```

<span class="caption">Листинг 5-15: Реализация метода <code>can_hold</code> для структуры<code>Rectangle</code>, который принимает другой экземпляр <code>Rectangle</code> в качестве параметра</span>

Когда мы запустим код с функцией `main` листинга 5-14, мы получим желаемый вывод. Методы могут принимать несколько параметров, которые мы добавляем в сигнатуру после первого  параметра `self` , и эти параметры работают так же, как параметры в функциях.

### Ассоциированные функции

Ещё одной полезной особенностью блоков `impl` является то, что мы можем определить функции внутри блоков `impl`, которые *не* принимают `self` в качестве параметра. Они называются *ассоциированными функциями*, потому что они связаны со структурой. Они все ещё функции, а не методы, потому что у них нет экземпляра структуры над которой они могут работать. Вы уже использовали ассоциированную функцию `String::from`.

Ассоциированные функции часто используются в качестве конструкторов, которые будут возвращать новый экземпляр структуры. Например, мы могли бы предоставить ассоциированную функцию, которая будет иметь один параметр измерения и использовать его как ширину и высоту, тем самым облегчая создание квадратного `Rectangle` прямоугольника, вместо указания одно и того же значение дважды:

<span class="filename">Файл: src/main.rs</span>

```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
#
impl Rectangle {
    fn square(size: u32) -> Rectangle {
        Rectangle { width: size, height: size }
    }
}
```

Чтобы вызвать эту ассоциированную функцию, используется синтаксис `::` с именем структуры; пример `let sq = Rectangle::square(3);`. Эта функция относится к структуре: синтаксис `::` используется как для ассоциированных функций, так и для пространства имён, созданные модулями. Мы обсудим модули в главе 7.

### Несколько блоков `impl`

Для каждой структуры разрешено иметь множество `impl` блоков. Например, листинг 5-15 является эквивалентным коду из листинга 5-16, который описывает метод в своём отдельном блоке `impl`.

```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
#
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
```

<span class="caption">Листинг 5-16: Переписанный листинг 5-15 с использованием нескольких блоков <code>impl</code></span>

В данном случае нет причин разделять эти методы на несколько блоков `impl`, но это тоже является правильным синтаксисом. Мы увидим случай, в котором полезно иметь несколько `impl` блоков в главе 10, где мы обсудим обобщённые типы и типажи.

## Итоги

Структуры позволяют создавать собственные типы, которые имеют смысл в вашей предметной области. Используя структуры, вы храните ассоциированные друг с другом фрагменты данных и даёте название частям данных, чтобы ваш код был более понятным. Методы позволяют определить поведение, которое имеют экземпляры ваших структур, а ассоциированные функции позволяют привязать функциональность к вашей структуре, не обращаясь к её экземпляру.

Но структуры - это не единственный способ создания пользовательских типов: давайте обратимся к перечислениям в Rust, чтобы добавить ещё один инструмент в ваш набор.
