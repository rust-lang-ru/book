## Хранение списков значений в векторах

Первым видом собрания, который мы разберём, будет вид данных `Vec<T>`, также известный как <em>вектор</em> (vector). Векторы позволяют хранить более одного значения в единой стопке данных, хранящей значения в памяти одно за другим. Векторы могут хранить данные только одного вида данных. Их удобно использовать, когда нужно хранить список значений, например, список написанных строк из файла, или список цен товаров в корзине покупок.

### Создание нового вектора

Чтобы создать новый пустой вектор, мы вызываем функцию `Vec::new`, как показано в приложении 8-1.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-01/src/main.rs:here}}
```

<span class="caption">Приложение 8-1: Создание нового пустого вектора для хранения значений вида данных <code>i32</code></span>

Обратите внимание, что здесь мы добавили изложение вида данных. Поскольку мы не вставляем никаких значений в этот вектор, Ржавчина не знает, какие значения мы собираемся хранить. Это важная особенность. Векторы выполнены с использованием обобщённых видов данных; мы рассмотрим, как использовать обобщённые виды данных с вашими собственными видами данных в Главе 10. А пока знайте, что вид данных `Vec<T>`, предоставляемый встроенной библиотекой, может хранить любой вид данных. Когда мы создаём новый вектор для хранения определенного вида данных, мы можем указать этот вид данных в угловых скобках. В приложении 8-1 мы сообщили Ржавчине, что вектор `Vec<T>` в переменной `v` будет хранить значения вида данных `i32`.

Чаще всего вы будете создавать `Vec<T>` с начальными значениями. Ржавчина может определить вид данных присваиваемых вами значений, но иногда вам всё же придётся указывать изложение вида данных. Для удобства, Ржавчина предоставляет макрос `vec!`, который создаст новый вектор, содержащий заданные вами значения. В приложении 8-2 создаётся новый вектор `Vec<i32>`, который будет хранить значения `1`, `2` и `3`. Числовым видом данных является `i32`, потому что это вид данных по установлен умолчанию для целочисленных значений, о чём упоминалось в разделе [“Виды данных”] Главы 3.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-02/src/main.rs:here}}
```

<span class="caption">Приложение 8-2: Создание нового вектора, содержащего значения</span>

Поскольку мы указали начальные значения вида данных `i32`, Ржавчина может сделать вывод, что вид данных переменной `v` это `Vec<i32>` и изложение вида данных здесь не нужно. Далее мы посмотрим как изменять вектор.

### Изменение вектора

Чтобы создать вектор и затем добавить к нему переменные, можно использовать способ `push`, показанный в приложении 8-3.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-03/src/main.rs:here}}
```

<span class="caption">Приложение 8-3: Использование способа <code>push</code> для добавления значений в вектор</span>

Как и с любой переменной, если мы хотим изменить её значение, нам нужно сделать её изменяемой с помощью ключевого слова `mut`, что обсуждалось в Главе 3. Все числа, которые мы помещаем в вектор имеют вид данных `i32` по умолчанию, поэтому Ржавчина с лёгкостью сама определяет вид данных `вектора`, по этой причине здесь не требуется изложение вида данных вектора как `Vec<i32>`.

### Чтение данных вектора

Есть два способа сослаться на значение, хранящееся в векторе: с помощью порядкового указателя или способа `get` . В следующих примерах для большей ясности мы указали виды данных значений, возвращаемых этими функциями.

В приложении 8-4 показаны оба способа доступа к значению в векторе: с помощью правил порядка и с помощью способа `get`.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-04/src/main.rs:here}}
```

<span class="caption">Приложение 8-4: Использование правил порядка и способа <code>get</code>, для доступа к переменной ряда в векторе</span>

Обратите внимание здесь на пару подробностей. Мы используем значение порядкового указателя `2` для получения третьей переменной: векторы упорядочиваются начиная с нуля. Указывая `&` и `[]` мы получаем ссылку на переменную по указанному порядковому указателю. Когда мы используем способ `get`,  содержащего порядковый указатель, переданный в качестве переменной, мы получаем вид данных `Option<&T>`, который мы можем проверить с помощью `match`.

Причина, по которой Ржавчина предоставляет два способа ссылки на переменную, заключается в том, что вы можете выбрать, как программа будет себя вести, когда вы попытаетесь использовать значение порядкового указателя за пределами границ. В качестве примера давайте посмотрим, что происходит, когда у нас есть вектор из пяти переменных, а затем мы пытаемся получить доступ к переменной ряда с порядковым указателем 100 с помощью каждого способа, как показано в приложении 8-5.

```rust,should_panic,panics
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-05/src/main.rs:here}}
```

<span class="caption">Приложение 8-5: Попытка доступа к переменной с порядковым указателем 100 в векторе, содержащем всего пять переменных</span>

Когда мы запускаем эту рукопись, первая строка с `&v[100]` вызовет сбой программы, потому что происходит попытка получить ссылку на несуществующую переменную. Такой подход лучше всего использовать, когда вы хотите, чтобы ваша программа со сбоем завершила работу при попытке доступа к переменной ряда за пределами границ вектора.

Когда способу `get` передаётся порядковый указатель, который находится за пределами границ вектора, он без сбоя возвращает `None`. Вы могли бы использовать такой подход, если доступ к переменной ряда за пределами границ вектора происходит время от времени при обычных обстоятельствах. Тогда ваша рукопись будет знать что делать для обработки наличия `Some(&element)` или `None`, как обсуждалось в Главе 6. Например, порядковый указатель может исходить от человека, вводящего число. Если пользователь случайно введёт слишком большое число, то программа получит значение `None` и у вас будет возможность сообщить пользователю, сколько переменных находится в текущем векторе, и дать ему возможность ввести допустимое значение. Такое поведение было бы более дружелюбным для пользователя, чем внезапный сбой программы из-за опечатки!

Когда у программы есть действительная ссылка, borrow checker (средство проверки заимствований), обеспечивает соблюдение правил владения и заимствования (описанные в Главе 4), чтобы обеспечить, что эта ссылка и любые другие ссылки на содержимое вектора остаются действительными. Вспомните правило, которое гласит, что у вас не может быть изменяемых и неизменяемых ссылок в одной и той же области. Это правило применяется в приложении 8-6, где мы храним неизменяемую ссылку на первую переменную вектора и затем пытаемся добавить переменную в конец вектора. Данная программа не будет работать, если мы также попробуем сослаться на данную переменную позже в функции:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-06/src/main.rs:here}}
```

<span class="caption">Приложение 8-6: Попытка добавить некоторую переменную в вектор, в то время когда есть ссылка на переменную вектора</span>

Сборка этой рукописи приведёт к ошибке:

```console
{{#include ../listings/ch08-common-collections/listing-08-06/output.txt}}
```

Рукопись в приложении 8-6 может выглядеть так, как будто она должна работать. Почему ссылка на первую переменную должна заботиться об изменениях в конце вектора? Эта ошибка возникает из-за особенности того, как работают векторы: векторы размещают значения в памяти друг за другом. Добавление новой переменной в конец вектора требует чтобы была свободная память в куче. Если в куче нет достаточного места, чтобы разместить все переменные - требуется выделение новой памяти из ОЗУ и переноса всего текущего содержимого вектора в новое пространство. В этом случае, ссылка на первую переменную будет указывать на освобождённую память. Правила заимствования предотвращают сбои программ в таком случае.

> Примечание: Дополнительные сведения о использовании вида данных `Vec<T>` смотрите в разделе ["The Rustonomicon"](https://doc.rust-lang.org/nomicon/vec/vec.html).

### Перебор значений в векторе

Для доступа к каждой переменной вектора по очереди, мы перебираем все переменные, а не используем порядковые указатели, для доступа к определенной переменной. В приложении 8-7 показано, как использовать круговорот `for` для получения неизменяемых ссылок на каждую переменную в векторе значений вида данных `i32` и их вывода.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-07/src/main.rs:here}}
```

<span class="caption">Приложение 8-7: Вывод каждой переменной вектора, при помощи повторения по переменным, содержащимся в векторе с помощью круговорота <code>for</code></span>

Мы также можем повторять изменяемые ссылки на каждую переменную изменяемого вектора, чтобы вносить изменения во все переменные. Круговорот `for` в приложении 8-8 добавит `50` к каждой переменной.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-08/src/main.rs:here}}
```

<span class="caption">Приложение 8-8: Повторение и изменение переменных вектора по изменяемым ссылкам</span>

Чтобы изменить значение на которое ссылается изменяемая ссылка, мы должны использовать приказчик разыменования ссылки `*`. Прежде чем использовать приказчик `+=` с переменной `i`  мы применяем разыменование `*` . Мы поговорим подробнее об приказчике разыменования в разделе [“Следование по указателю к значению с помощью приказчика разыменования”] Главы 15.

Перебор вектора, будь то неизменяемый или изменяемый, безопасен из-за правил проверки заимствования. Если бы мы попытались вставить или удалить переменные в телах круговорота `for` в приложениях 8-7 и 8-8, мы бы получили ошибку сборщика. Ошибка подобна той, которую мы получили с рукописью в приложении 8-6. Ссылка на вектор, содержащийся в круговороте for, предотвращает одновременное изменение всего вектора.

### Использование перечислений для хранения множества разных видов

Векторы могут хранить значения только одинакового вида данных. Это может быть неудобно; определённо существуют случаи когда надо хранить список переменных разных видов данных. К счастью, исходы перечисления определены в нём самом, поэтому, когда нам нужен один вид данных для представления переменных разных видов данных, мы можем использовать перечисление!

Например, мы хотим получить значения из строки в электронной таблице где некоторые столбцы строки содержат целые числа, некоторые числа с плавающей точкой, а другие - строковые значения. Можно определить перечисление, исходы которого будут содержать разные виды данных значений и тогда все исходы перечисления будут считаться одним и тем же видом: видом самого перечисления. Затем мы можем создать вектор для хранения этого перечисления и, в конечном счёте, для хранения различных видов. Мы покажем это в приложении 8-9.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-09/src/main.rs:here}}
```

<span class="caption">Приложение 8-9: Определение <code>enum</code> для хранения значений разных видов данных в одном векторе</span>

Ржавчина должна знать, какие виды данных будут в векторе во время сборки, чтобы точно знать сколько памяти в куче потребуется для хранения каждой переменной. Мы также должны чётко указать, какие виды данных разрешены в этом векторе. Если бы Ржавчина позволяла вектору содержать любой вид данных, то была бы возможность что один или несколько видов данных вызовут ошибки при выполнении действий над переменными вектора. Использование перечисления вместе с выражением `match` означает, что во время сборки Ржавчина  заверяет, что все возможные исходы будут обработаны, как обсуждалось в главе 6.

Если вы не знаете исчерпывающий набор видов данных, которые программа получит во время выполнения для хранения в векторе, то способ использования перечисления не сработает. Вместо этого вы можете использовать сущность-предмет, который мы рассмотрим в главе 17.

Теперь, когда мы обсудили некоторые из наиболее распространённых способов использования векторов, обязательно ознакомьтесь [с пособием по API вектора](https://doc.rust-lang.org/std/vec/struct.Vec.html), чтобы узнать о множестве полезных способов, определённых в `Vec<T>` встроенной библиотеки. Например, в дополнение к способу `push`, существует способ `pop`, который удаляет и возвращает последнюю переменную.

### Удаление переменных из вектора

Подобно стопкам`struct`, вектор высвобождает свою память когда выходит из области видимости, что показано в приложении 8-10.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-10/src/main.rs:here}}
```

<span class="caption">Приложение 8-10: Показано как удаляется вектор и его переменные</span>

Когда вектор удаляется, всё его содержимое также удаляется: удаление вектора означает и удаление значений, которые он содержит. Средство проверки заимствования заверяет, что любые ссылки на содержимое вектора используются только тогда, когда сам вектор действителен.

Давайте перейдём к следующему виду собрания: `String`!


[“Виды данных”]: ch03-02-data-types.html#data-types
[“Следование по указателю к значению с помощью приказчика разыменования”]: ch15-02-deref.html#following-the-pointer-to-the-value-with-the-dereference-operator