## Создание однопоточного сетевому-отдельного вычислителя

Начнём с однопоточного сетевого-отдельного вычислителя. Перед тем, как начать, давайте сделаем краткий обзор протоколов, задействованных при создании сетевых-отдельный вычислителей. подробное описание этих протоколов выходит за рамки этой книги, но краткий обзор даст вам необходимые сведения.

Двумя основными протоколами, используемыми в сетевых-отдельных вычислителях, являются *протокол передачи гипертекста* *(HTTP - Hypertext Transfer Protocol)* и *Протокол управления передачей* *(TCP - Transmission Control Protocol)*. Оба протокола являются протоколами вида *запрос-ответ* (request-response), то есть *конечный потребитель* объявляет запросы, а *отдельный вычислитель* слушает эти запросы и предоставляет ответ конечному потребителю. Содержимое этих запросов и ответов определяется протоколами.

TCP - это протокол нижнего уровня, который описывает подробности того, как сведения передаётся от одного отдельного вычислителя к другому, но не определяет, что это за сведения. HTTP строится поверх TCP, определяя содержимое запросов и ответов. Технически возможно использовать HTTP с другими протоколами, но в подавляющем большинстве случаев HTTP отправляет свои данные поверх TCP. Мы будем работать с необработанными байтами в TCP и запросами и ответами в HTTP.

### Прослушивание TCP соединения

Нашему сетевому-отдельному вычислителю необходимо прослушивать TCP-соединение, так что это первая часть, над которой мы будем работать. Обычная библиотека предлагает для этого раздел `std::net`. Сделаем новое дело обычным способом:

```console
$ cargo new hello
      Created binary (application) `hello` project
$ cd hello
```

Дл начала добавьте рукопись из приложения 20-1 в файл *src/main.rs*. Эта рукопись будет прослушивать входящие TCP потоки по адресу `127.0.0.1:7878`. Когда отдельный вычислитель примет входящий поток, он выведет `Connection established!` ("Соединение установлено!").

<span class="filename">Файл: src/main.rs</span>

```rust,no_run
{{#rustdoc_include ../listings/ch20-web-server/listing-20-01/src/main.rs}}
```

<span class="caption">Приложение 20-1: Прослушивание входящих потоков и вывод сообщения при получении потока</span>

Используя `TcpListener` мы можем слушать TCP соединения к адресу `127.0.0.1:7878`. В адресе, в его части перед двоеточием, сначала идёт IP-адрес, относящийся к вашему компьютеру (он одинаковый на каждом компьютере и не представляет определенный компьютер составителя), а часть `7878` является портом. Мы выбрали этот порт по двум причинам: HTTP обычно не используется на этом порту, поэтому маловероятно, что наш отдельный вычислитель будет враждовать с каким-нибудь другим отдельным вычислителем, который может выполняться на вашей машине, и ещё 7878 - это слово *Ржавчина*, набранное на телефоне.

Функция `bind` в этом задумки работает так же, как функция `new`, поскольку она возвращает новый образец данных `TcpListener` . Причина, по которой функция называется `bind` заключается в том, что в сетевой совокупности понятий подключение к порту для прослушивания называется «привязка к порту» (“binding to a port”).

Функция `bind` возвращает `Result<T, E>`, а это значит, что привязка может не состояться. Так, например, подключение к порту 80 предполагает наличие прав хозяина (прочие пользователи могут прослушивать порты только от 1023-го и выше), поэтому если мы попытаемся подключиться к порту 80, не будучи хозяином, привязка не сработает. Привязка также не выполнится, например, если мы запустим два образца нашей программы, прослушивающие один и тот же порт. Поскольку мы пишем простейший отдельный вычислитель в учебных целях, мы не будем беспокоиться об обработке подобных ошибок; вместо этого мы используем `unwrap` для прекращения работы программы в случае возникновения ошибок.

Способ `incoming` в `TcpListener` возвращает повторитель , который даёт нам последовательность потоков (определеннее, потоков вида данных `TcpStream` ). Один *поток* представляет собой открытое соединение между конечным потребителем и отдельный вычислителем. *Соединением* называется полный этап запроса и ответа, в котором конечный потребитель подключается к отдельному вычислителю, отдельный вычислитель порождает ответ, и отдельный вычислитель закрывает соединение. Таким образом, мы будем читать из потока `TcpStream` то, что отправил конечный потребитель, а затем записывать наш ответ в поток, для отправки его обратно конечному потребителю. В целом, круговорот `for` будет обрабатывать каждое соединение по очереди и создавать последовательность потоков, которые мы будем обрабатывать.

На текущий мгновение наша обработка потока состоит из вызова `unwrap` для завершения программы, если в потоке возникли ошибки, если же таковых не обнаружится, программа выведет сообщение. В следующем приложении мы добавим больше возможности для успешного задумки. Причиной того, что мы можем получать ошибки от способа `incoming`, когда конечный потребитель подключается к отдельному вычислителю, является то, что на самом деле мы не перебираем подключения. На самом деле мы перебираем *попытки подключения*. Подключение может не состояться по ряду причин, многие из которых зависят от операционной системы. Например, многие операционные системы имеют ограничение на количество одновременно открытых соединений, которые они могут поддерживать; при превышении этого предела новые попытки установить соединение будут приводить к ошибке, пока какие-либо из уже открытых соединений не будут закрыты.

Попробуем запустить эту рукопись! Вызовите `cargo run` в окне вызова, а затем загрузите *127.0.0.1:7878* в сетевом-обозревателе. В обозревателе должно отображаться сообщение об ошибке, например «Connection reset», поскольку отдельный вычислитель в настоящее время не отправляет обратно никаких данных. Но когда вы посмотрите на свой окно вызова, вы должны увидеть несколько сообщений, которые были выведены, когда обозреватель подключался к отдельному вычислителю!

```text
     Running `target/debug/hello`
 Connection established!
 Connection established!
 Connection established!
```

Иногда вы видите несколько сообщений, выведенных для одного запроса обозревателя; Причина может заключаться в том, что обозреватель выполняет запрос страницы, а также других источников, таких как значок *favicon.ico,* который отображается на вкладке обозревателя.

Также может быть, что обозреватель пытается подключиться к отдельному вычислителю несколько раз, потому что отдельный вычислитель не отвечает. Когда `stream` выходит из области видимости и отбрасывается в конце круговорота, соединение закрывается как часть выполнения `drop`. Обозреватели иногда обрабатывают закрытые соединения, повторяя попытки, потому что неполадка может быть временной. Важным обстоятельством является то, что мы успешно получили указатель TCP-соединения!

Не забудьте остановить программу, нажав <span class="keystroke">ctrl-c</span>, когда вы закончите выполнение определённой исполнения рукописи. Затем перезапустите программу, вызвав приказ `cargo run`, после того, как вы внесли какой-либо набор изменений, чтобы убедиться, что используется самое свежее исполнение рукописи.

### Чтение запросов

Выполняем возможности чтения запроса из обозревателя! Чтобы разделить части, связанные с получением соединения и последующим действием с ним, мы запустим новую функцию для обработки соединения. В этой новой функции `handle_connection` мы будем читать данные из потока TCP и выводить их, чтобы мы могли видеть данные, отправленные из обозревателя. Измените рукопись, чтобы он выглядел как в приложении 20-2.

<span class="filename">Файл: src/main.rs</span>

```rust,no_run
{{#rustdoc_include ../listings/ch20-web-server/listing-20-02/src/main.rs}}
```

<span class="caption">Приложение 20-2: Чтение из <code>TcpStream</code> и вывод данных</span>

Мы добавляем `std::io::prelude` и `std::io::BufReader` в область видимости, чтобы получить доступ к сущностям и видам данных, которые позволяют нам читать и писать в поток. В круговороте `for` функции `main` вместо вывода сообщения о том, что мы установили соединение, мы теперь вызываем новую функцию `handle_connection` и передаём ей `stream`.

В функции `handle_connection` мы создаём новый образец данных `BufReader`, который оборачивает изменяемую ссылку на `stream`. `BufReader` добавляет буферизацию, управляя вызовами способов сущности `std::io::Read` за нас.

Мы создаём переменную `http_request` для сбора строк запроса, который обозреватель отправляет на наш отдельный вычислитель. Мы указываем, что хотим собрать эти строки в вектор, добавляя изложение вида данных `Vec<_>`.

`BufReader` использует сущность `std::io::BufRead`, которая использует способ `lines`. Способ `lines` возвращает повторитель `Result<String, std::io::Error>`, разделяющий поток данных на части всякий раз, когда ему попадается байт новой строки. Чтобы получить все строки `String`, мы с помощью map вызываем `unwrap` у каждого `Result`. Значение `Result` может быть ошибкой, если данные не соответствуют исполнению UTF-8 или если возникли сбои с чтением из потока. Опять же, программа в промышленном исполнении должна обрабатывать эти ошибки более изящно, но мы для простоты решили прекращать работу программы в случае ошибки.

Обозреватель указывает об окончании HTTP-запроса, отправляя два знака перевода строки подряд, поэтому, чтобы получить один запрос из потока, мы забираем строки, пока не получим строку, которая является пустой строкой. После того, как мы собрали строки в вектор, мы выводим их, используя красивое отладочную разметку, чтобы мы могли взглянуть на указания, которые сетевой-обозреватель отправляет на наш отдельный вычислитель.

Попробуем эту рукопись! Запустите программу и снова сделайте запрос в сетевом-обозревателе. Обратите внимание, что мы по-прежнему будем получать в обозревателе страницу с ошибкой, но вывод нашей программы в окне вызова теперь будет выглядеть примерно так:

```console
$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
Request: [
    "GET / HTTP/1.1",
    "Host: 127.0.0.1:7878",
    "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0",
    "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
    "Accept-Language: en-US,en;q=0.5",
    "Accept-Encoding: gzip, deflate, br",
    "DNT: 1",
    "Connection: keep-alive",
    "Upgrade-Insecure-Requests: 1",
    "Sec-Fetch-Dest: document",
    "Sec-Fetch-Mode: navigate",
    "Sec-Fetch-Site: none",
    "Sec-Fetch-User: ?1",
    "Cache-Control: max-age=0",
]
```

В зависимости от вашего обозревателя итог может немного отличаться. Теперь, когда мы выводим данные запроса, мы можем понять, почему мы получаем несколько подключений из одного запроса обозревателя, посмотрев на путь после `GET` в первой строке запроса. Если все повторяющиеся соединения запрашивают */* , мы знаем, что обозреватель пытается получить */* повторно, потому что он не получает ответа от нашей программы.

Давайте разберём эти данные запроса, чтобы понять, что обозреватель запрашивает у нашей программы.

### Пристальный взгляд на HTTP запрос

HTTP - это письменный протокол и запрос имеет следующий вид:

```text
Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
```

Первая строка - это *строка запроса* , содержащая сведения о том, что запрашивает конечный потребитель. Первая часть строки запроса указывает используемый *способ* , например `GET` или `POST` , который описывает, как конечный потребитель выполняет этот запрос. Наш конечный потребитель использовал запрос `GET`, что означает, что он просит нас предоставить сведения.

Следующая часть строки запроса - это */*, которая указывает *единый определитель* *источника (URI),* который запрашивает конечный потребитель: URI почти, но не совсем то же самое, что и *единый указатель источника* *(URL)*. Разница между URI и URL-адресами не важна для наших целей в этой главе, но согласно принятых требований HTTP использует понятие URI, поэтому мы можем просто мысленно заменить URL-адрес здесь.

Последняя часть - это исполнение HTTP, которую использует конечный потребитель, а затем строка запроса заканчивается *последовательностью CRLF* . (CRLF обозначает *возврат каретки* и *перевод строки* , что является понятием из дней пишущих машинок!) Последовательность CRLF также может быть записана как `\r\n` , где `\r` - возврат каретки, а `\n` - перевод строки. Последовательность CRLF отделяет строку запроса от остальных данных запроса. Обратите внимание, что при выводе CRLF мы видим начало новой строки, а не `\r\n` .

Глядя на данные строки запроса, которые мы получили от запуска нашей программы, мы видим, что `GET` - это способ, */* - это URI запроса, а `HTTP/1.1` - это исполнение.

После строки запроса оставшиеся строки, начиная с `Host:` далее, являются заголовками. `GET` запросы не имеют тела.

Попробуйте сделать запрос из другого обозревателя или запросить другой адрес, например *127.0.0.1:7878/test* , чтобы увидеть, как изменяются данные запроса.

Теперь, когда мы знаем, что запрашивает обозреватель, давайте отправим обратно в ответ некоторые данные!

### Написание ответа

Теперь выполняем отправку данных в ответ на запрос конечного потребителя. Ответы имеют следующий вид:

```text
HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
```

Первая строка - это *строка состояния*, которая содержит исполнение HTTP, используемую в ответе, числовой рукопись состояния, который складывает итог запроса, и фразу причины, которая предоставляет письменное описание рукописи состояния. После последовательности CRLF идут любые заголовки, другая последовательность CRLF и тело ответа.

Вот пример ответа, который использует HTTP исполнения 1.1, имеет рукопись состояния 200, фразу причины OK, без заголовков и без тела:

```text
HTTP/1.1 200 OK\r\n\r\n
```

Рукопись состояния 200 - это обычный успешный ответ. писание представляет собой крошечный успешный HTTP-ответ. Давайте запишем это в поток как наш ответ на успешный запрос! Из функции `handle_connection` удалите `println!` который выводил данные запроса и заменял их рукописью из Приложения 20-3.

<span class="filename">Файл: src/main.rs</span>

```rust,no_run
{{#rustdoc_include ../listings/ch20-web-server/listing-20-03/src/main.rs:here}}
```

<span class="caption">Приложение 20-3: Запись крошечного успешного HTTP-ответа в поток</span>

Первый перевод строки определяет переменную `response`, которая содержит данные сообщения об успешном выполнении. Затем мы вызываем `as_bytes` в нашем `response`, чтобы преобразовать строковые данные в байты. Способ `write_all` в `stream` принимает вид данных `&[u8]` и отправляет эти байты непосредственно получателю. Поскольку действие `write_all` может завершиться с ошибкой, мы, как и ранее, используем `unwrap` на любом возможно ошибочном итоге. И опять, в существующем приложении здесь вам нужно было бы добавить обработку ошибок.

После этих изменений давайте запустим нашу рукопись и сделаем запрос. Мы больше не выводим никаких данных в окно вызова, поэтому мы не увидим никакого вывода, кроме сообщений от Cargo. Когда вы загрузите *127.0.0.1:7878* в сетевом-обозревателе, вы должны получить пустую страницу вместо ошибки. Вы только что вручную написали рукопись получения HTTP-запроса и отправки ответа на него!

### Возвращение существующего HTML

Давайте используем возможности чего-нибудь большего, чем просто пустой страницы. Создайте новый файл *hello.html* в корне папки вашего дела, а не в папке *src* . Вы можете ввести любую HTML-рукопись, которую вам заблагорассудится; В приложении 20-4 показан один из исходов.

<span class="filename">Файл: hello.html</span>

```html
{{#include ../listings/ch20-web-server/listing-20-05/hello.html}}
```

<span class="caption">Приложение 20-4: Пример HTML-файла для ответа на запрос</span>

Это простейший HTML5-документ с заголовком и каким-то писанием. Чтобы отдельный вычислитель возвращал его в ответ на полученный запрос, мы изменим `handle_connection`, как показано в приложении 20-5, чтобы считать HTML-файл, добавить его в ответ в качестве тела и отправить.

<span class="filename">Файл: src/main.rs</span>

```rust,no_run
{{#rustdoc_include ../listings/ch20-web-server/listing-20-05/src/main.rs:here}}
```

<span class="caption">Приложение 20-5: Отправка содержимого <em>hello.html</em> в качестве тела ответа</span>

Мы добавили способ `fs` в указание `use`, чтобы включить в область видимости раздел файловой системы встроенной библиотеки. Рукопись для чтения содержимого файла в строку должна выглядеть знакомым для вас; мы использовали его в главе 12, когда читали содержимое файла для нашего дела ввода-вывода в приложении 12-4.

Далее мы используем `format!` чтобы добавить содержимое файла в качестве тела ответа об успешном завершении. Чтобы обеспечить действительный HTTP-ответ, мы добавляем заголовок `Content-Length` который имеет размер тела нашего ответа, в данном случае размер `hello.html` .

Запустите эту рукопись приказом `cargo run` и загрузите *127.0.0.1:7878* в обозревателе; вы должны увидеть выведенный HTML в обозревателе!

В настоящее время мы пренебрегаем данные запроса в переменной `http_request` и в любом случае просто отправляем обратно содержимое HTML-файла. Это означает, что если вы попытаетесь запросить адрес *127.0.0.1:7878/something-else* в своём обозревателе, вы все равно получите тот же самый HTML-ответ. Пока что наш отдельный вычислитель очень ограничен, и не умеет делать то, что делает большинство сетевых-отдельный вычислителей. Мы хотим настроить наши ответы в зависимости от запроса и отправлять обратно HTML-файл только для правильно созданного запроса к пути */* .

### Проверка запроса и выборочное возвращение ответа

Сейчас наш сетевой-отдельный вычислитель возвращает HTML из файла независимо от того, что определенно запросил конечный потребитель. Давайте добавим проверку того, что обозреватель запрашивает */*, прежде чем вернуть HTML-файл, и будем возвращать ошибку, если обозреватель запрашивает что-то постороннее. Для этого нам нужно изменять `handle_connection`, как показано в приложении 20-6. Новый рукопись проверяет соответствует ли требуемый запросом источник с определителем */*, и содержит разделы `if` и `else`, чтобы иначе обрабатывать другие запросы.

<span class="filename">Файл: src/main.rs</span>

```rust,no_run
{{#rustdoc_include ../listings/ch20-web-server/listing-20-06/src/main.rs:here}}
```

<span class="caption">Приложение 20-6: Обрабатываем запросы для корневого источника <em>/</em> не так, как запросы для других источников</span>

Мы будем рассматривать только первую строку HTTP-запроса, поэтому вместо того, чтобы читать весь запрос в вектор, мы вызываем `next` , чтобы получить первая переменная из повторителя. Первый вызов `unwrap` заботится об обработке `Option` и останавливает программу, если в повторителе нет переменных. Второй `unwrap` обрабатывает `Result` и имеет тот же эффект, что и `unwrap`, который был в `map`, добавленном в приложении 20-2.

Затем мы проверяем переменную `request_line`, чтобы увидеть, равна ли она строке запроса, соответствующей запросу GET для пути */* . Если это так, раздел`if` возвращает содержимое нашего HTML-файла.

Если `request_line` *не* равна запросу GET для пути */*, это означает, что мы получили какой-то другой запрос. Мы скоро добавим рукопись в раздел`else`, чтобы ответить на все остальные запросы.

Запустите эту рукопись сейчас и запросите *127.0.0.1:7878* ; вы должны получить HTML в *hello.html* . Если вы сделаете любой другой запрос, например *127.0.0.1:7878/something-else* , вы получите ошибку соединения, подобную той, которую вы видели при запуске рукописи из Приложения 20-1 и Приложения 20-2.

Теперь давайте добавим рукопись из приложения 20-7 в раздел`else` чтобы вернуть ответ с рукописью состояния 404, который указывает о том, что содержание для запроса не найден. Мы также вернём HTML-рукопись для страницы, отображаемой в обозревателе, с указанием ответа конечному пользователю.

<span class="filename">Файл: src/main.rs</span>

```rust,no_run
{{#rustdoc_include ../listings/ch20-web-server/listing-20-07/src/main.rs:here}}
```

<span class="caption">Приложение  20-7: Отвечаем рукописью состояния 404 и страницей ошибки, если было запрошено что-то, отличающееся от источника <em>/</em></span>

Здесь ответ имеет строку состояния с рукописью 404 и фразу причины `NOT FOUND`. Тело ответа будет HTML из файла *404.html*. Вам нужно создать файл *404.html* рядом с *hello.html* для этой страницы ошибки; снова не стесняйтесь использовать любой HTML рукопись или пример HTML рукописи в приложении 20-8.

<span class="filename">Файл: 404.html</span>

```html
{{#include ../listings/ch20-web-server/listing-20-07/404.html}}
```

<span class="caption">Приложение 20-8: Пример содержимого страницы для отправки с любым ответом 404</span>

С этими изменениями снова запустите отдельный вычислитель. Запрос на *127.0.0.1:7878* должен возвращать содержимое *hello.html*, и любой другой запрос, как *127.0.0.1:7878/foo*, должен возвращать сообщение об ошибке HTML от *404.html*.

### Переработка рукописи

На текущий мгновение разделы `if` и `else` во многом повторяются: они оба читают файлы и записывают содержимое файлов в поток. Разница лишь в строке состояния и имени файла. Давайте сделаем рукопись более кратким, вынеся эти отличия в отдельные разделы `if` и `else`, в которых переменным будут присвоены значения строки состояния и имени файла; далее эти переменные мы сможем использовать в рукописи для чтения файла и создания ответа. В приложении 20-9 показана рукопись после изменения больших разделов `if` и `else`.

<span class="filename">Файл: src/main.rs</span>

```rust,no_run
{{#rustdoc_include ../listings/ch20-web-server/listing-20-09/src/main.rs:here}}
```

<span class="caption">Приложение 20-9: Переработка рукописи разделов <code>if</code> и <code>else</code>, чтобы они содержали только рукопись, которая отличается для каждого из случаев</span>

Теперь разделы `if` и `else` возвращают только соответствующие значения для строки состояния и имени файла в упорядоченном ряде. Затем мы используем разъединение, чтобы присвоить эти два значения `status_line` и `filename` используя образец данных в указании `let`, как обсуждалось в главе 18.

Ранее повторяющуюся рукопись теперь находится вне разделов `if` и `else` и использует переменные `status_line` и `filename`. Это позволяет легче увидеть разницу между этими двумя случаями и означает, что у нас есть только одно место для обновления рукописи, если захотим изменить работу чтения файлов и записи ответов. Поведение рукописи в приложении 20-9 будет таким же, как и в 20-8.

Потрясающие! Теперь у нас есть простой сетевой-отдельный вычислитель примерно на 40 строках рукописи Ржавчины, который отвечает на один запрос страницей с содержанием и отвечает на все остальные запросы ответом 404.

В настоящее время наш отдельный вычислитель работает в одном потоке, что означает, что он может обслуживать только один запрос за раз. Давайте разберёмся, почему это может быть неполадкой, сымитировав несколько медленных запросов. Затем мы исправим случай так, чтобы наш отдельный вычислитель мог обрабатывать несколько запросов одновременно.
