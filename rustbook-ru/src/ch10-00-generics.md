# Обобщённые виды данных, сущности и время жизни

Каждый язык программирования имеет в своём запасе производительные средства борьбы с повторением рукописи. В Ржавчине одним из таких средств являются обобщённые виды данных - *generics*. Это абстрактные подставные виды данных на место которых возможно поставить какой-либо определенный вид данных или другое свойство. Когда мы пишем рукопись, мы можем выразить поведение обобщённых видов данных или их связь с другими обобщёнными видами данных, не зная какой вид данных будет использован на их месте при сборке и запуске рукописи.

Функции могут принимать свойства некоторого "обобщённого" вида данных вместо привычных "определенных" видов данных, вроде `i32` или `String`. Подобно, функция принимает свойства с неизвестными заранее значениями, чтобы выполнять одинаковые действия над несколькими определенными значениями. На самом деле мы уже использовали обобщённые виды данных в Главе 6 (`Option<T>`), в Главе 8 (`Vec<T>` и `HashMap<K, V>`) и в Главе 9 (`Result<T, E>`). В этой главе вы узнаете, как определить собственные виды данных, функции и способы, используя возможности обобщённых видов данных.

Прежде всего, мы рассмотрим как для уменьшения повторения извлечь из рукописи некоторую общую возможность. Далее, мы будем использовать тот же рычаг для создания обобщённой функции из двух функций, которые отличаются только видом данных их свойств. Мы также объясним, как использовать обобщённые виды данных при определении стопок и перечислений.

После этого мы изучим как использовать сущности (traits) для определения поведения в обобщённом виде данных. Можно соединить сущности с обобщёнными видами данных, чтобы обобщённый вид данных мог принимать только такие виды данных, которые имеют определённое поведение, а не все подряд.

В конце мы обсудим *времена жизни (lifetimes)*, вариации обобщённых видов данных, которые дают сборщику сведения о том, как сроки жизни ссылок относятся друг к другу. Времена жизни позволяют нам указать дополнительные сведения об "одолженных" (borrowed) значениях, которая позволит сборщику удостовериться в соблюдения правил используемых ссылок в тех случаях, когда сборщик не может сделать это самостоятельно .

## Удаление повторения рукописи с помощью выделения общей возможности

В обобщениях мы можем заменить определенный вид данных на "исполнитель" (placeholder), обозначающую несколько видов данных, что позволяет удалить повторяющуюся рукопись. Прежде чем углубляться в правила написания обобщённых видов, давайте сначала посмотрим, как удалить повторение, не задействуя гибкие виды данных, путём извлечения функции, которая заменяет определённые значения исполнителем, представляющим несколько значений. Затем мы применим ту же технику для извлечения гибкой функции! Изучив, как распознать повторяющуюся рукопись, которую можно извлечь в функцию, вы начнёте распознавать повторяющуюся рукопись, которая может использовать обобщённые виды данных.

Начнём с короткой программы в приложении 10-1, которая находит наибольшее число в списке.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-01/src/main.rs:here}}
```

<span class="caption">Приложение 10-1: Поиск наибольшего числа в списке чисел</span>

Сохраним список целых чисел в переменной `number_list` и поместим первое значение из списка в переменную `largest`. Далее, переберём все переменные списка, и, если текущая переменная больше числа сохранённого в переменной `largest`, заменим значение в этой переменной. Если текущая переменная меньше или равна "наибольшему", найденному ранее, значение переменной оставим прежним и перейдём к следующей переменной списка. После перебора всех переменных списка переменная `largest` должна содержать наибольшее значение, которое в нашем случае будет равно 100.

Теперь перед нами стоит задача найти наибольшее число в двух разных списках. Для этого мы можем повторять рукопись из приложения 10-1 и использовать тот же ход мыслей в двух разных местах программы, как показано в приложении 10-2.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-02/src/main.rs}}
```

<span class="caption">Приложение 10-2: Рукопись для поиска наибольшего числа в <em>двух</em> списках чисел</span>

Несмотря на то, что рукопись программы работает, повторение рукописи утомительно и подвержено ошибкам. При внесении изменений мы должны не забыть обновить каждое место, где рукопись повторяется.

Для устранения повторения мы можем создать дополнительную абстракцию с помощью функции которая сможет работать с любым списком целых чисел переданным ей в качестве входного свойства и находить для этого списка наибольшее число. Данное решение делает рукопись более ясным и позволяет абстрактным образом выполнить распорядок поиска наибольшего числа в списке.

В приложении 10-3 мы извлекаем рукопись, которая находит наибольшее число, в функцию с именем  `largest`. Затем мы вызываем функцию, чтобы найти наибольшее число в двух списках из приложения 10-2. Мы также можем использовать эту функцию для любого другого списка значений `i32` , который может встретиться позже.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-03/src/main.rs:here}}
```

<span class="caption">Приложение 10-3: Абстрактный рукопись для поиска наибольшего числа в двух списках</span>

Функция `largest` имеет свойство с именем `list`, который представляет любой срез значений вида данных `i32`, которые мы можем передать в неё. В итоге вызова функции, рукопись выполнится с определенными, переданными в неё значениями.

Итак, вот шаги выполненные для изменения рукописи из приложения 10-2 в приложение 10-3:

1. Определить повторяющуюся рукопись.
2. Извлечь повторяющуюся рукопись и поместить ее в тело функции, определив входные и выходные значения этой рукописи в ярлыке функции.
3. Обновить и заменить два участка повторяющегося рукописи вызовом одной функции.

Далее, чтобы уменьшить повторение рукописи, мы воспользуемся теми же шагами для обобщённых видов данных. Обобщённые виды данных позволяют работать над абстрактными видами данных таким же образом, как тело функции может работать над абстрактным списком `list` вместо определенных значений.

Например, у нас есть две функции: одна ищет наибольшее значение внутри среза значений вида данных `i32`, а другая внутри среза значений вида данных `char`. Как уменьшить такое повторение? Давайте выяснять!


