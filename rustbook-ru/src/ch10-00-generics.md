# Обобщённые виды данных, сущности и времена жизни

Каждый язык программирования имеет в своём запасе производительные средства борьбы с повторением рукописи. В Ржавчине одним из таких средств являются обобщённые виды данных - *generics*. Это абстрактные подставные виды данных, на место которых возможно поставить какой-либо определенный вид данных или другое свойство. Когда мы пишем рукопись, мы можем выразить поведение обобщённых видов данных или их связь с другими обобщёнными видами данных, не зная какой вид данных будет использован на их месте при сборке и запуске рукописи.

Способы (функции) могут принимать свойства некоторого "обобщённого" вида данных вместо привычных "определенных" видов данных, вроде `i32` или `String`. Подобно, способ (функция) принимает переменные с неизвестными заранее значениями, чтобы выполнять одинаковые действия над несколькими определенными значениями. На самом деле мы уже использовали обобщённые виды данных в Главе 6 (`Option<T>`), в Главе 8 (`Vec<T>` и `HashMap<K, V>`) и в Главе 9 (`Result<T, E>`). В этой главе вы узнаете, как определить собственные виды данных, сущности и способы, используя возможности обобщённых видов данных.

Прежде всего, мы рассмотрим как применять способы и возможности, предоставленные Ржавчиной для уменьшения рукописи. Далее, мы будем использовать те же средства для создания обобщённой способы (функции) из двух функций, которые отличаются только видом данных их свойств. Мы также объясним, как использовать обобщённые виды данных при изложении стопок и перечислений.

После этого мы изучим как использовать сущности (traits) для определения поведения в обобщённом виде данных. Можно соединить сущности с обобщёнными видами данных, чтобы обобщённый вид данных мог принимать только такие виды данных, которые имеют определённое поведение, а не все подряд.

В конце мы обсудим *времена жизни (lifetimes)*, множества обобщённых видов данных, которые дают сборщику сведения о том, как времена жизни ссылок относятся друг к другу. Времена жизни позволяют нам указать дополнительные сведения об "одолженных" (borrowed) значениях, которая позволит сборщику удостовериться в соблюдения правил используемых ссылок в тех случаях, когда сборщик не может сделать это самостоятельно .

## Уменьшение рукописи за счёт выделения функций

Обобщение позволяет нам заменить определенные виды данных на один единственный "исполнитель" (placeholder), обозначающий сразу несколько видов данных, для уменьшения рукописи. Прежде чем углубляться в правила написания обобщённых видов, давайте сначала посмотрим, как удалить повторы, не задействуя обобщённые виды данных, путём извлечения способы (функции), которая заменяет определённые значения исполнителем, представляющим несколько значений. Затем мы применим то же средство для извлечения обобщенной способы (функции)! Изучив, как распознать повторы в рукописи, которые можно извлечь в способ (функцию), вы начнёте распознавать излишнюю рукопись, которая может использовать обобщённые виды данных.

Начнём с короткой рукописи, приведенной в приложении 10-1, которая находит наибольшее число в списке.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-01/src/main.rs:here}}
```

<span class="caption">Приложение 10-1: Поиск наибольшего числа в списке чисел</span>

Сохраним список целых чисел в переменной `список_чисел` и поместим первое значение из списка в переменную `наибольшее`. Далее, переберём все значения списка `Vec`, и, если текущее значение больше числа, сохранённого в переменной `наибольшее`, присвоим переменной `наибольшее` большее значение. Если текущее значение переменной меньше или равно "наибольшему", найденному ранее, значение переменной оставим прежним и перейдём к следующему значению списка. После перебора всех значений списка переменная `наибольшее` должна содержать наибольшее значение из `Vec`, которое в нашем случае будет равно 100.

Теперь перед нами стоит задача найти наибольшее число в двух разных списках. Для этого мы можем использовать рукопись из приложения 10-1 и применяя тот же подход в двух разных местах рукописи, как показано в приложении 10-2.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-02/src/main.rs}}
```

<span class="caption">Приложение 10-2: Рукопись для поиска наибольшего числа в <em>двух</em> списках чисел</span>

Несмотря на то, что рукопись приложения работает, повторение рукописи утомительно и подвержено ошибкам. При внесении изменений мы должны не забыть обновить каждое место, где рукопись повторяется.

Для устранения повторения мы можем создать дополнительную абстракцию с помощью способы (функции), которая сможет работать с любым списком целых чисел, переданных ей в качестве входного свойства и находить для этого списка наибольшее число. Данное решение делает рукопись более ясной и позволяет абстрактным образом упорядочить поиск наибольшего числа в списке.

В приложении 10-3 мы извлекаем рукопись, которая находит наибольшее число, в способ (функцию) с именем  `наибольшее`. Затем мы вызываем способ (функцию), чтобы найти наибольшее число в двух списках из приложения 10-2. Мы также можем использовать эту способ (функцию) для любого другого списка значений `i32` , которое может встретиться позже.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-03/src/main.rs:here}}
```

<span class="caption">Приложение 10-3: Абстрактная рукопись для поиска наибольшего числа в двух списках</span>

Способ (функция) `наибольшее` имеет свойство с именем `список`, которое представляет любой срез значений вида данных `i32`, которые мы можем передать в неё. В итоге вызова способы (функции), рукопись выполнится с определенными, переданными в неё значениями.

Итак, вот шаги для изменения рукописи из приложения 10-2 и приведения её в соответствии в приложении 10-3:

1. Определить повторы рукописи.
2. Извлечь повторы рукописи и поместить их в тело способы (функции), определив входные и выходные значения этой рукописи в ярлыке способы (функции).
3. Обновить и заменить два участка повторяющегося рукописи вызовом одной способы (функции).

Далее, чтобы уменьшить повторение рукописи, мы воспользуемся теми же шагами для обобщённых видов данных. Обобщённые виды данных позволяют работать над абстрактными видами данных таким же образом, как тело способы (функции) может работать над абстрактным списком `список` вместо определенных значений.

Например, у нас есть две способы (функции): одна ищет наибольшее значение внутри среза значений вида данных `i32`, а другая внутри среза значений вида данных `char`. Как уменьшить такую рукопись? Давайте выяснять!


