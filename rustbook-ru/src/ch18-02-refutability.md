## Возможность опровержения: может ли образец данных не совпадать

Образцы бывают двух видов: опровержимые и неопровержимые. Образцы, которые будут соответствовать любому возможному переданному значению, являются *неопровержимыми* (irrefutable). Примером может быть `x` в указании `let x = 5;`, потому что `x` соответствует чему-либо и, следовательно, не может не совпадать. Образцы, которые могут не соответствовать некоторому возможному значению, являются *опровержимыми* (refutable). Примером может быть `Some(x)` в выражении `if let Some(x) = a_value`, потому что если значение в переменной `a_value` равно `None`, а не `Some`, то образец данных `Some(x)` не будет совпадать.

Свойства функций, указания `let` и круговороты `for` могут принимать только неопровержимые образцы, поскольку программа не может сделать ничего значимого, если значения не совпадают. А выражения `if let` и `while let` принимают опровержимые и неопровержимые образцы, но сборщик предостерегает от неопровержимых образцов, поскольку по определению они предназначены для обработки возможного сбоя: возможность условного выражения заключается в его способности выполнять разные рукописи в зависимости от успеха или неудачи.

В общем случае, вам не нужно беспокоиться о разнице между опровержимыми (refutable) и неопровержимыми (irrefutable) образцами; тем не менее, вам необходимо ознакомиться с подходом возможности опровержения, чтобы вы могли отреагировать на неё, увидев в сообщении об ошибке. В таких случаях вам потребуется изменить либо образец данных, либо устройство, с которым вы используете образец данных, в зависимости от предполагаемого поведения рукописи.

Давайте посмотрим на пример того, что происходит, когда мы пытаемся использовать опровержимый образец данных, где Ржавчина требует неопровержимый образец данных, и наоборот. В приложении 18-8 показана указание `let`, но для образца данных мы указали `Some(x)`, являющийся образцом, который можно опровергнуть. Как и следовало ожидать, эта рукопись не будет собираться.

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-08/src/main.rs:here}}
```

<span class="caption">Приложение 18-8: Попытка использовать опровержимый образец данных вместе с <code>let</code></span>

Если `some_option_value` было бы значением `None`, то оно не соответствовало бы образцу данных `Some(x)`, что означает, что образец данных является опровержимым. Тем не менее, указание `let` может принимать только неопровержимый образец данных, потому что нет правильной рукописи, которая может что-то сделать со значением `None`. Во время сборки Ржавчина будет жаловаться на то, что мы пытались использовать опровержимый образец данных, для которого требуется неопровержимый образец данных:

```console
{{#include ../listings/ch18-patterns-and-matching/listing-18-08/output.txt}}
```

Поскольку мы не покрыли (и не могли покрыть!) каждое допустимое значение с помощью образца данных `Some(x)`, то Ржавчина выдаёт ошибку сборки.

Чтобы исправить неполадку наличия опровержимого образца, там, где нужен неопровержимый образец данных, можно изменить рукопись, использующую образец данных: вместо использования `let`, можно использовать `if let`. Затем, если образец данных не совпадает, выполнение рукописи внутри узорчатых скобок будет пропущено, что даст возможность продолжить правильное выполнение. В приложении 18-9 показано, как исправить рукопись из приложения 18-8.

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-09/src/main.rs:here}}
```

<span class="caption">Приложение 18-9. Использование <code>if let</code> и раздела с опровергнутыми образцами данных вместо <code>let</code></span>

Рукопись исправлена! Эта рукопись совершенно правильная, хотя это означает, что мы не можем использовать неопровержимый образец данных без получения ошибки. Если мы используем образец данных `if let`, который всегда будет совпадать, то для примера `x`, показанного в приложении 18-10, сборщик выдаст предупреждение.

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-10/src/main.rs:here}}
```

<span class="caption">Приложение 18-10. Попытка использовать неопровержимый образец данных с <code>if let</code></span>

Ржавчина жалуется, что не имеет смысла использовать `if let` с неопровержимым образцом:

```console
{{#include ../listings/ch18-patterns-and-matching/listing-18-10/output.txt}}
```

По этой причине совпадающие ветки выражений должны использовать опровержимые образцы, за исключением последнего, который должен сопоставлять любые оставшиеся значения с неопровержимым образцом. Ржавчина позволяет нам использовать неопровержимый образец данных в `match` только с одной веткой, но эти правила написания не особенно полезны и могут быть заменены более простым указанием `let`.

Теперь, когда вы знаете, где использовать образцы и разницу между опровержимыми и неопровержимыми образцами, давайте рассмотрим весь правила написания, который мы можем использовать для создания образцов.
