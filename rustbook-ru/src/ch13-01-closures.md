<!-- Old heading. Do not remove or links may break. -->

<a id="closures-anonymous-functions-that-can-capture-their-environment"></a>

## Замыкания: безымянные функции, которые запечатлевают ("получают") своё окружение

Замыкания в Ржавчине - это безымянные функции, которые можно сохранять в переменных или передавать в качестве переменных другим функциям. Вы можете создать замыкание в одном месте, а затем вызвать его в каком-нибудь другом, чтобы выполнить обработку в иной среде. В отличие от функций, замыкания могут использовать значения из области видимости в которой они были определены. Мы выполним, как эти функции замыканий открывают возможности для повторного использования рукописи и изменения её поведения.

<!-- Old headings. Do not remove or links may break. -->

<a id="creating-an-abstraction-of-behavior-with-closures"></a>
<a id="refactoring-using-functions"></a>
<a id="refactoring-with-closures-to-store-code"></a>

### Получение переменных окружения с помощью замыкания

Сначала мы рассмотрим, как с помощью замыканий можно использовать предметы из области, в которой они вместе были определены, для их последующего использования. Вот задумка: Время от времени наше предприятие по производству рубашек в качестве акции дарит  рубашки ограниченного выпуска, выпущенные ограниченным тиражом, каким-нибудь пользователям из нашего списка рассылки. Люди из списка рассылки при желании могут выбрать любимый цвет в своём личном кабинете. Если человек, выбранный для получения бесплатной рубашки, указал свой любимый цвет, он получает рубашку этого цвета. Если человек не указал свой любимый цвет, он получит рубашку того цвета, которых у предприятия на данное мгновение больше всего.

Существует множество способов выполнить это. В данном примере мы будем использовать перечисление `ShirtColor`, которое имеет два исхода: `Red` и `Blue` (для простоты ограничим количество доступных цветов этими двумя). Запасы предприятия мы представим стопкой `Inventory`, которая состоит из поля `shirts`, содержащего `Vec<ShirtColor>`, в котором перечислены рубашки тех цветов, которые есть в наличии. Способ `giveaway`, определённый в `Inventory`, принимает необязательное свойство - цвет, предпочитаемый пользователем, выбранным для получения бесплатной рубашки, и возвращает тот цвет рубашки, который он получит в действительности. Этот порядок показана в приложении 13-1:

<span class="filename">Имя файла: src/main.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-01/src/main.rs}}
```

<span class="caption">Приложение 13-1: Случай с раздачей рубашек предприятием</span>

В магазине `store`, определённом в `main`, осталось две синие и одна красная рубашки для этой ограниченной акции. Мы вызываем способ `giveaway` для пользователя предпочитающего красную рубашку и для пользователя без каких-либо предпочтений.

Опять же, эта рукопись могла быть выполнена множеством способов, но в данном случае, чтобы сосредоточиться на замыканиях, мы придерживались изученных ранее подходов, за исключением тела способа `giveaway`, в котором используется замыкание. В способе `giveaway` мы получаем пользовательское предпочтение цвета как свойство вида данных `Option<ShirtColor>` и применяем способ `unwrap_or_else` для `user_preference`. Способ <a data-md-type="raw_html" href="../std/option/enum.Option.html#method.unwrap_or_else">`unwrap_or_else` перечисления `Option<T>`</a><!-- ignore --> определён встроенной библиотекой. Он принимает одну переменную: значение `T` (возвращается значение в заранее заданном виде, которое окажется в исходе `Some` перечисления `Option<T>`, в нашем случае `ShirtColor`). Если `Option<T>` окажется исходом `Some`, `unwrap_or_else` вернёт значение из `Some`. А если `Option<T>` будет является исходом `None`, `unwrap_or_else` вызовет замыкание и вернёт значение, полученное из замыкания.

В качестве переменной `unwrap_or_else` мы передаём замыкание `|| self.most_stocked()`. Это замыкание, которое не принимает никаких свойств (если бы у замыкания были свойства, они были бы перечислены между двумя вертикальными полосами). В теле замыкания вызывается `self.most_stocked()`. Здесь мы определили замыкание, а использование `unwrap_or_else` таково, что оно выполнится позднее, когда потребуется получить итог.

Итог выполнения рукописи:

```console
{{#include ../listings/ch13-functional-features/listing-13-01/output.txt}}
```

Важной особенностью здесь является то, что мы вызвали замыкание, которое в свою очередь вызывает `self.most_stocked()` - способ для нашего образца данных (стопки) `Inventory`. Обычной библиотеке не нужно знать ничего о видах данных: стопка -> `Inventory` или  перечисление -> `ShirtColor`, которые мы определили, или о ходе мыслей, который мы хотим использовать для решения данной задачи. Замыкание определяет неизменяемую ссылку на `self` `Inventory` и передаёт её с указанным нами содержимым в способ `unwrap_or_else`. А вот функции не могут определять своё окружение таким образом.

### Выведение и изложение видов замыкания

Есть и другие различия между функциями и замыканиями. Замыкания обычно не требуют определения видов данных в входных свойств или возвращаемого значения, как это делается в функциях `fn`. Изложения видов данных требуются для функций, потому что виды данных находятся за пределами самой функции, предоставляемого пользователям. Жёсткое определение видов данных необходимо для того, чтобы все вида данных были согласованы в том, какие виды данных использует и возвращает функция. А вот замыкания, напротив, для них не требуется строго указывать виды данных: так как они могут храниться в переменных и использоваться не имея имени, при этом незримо для пользователей нашей библиотеки.

Замыкания, как правило, небольшие и уместны в какой-то узконаправленном среде, а не в произвольных случаях. В этих ограниченных средах сборщик может вывести виды свойств и возвращаемого вида данных, подобно тому, как он может вывести виды данных большинства переменных (есть редкие случаи, когда сборщику также нужны изложения видов замыканий).

Как и в случае с переменными, мы можем добавить изложения видов данных, если хотим внести определенность при описании за счёт увеличения рукописи. Определение видов данных для замыкания будет выглядеть как определение в приложении 13-2. В этом примере в переменной определено замыкание, при этом мы не определяем замыкание в том месте, куда мы передаём его в качестве переменной, как это было в приложении 13-1.

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-02/src/main.rs:here}}
```

<span class="caption">Приложение 13-2: Добавление необязательных наставлений видов свойств и возвращаемых значений в замыкании</span>

С добавлением описаний видов данных, правила написания замыканий выглядят более похожими на правила написания функций. Здесь мы для сравнения, определяем функцию, которая добавляет 1 к своему значению, и замыкание, которое имеет такое же поведение. Мы добавили несколько пробелов, чтобы выровнять соответствующие части. Это показывает, что правила написания замыкания похожи на правила написания функции, за исключением использования труб (вертикальная черта) и дополнительного количества необязательных пояснений согласно правилам написания:

```rust,ignore
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
```

В первой строке описано определение функции, а во второй - полностью расписано всё замыкание от начала и до конца. В третьей строке мы удаляем из изложения описания видов данных при описании замыкания. В четвёртой строке мы убираем узорчатые скобки, которые являются необязательными, поскольку тело замыкания содержит только одно действие. Все выше указанные изложения являются правильными согласно правил написания и являются равноценными с точки зрения поведения при их вызове. Строки `add_one_v3` и `add_one_v4` требуют, чтобы виды данных, используемых в замыканиях были заранее определены до сборки, поскольку виды данных не определены. Это похоже на `let v = Vec::new();`, когда для `Vec` необходимо указать вид данных, либо значения ранее определенного вида данных, чтобы Ржавчина смогла понять с каким видом данных ей предстоит выполнять действия.

Для определения итога замыкания сборщик  определяет виды данных для каждого из входных и возвращаемых значений. Например, в приложении 13-3 показано определение короткого замыкания, которое просто возвращает значение, полученное в качестве входного. Это замыкание бесполезно, показано для примера. Обратите внимание, что мы не указали в описании вид данных. Поскольку виды данных не определены, мы можем вызвать замыкание для любого вида данных, что мы и сделали в первый раз с `String`. Но если мы затем попытаемся вызвать `example_closure` для другого вида данных - например целого числа, мы получим ошибку.

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-03/src/main.rs:here}}
```

<span class="caption">Приложение 13-3: Попытка вызова замыкания, при обращении к которому вкладываются разные виды данных</span>

Сборщик вернёт нам вот такую ошибку:

```console
{{#include ../listings/ch13-functional-features/listing-13-03/output.txt}}
```

При первом вызове `example_closure` со значением `String` сборщик определяет входной (`x`) и выходной вид данных для данного замыкания как `String`. Этот вид данных затем привязывается к замыканию в `example_closure`, и мы получаем ошибку из-за недопустимого вида данных при следующей попытке , так как нельзя повторно использовать другой вид данных с тем же замыканием.

### Получение ссылок или передача владения

Замыкания могут получать значения из своего окружения тремя способами, которые соответствуют тем же трём способам, которыми функция может принимать свойства: заимствование неизменяемое, заимствование изменяемое и получение владения. Замыкание самостоятельно определяет, какой из этих способов использовать, исходя из того, что тело замыкания делает с полученными значениями.

В приложении 13-4 мы определяем замыкание, которое получает неизменяемую ссылку на вектор с именем `list`, поскольку неизменяемой ссылки достаточно для вывода значения:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-04/src/main.rs}}
```

<span class="caption">Приложение 13-4: Определение и вызов замыкания, которое получает неизменяемую ссылку</span>

Этот пример также отображает, то что переменная может быть привязана к вызову самого замыкания, и в дальнейшем мы можем вызвать замыкание, используя имя переменной и круглые скобки, как если бы имя переменной было именем функции.

Поскольку мы можем иметь несколько неизменяемых ссылок на `list` одновременно, `list` остаётся доступным из рукописи до определения замыкания, после определения замыкания, а также до вызова замыкания и после. Итог данной рукописи:

```console
{{#include ../listings/ch13-functional-features/listing-13-04/output.txt}}
```

В следующем приложении 13-5 мы изменили тело замыкания так, чтобы оно добавляло переменную в вектор `list`. Теперь замыкание получает изменяемую ссылку:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-05/src/main.rs}}
```

<span class="caption">Приложение 13-5. Определение и вызов замыкания, получающего изменяемую ссылку</span>

Эта рукопись собирается, запускается и выводит:

```console
{{#include ../listings/ch13-functional-features/listing-13-05/output.txt}}
```

Обратите внимание, что между определением и вызовом замыкания `borrows_mutably` больше нет `println!`: когда определяется `borrows_mutably`, оно получает изменяемую ссылку на `list`. После вызова замыкания мы больше не используем его, поэтому изменяемое заимствование заканчивается. Между определением замыкания и вызовом замыкания неизменяемое заимствование для вывода недоступно, потому что при наличии изменяемого заимствования никакие другие заимствования недопустимы. Попробуйте добавить туда `println!` и посмотрите, какое сообщение об ошибке вы получите!

Если вы хотите заставить замыкание принять владение значениями, которые оно использует в окружении, даже если в теле замыкания нет рукописи, требующей владения, вы можете использовать ключевое слово `move` перед указанием свойств.

Это средство в основном полезно при передаче замыкания владения новому потоку, чтобы переместить владение данными так, чтобы ими владел новый поток. Мы подробно обсудим потоки и то, зачем их использовать, в главе 16, когда будем говорить о одновременности и многопоточности, а пока давайте вкратце рассмотрим порождение порождённого потока с помощью замыкания, в котором используется ключевое слово `move`. В приложении 13-6 показана рукопись из приложения 13-4, измененная для вывода вектора в новом потоке, а не в основном:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-06/src/main.rs}}
```

<span class="caption">Приложение 13-6: Использование <code>move</code> для принуждения замыкания потока принять на себя владение <code>list</code></span>

Мы порождаем новый поток, передавая ему в качестве переменной замыкание для выполнения. Тело замыкания выводит список. В приложении 13-4 замыкание получило `list` только с помощью неизменяемой ссылки, потому что это наименьший уровень доступа, необходимый для обращения к `list` для вывода. В этом примере, несмотря на то, что тело замыкания по-прежнему требует только неизменяемой ссылки, нам нужно указать, что `list` должен быть передан во владение замыканию, поместив ключевое слово `move` в начало определения замыкания. Порожденный поток может завершиться раньше, чем завершится основной поток, или основной поток может завершиться первым. Если основной поток сохранил владение `list`, но завершился раньше порождённого потока и удалил `list`, то неизменяемая ссылка в потоке будет недействительной. Поэтому сборщик требует, чтобы `list` был передан во владение замыканию, которое передаёт владение порожденному потоку, чтобы ссылка была действительной. Попробуйте убрать ключевое слово `move` или использовать `list` в основном потоке после вызова замыкания и посмотрите, какие ошибки сборщика вы получите!

<!-- Old headings. Do not remove or links may break. -->

<a id="storing-closures-using-generic-parameters-and-the-fn-traits"></a>
<a id="limitations-of-the-cacher-implementation"></a>
<a id="moving-captured-values-out-of-the-closure-and-the-fn-traits"></a>

### Перемещение полученных значений из замыканий и сущности `Fn`

После того, как замыкание получило ссылку или право владения значением из области видимости, в которой оно определено (тем самым влияя на то, что перемещается *в* замыкание), рукопись в теле замыкания определяет, что происходит со ссылками или значениями, во время последующего выполнения (тем самым влияя на то, что перемещается *из* замыкания). Тело замыкания может делать любое из следующих действий: перемещать полученное значение из замыкания, изменять полученное значение, не перемещать и не изменять значение или вообще ничего не получать из среды.

То, как замыкание получает и обрабатывает значения из своего окружения, указывает на то, какие сущности используют замыкание, а с помощью сущностей функции и стопки могут определять, какие виды замыканий они могут использовать. Замыканиям самостоятельно присваивается выполнение одного, двух или всех трёх из нижеперечисленных сущностей `Fn`, аддитивным образом, в зависимости от того, как тело замыкания обрабатывает значения:

1. `FnOnce` применяется к замыканиям, которые могут быть вызваны один раз. Все замыкания используют по крайней мере эту сущность, потому что все замыкания могут быть вызваны. Замыкание, которое передаёт право владения на полученные значения из своего тела, использует только `FnOnce` и ни один из других признаков `Fn`, потому что оно может быть вызвано только один раз.
2. `FnMut` применяется к замыканиям, которые не передают полученные значения из своего тела, но могут изменять полученные значения. Такие замыкания могут вызываться более одного раза.
3. `Fn` применяется к замыканиям, которые не передают право владения на полученные значения из своего тела и не изменяют полученные значения, а также к замыканиям, которые ничего не получают из своего окружения. Такие замыкания могут выполняться более одного раза и не меняют ничего в своём окружении, что важно в таких случаях, как одновременный вызов замыкания несколько раз.

Давайте рассмотрим определение способа `unwrap_or_else` у `Option<T>`, который мы использовали в приложении 13-1:

```rust,ignore
impl<T> Option<T> {
    pub fn unwrap_or_else<F>(self, f: F) -> T
    where
        F: FnOnce() -> T
    {
        match self {
            Some(x) => x,
            None => f(),
        }
    }
}
```

Напомним, что `T` - это гибкий вид данных, отображающий вид значения в `Some` исходе `Option`. Этот вид данных `T` также является возвращаемым видом функции `unwrap_or_else`: например, рукопись, вызывающая `unwrap_or_else` у `Option<String>`, получит `String`.

Далее, обратите внимание, что функция `unwrap_or_else` имеет дополнительное свойство гибкого вида данных `F`. Здесь `F` - это вид входного свойства `f`, который является замыканием, заданным нами при вызове `unwrap_or_else`.

Ограничением сущности, заданным для обобщённого вида данных `F`, является `FnOnce() -> T`, что означает, что `F` должен вызываться один раз, не принимать никаких переменных и возвращать `T`. Использование `FnOnce` в ограничении сущности говорит о том, что `unwrap_or_else` должен вызывать `f` не более одного раза. В теле `unwrap_or_else` мы видим, что если `Option` будет равен `Some`, то `f` не будет вызван. Если же значение `Option` будет равным `None`, то `f` будет вызван один раз. Поскольку все замыкания используют `FnOnce`, `unwrap_or_else` принимает самые разные виды замыканий и является настолько гибким, насколько это возможно.

> Примечание: Функции также могут использовать все три сущности `Fn`. Если то, что мы хотим сделать, не требует получения значения из среды, мы можем передавать имя какой-либо функции, а не замыкания, когда нам нужно что-то, выполняющее одну из сущностей `Fn`. Например, для значения `Option<Vec<T>>` мы можем вызвать `unwrap_or_else(Vec::new)`, чтобы получить новый пустой вектор, если значение окажется `None`.

Теперь рассмотрим способ встроенной библиотеки `sort_by_key`, определённый у срезов, чтобы увидеть, чем он отличается от `unwrap_or_else` и почему `sort_by_key` использует `FnMut` вместо `FnOnce` для ограничения сущности. Замыкание принимает единственная переменная в виде ссылки на текущую переменную в рассматриваемом срезе и возвращает значение вида данных `K`, к которому применимо упорядочивание. Эта функция полезна, когда вы хотите упорядочить срез по определённому свойству каждой переменной. В приложении 13-7 у нас есть список образцов `Rectangle`, и мы используем `sort_by_key`, чтобы упорядочить их по свойству `width` от меньшего к большему:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-07/src/main.rs}}
```

<span class="caption">Приложение 13-7: Использование <code>sort_by_key</code> для упорядочивания прямоугольников по ширине</span>

Эта рукопись выводит:

```console
{{#include ../listings/ch13-functional-features/listing-13-07/output.txt}}
```

Причина, по которой `sort_by_key` определена как принимающая замыкание `FnMut`, заключается в том, что она вызывает замыкание несколько раз: по одному разу для каждой переменной в срезе. Замыкание `|r| r.width` не получает, не изменяет и не перемещает ничего из своего окружения, поэтому оно удовлетворяет требованиям связанности признаков.

И наоборот, в приложении 13-8 показан пример замыкания, которое использует только признак `FnOnce`, потому что оно перемещает значение из среды. Сборщик не позволит нам использовать это замыкание с `sort_by_key`:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-08/src/main.rs}}
```

<span class="caption">Приложение 13-8: Попытка использовать замыкание <code>FnOnce</code> с <code>sort_by_key</code></span>

Это надуманный, замысловатый способ (который не работает) подсчёта количества вызовов `sort_by_key` при упорядочиванию `list`. Эта рукопись пытается выполнить подсчёт, перемещая `value` - `String` из окружения замыкания - в вектор `sort_operations`. Замыкание получает `value`, затем перемещает `value` из замыкания, передавая владение на `value` вектору `sort_operations`. Это замыкание можно вызвать один раз; попытка вызвать его второй раз не сработает, потому что `value` уже не будет находиться в той среде, из которой его можно будет снова поместить в `sort_operations`! Поэтому это замыкание использует только `FnOnce`. Когда мы попытаемся собрать эту рукопись, мы получим ошибку сообщающую о том что `value` не может быть перемещено из замыкания, потому что замыкание должно использовать `FnMut`:

```console
{{#include ../listings/ch13-functional-features/listing-13-08/output.txt}}
```

Ошибка указывает на строку в теле замыкания, которая перемещает `value` из окружения. Чтобы исправить это, нужно изменить тело замыкания так, чтобы оно не перемещало значения из окружения. Для подсчёта количества вызовов `sort_by_key` более простым способом является хранение счётчика в окружении и увеличение его значения в теле замыкания. Замыкание в приложении 13-9 работает с `sort_by_key`, поскольку оно определяет только изменяемую ссылку на счётчик `num_sort_operations` и поэтому может быть вызвано более одного раза:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-09/src/main.rs}}
```

<span class="caption">Приложение 13-9: Использование замыкания <code>FnMut</code> с <code>sort_by_key</code> разрешено</span>

Сущности `Fn` важны при определении или использовании функций или видов данных, использующих замыкания. В следующем разделе мы обсудим повторители. Многие способы повторителей принимают переменные в виде замыканий, поэтому не забывайте об этих подробностях, пока мы продвигаемся дальше!


