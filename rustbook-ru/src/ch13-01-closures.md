<!-- Old heading. Do not remove or links may break. -->

<a id="closures-anonymous-functions-that-can-capture-their-environment"></a>

## Замыкания: безымянные способы (функции), которые запечатлевают ("получают") своё окружение

Замыкания в Ржавчине - это безымянные способы (функции), которые можно сохранять в переменных или передавать в качестве переменных другим способам (функциям). Вы можете создать замыкание в одном месте, а затем вызвать его в каком-нибудь другом, чтобы выполнить обработку в иной среде. В отличие от способов (функций), замыкания могут использовать значения из области видимости в которой они были определены. Мы рассм, как эти способы (функции) замыканий открывают возможности для повторного использования рукописи и изменения её поведения.
<!-- Old headings. Do not remove or links may break. -->

<a id="creating-an-abstraction-of-behavior-with-closures"></a>
<a id="refactoring-using-functions"></a>
<a id="refactoring-with-closures-to-store-code"></a>

### Получение переменных окружения с помощью замыкания

Сначала мы рассмотрим, как с помощью замыканий можно использовать предметы из области, в которой они вместе были определены, для их последующего использования. Вот задумка: Время от времени наше предприятие по производству рубашек в качестве акции дарит  рубашки ограниченного выпуска, выпущенные ограниченным тиражом, каким-нибудь пользователям из нашего списка рассылки. Люди из списка рассылки при желании могут выбрать любимый цвет в своём личном кабинете. Если человек, выбранный для получения бесплатной рубашки, указал свой любимый цвет, он получает рубашку этого цвета. Если человек не указал свой любимый цвет, он получит рубашку того цвета, которых у предприятия на данное мгновение больше всего.

Существует множество способов выполнить это. В данном примере мы будем использовать перечисление `ЦветРубашки`, которое имеет два исхода: `Красный` и `Синий` (для простоты ограничим количество доступных цветов этими двумя). Запасы предприятия мы представим стопкой `Запасы`, которая состоит из поля `рубашки`, содержащего `Vec<ЦветРубашки>`, в котором перечислены рубашки тех цветов, которые есть в наличии. Способ `выдать`, определённый в `Запасы`, принимает необязательную переменную - цвет, предпочитаемый пользователем, выбранным для получения бесплатной рубашки, и возвращает тот цвет рубашки, который он получит в действительности. Этот порядок показан в приложении 13-1:

<span class="filename">Имя файла: src/main.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-01/src/main.rs}}
```

<span class="caption">Приложение 13-1: Случай с раздачей рубашек предприятием</span>

В магазине `склад`, определённом в `main`, осталось две синие и одна красная рубашки для этой ограниченной акции. Мы вызываем способ `выдать` для пользователя предпочитающего красную рубашку и для пользователя без каких-либо предпочтений.

Опять же, эта рукопись могла быть выполнена множеством способов, но в данном случае, чтобы сосредоточиться на замыканиях, мы придерживались изученных ранее подходов, за исключением тела способа `выдать`, в котором используется замыкание. В способе `выдать` мы получаем пользовательское предпочтение цвета как входную переменную вида данных `Option<ЦветРубашки>` и применяем способ `unwrap_or_else` для `пользвательский_выборerence`. Способ <a data-md-type="raw_html" href="../std/option/enum.Option.html#method.unwrap_or_else">`unwrap_or_else` перечисления `Option<T>`</a><!-- ignore --> определён встроенной библиотекой. Он принимает одну переменную: значение `T` (возвращается значение в заранее заданном виде, которое окажется в исходе `Some` перечисления `Option<T>`, в нашем случае `ЦветРубашки`). Если `Option<T>` окажется исходом `Some`, `unwrap_or_else` вернёт значение из `Some`. А если `Option<T>` будет является исходом `None`, `unwrap_or_else` вызовет замыкание и вернёт значение, полученное из замыкания.

В качестве переменной `unwrap_or_else` мы передаём замыкание `|| self.most_stocked()`. Это замыкание, которое не принимает никаких переменных (если бы у замыкания были переменные, они были бы перечислены между двумя вертикальными полосами). В теле замыкания вызывается `self.most_stocked()`. Здесь мы определили замыкание, а использование `unwrap_or_else` таково, что оно выполнится позднее, когда потребуется получить итог.

Итог выполнения рукописи:

```console
{{#include ../listings/ch13-functional-features/listing-13-01/output.txt}}
```

Важной особенностью здесь является то, что мы вызвали замыкание, которое в свою очередь вызывает `self.most_stocked()` - способ для нашего образца данных (стопки) `Запасы`. Обычной библиотеке не нужно знать ничего о видах данных: стопка -> `Запасы` или  перечисление -> `ЦветРубашки`, которые мы определили, или о ходе мыслей, который мы хотим использовать для решения данной задачи. Замыкание определяет неизменяемую ссылку на `self` `Запасы` и передаёт её с указанным нами содержимым в способ `unwrap_or_else`. А вот способы (функции) не могут определять своё окружение таким образом.

### Выведение и изложение видов замыкания

Есть и другие различия между способами (функциями) и замыканиями. Замыкания обычно не требуют определения видов данных в входных переменных или возвращаемого значения, как это делается в способ (функция)х `fn`. Изложения видов данных требуются для способов (функций), потому что виды данных находятся за пределами самого способа (функции), предоставляемого пользователям. Жёсткое определение видов данных необходимо для того, чтобы все вида данных были согласованы в том, какие виды данных использует и возвращает способ (функция). А вот замыкания, напротив, для них не требуется строго указывать виды данных: так как они могут храниться в переменных и использоваться не имея имени, при этом незримо для пользователей нашей библиотеки.

Замыкания, как правило, небольшие и уместны в какой-то узконаправленном среде, а не в произвольных случаях. В этих ограниченных средах сборщик может вывести виды данных переменных и возвращаемого вида данных, подобно тому, как он может вывести виды данных большинства переменных (есть редкие случаи, когда сборщику также нужны изложения видов замыканий).

Как и в случае с переменными, мы можем добавить изложения видов данных, если хотим внести определенность при описании за счёт увеличения рукописи. Определение видов данных для замыкания будет выглядеть как определение в приложении 13-2. В этом примере в переменной определено замыкание, при этом мы не определяем замыкание в том месте, куда мы передаём его в качестве переменной, как это было в приложении 13-1.

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-02/src/main.rs:here}}
```

<span class="caption">Приложение 13-2: Добавление необязательных наставлений видов данных переменных и возвращаемых значений в замыкании</span>

С добавлением описаний видов данных, правила написания замыканий выглядят более похожими на правила написания способов (функций). Здесь мы для сравнения, определяем способ (функцию), которая добавляет 1 к своему значению, и замыкание, которое имеет такое же поведение. Мы добавили несколько пробелов, чтобы выровнять соответствующие части. Это показывает, что правила написания замыкания похожи на правила написания способа (функции), за исключением использования труб (вертикальная черта) и дополнительного количества необязательных пояснений согласно правилам написания:

```rust,ignore
fn  добавить_одно_исполнение_1   (x: u32) -> u32 { x + 1 }
let добавить_одно_исполнение_2 = |x: u32| -> u32 { x + 1 };
let добавить_одно_исполнение_3 = |x|             { x + 1 };
let добавить_одно_исполнение_4 = |x|               x + 1  ;
```

В первой строке описано определение способа (функции), а во второй - полностью расписано всё замыкание от начала и до конца. В третьей строке мы удаляем из изложения описания видов данных при описании замыкания. В четвёртой строке мы убираем узорчатые скобки, которые являются необязательными, поскольку тело замыкания содержит только одно действие. Все выше указанные изложения являются правильными согласно правил написания и являются равноценными с точки зрения поведения при их вызове. Строки `добавить_одно_исполнение_3` и `добавить_одно_исполнение_4` требуют, чтобы виды данных, используемых в замыканиях были заранее определены до сборки, поскольку виды данных не определены. Это похоже на `let v = Vec::new();`, когда для `Vec` необходимо указать вид данных, либо значения ранее определенного вида данных, чтобы Ржавчина смогла понять с каким видом данных ей предстоит выполнять действия.

Для определения итога замыкания сборщик  определяет виды данных для каждого из входных и возвращаемых значений. Например, в приложении 13-3 показано определение короткого замыкания, которое просто возвращает значение, полученное в качестве входного. Это замыкание бесполезно, показано для примера. Обратите внимание, что мы не указали в описании вид данных. Поскольку виды данных не определены, мы можем вызвать замыкание для любого вида данных, что мы и сделали в первый раз с `String`. Но если мы затем попытаемся вызвать `пример_замыкания` для другого вида данных - например целого числа, мы получим ошибку.

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-03/src/main.rs:here}}
```

<span class="caption">Приложение 13-3: Попытка вызова замыкания, при обращении к которому вкладываются разные виды данных</span>

Сборщик вернёт нам вот такую ошибку:

```console
{{#include ../listings/ch13-functional-features/listing-13-03/output.txt}}
```
При первом вызове `пример_замыкания` со значением `String` сборщик определяет входной (`x`) и выходной вид данных для данного замыкания как `String`. Этот вид данных затем привязывается к замыканию в `пример_замыкания`, и мы получаем ошибку из-за недопустимого вида данных при следующей попытке , так как нельзя повторно использовать другой вид данных с тем же замыканием.

### Получение ссылок или передача владения

Замыкания могут получать значения из своего окружения тремя способами, которые соответствуют тем же трём способам, которыми способ (функция) может принимать переменные: заимствованая неизменяемая, заимствованная изменяемая и получение права владения. Замыкание самостоятельно определяет, какой из этих способов использовать, исходя из того, что тело замыкания делает с полученными значениями.

В приложении 13-4 мы определяем замыкание, которое получает неизменяемую ссылку на вектор с именем `список`, поскольку неизменяемой ссылки достаточно для вывода значения:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-04/src/main.rs}}
```

<span class="caption">Приложение 13-4: Определение и вызов замыкания, которое получает неизменяемую ссылку</span>

Этот пример также отображает, то что переменная может быть привязана к вызову самого замыкания, и в дальнейшем мы можем вызвать замыкание, используя имя переменной и круглые скобки, как если бы имя переменной было именем способа (функции).

Поскольку мы можем иметь несколько неизменяемых ссылок на `список` одновременно, `список` остаётся доступным для использования до определения замыкания, после определения замыкания, а также до вызова замыкания и после. Итог данной рукописи:

```console
{{#include ../listings/ch13-functional-features/listing-13-04/output.txt}}
```

В следующем приложении 13-5 мы изменили тело замыкания так, чтобы оно добавляло переменную в вектор `список`. Теперь замыкание получает изменяемую ссылку:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-05/src/main.rs}}
```

<span class="caption">Приложение 13-5. Определение и вызов замыкания, получающего изменяемую ссылку</span>

Итог данной рукописи при сборке:

```console
{{#include ../listings/ch13-functional-features/listing-13-05/output.txt}}
```

Обратите внимание, что между определением и вызовом замыкания `заимствование_с_правом_изменения` больше нет `println!`: когда определяется `заимствование_с_правом_изменения`, оно получает изменяемую ссылку на `список`. После вызова замыкания мы больше не используем его, поэтому изменяемое заимствование заканчивается. Между определением замыкания и вызовом замыкания неизменяемое заимствование для вывода недоступно, потому что при наличии изменяемого заимствования никакие другие заимствования недопустимы. Попробуйте добавить туда `println!` и посмотрите, какое сообщение об ошибке вы получите!

Если вы хотите заставить замыкание принять владение значениями, которые оно использует в окружении, даже если в теле замыкания нет рукописи, требующей владения, вы можете использовать ключевое слово `move` перед указанием переменных.

Это средство в основном полезно при передаче замыканием права владения порождённому потоку,то есть чтобы передать право владение переменными во владение порожденному потоку. Мы подробно обсудим потоки и то, зачем их использовать, в главе 16, когда будем говорить о одновременности и многопоточности, а пока давайте вкратце рассмотрим порождение дополнительного потока с помощью замыкания, в котором используется ключевое слово `move`. В приложении 13-6 показана рукопись из приложения 13-4, измененная для вывода вектора в новом потоке, а не в основном:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-06/src/main.rs}}
```

<span class="caption">Приложение 13-6: Использование <code>move</code> для принуждения замыкания потока принять на себя владение <code>список</code></span>

Мы порождаем новый поток, передавая ему в качестве переменной замыкание для выполнения. Тело замыкания выводит список. В приложении 13-4 замыкание получило `список` с помощью неизменяемой ссылки, потому что это наименьший уровень доступа, необходимый для обращения к `список` для вывода. В этом примере, несмотря на то, что телу замыкания по-прежнему достаточно неизменяемой ссылки, нам нужно указать, что `список` должен быть передан во владение замыканию, поместив ключевое слово `move` в начало определения замыкания. Порожденный поток может завершиться раньше, чем завершится основной поток, или основной поток может завершиться первым. Если основной поток сохранил владение `список`, но завершился раньше порождённого потока и удалил `список`, то неизменяемая ссылка в потоке будет недействительной. Поэтому сборщик требует, чтобы `список` был передан во владение замыканию, которое передаёт владение порожденному потоку, чтобы ссылка была действительной. Попробуйте убрать ключевое слово `move` или использовать `список` в основном потоке после вызова замыкания и посмотрите, какие ошибки сборщика вы получите!

<!-- Old headings. Do not remove or links may break. -->

<a id="storing-closures-using-generic-parameters-and-the-fn-traits"></a>
<a id="limitations-of-the-cacher-implementation"></a>
<a id="moving-captured-values-out-of-the-closure-and-the-fn-traits"></a>

### Передача полученных значений из замыканий и сущности `Fn`

После того, как замыкание получило ссылку или право владения значением из области видимости, в которой оно определено (тем самым влияя на то, что передано замыканию), действия в теле замыкания определяют, что происходит со ссылками или переменными, во время последующего выполнения (тем самым влияя на то, что будет возвращено из замыкания). В теле замыкания допустимы любые из следующих действий: передавать право владения полученным значением, изменять полученное значение, не передавать право владения и не изменять значение или вообще ничего не получать из среды.

Способ, которым замыкание получает и обрабатывает значения из своего окружения, указывает на то, какие сущности использует замыкание. Сущности определяют какие замыкания могут быть использованы способами (функциями), стопками. Замыканиям самостоятельно определяют исполнение одного, двух или всех трёх из нижеперечисленных сущностей `Fn`, определяя по умолчанию способ взаимодействия, в зависимости от того, как тело замыкания обрабатывает значения:

1. `FnOnce` применяется к замыканиям, которые могут быть вызваны один раз. Все замыкания используют по крайней мере эту сущность, потому что все замыкания могут быть вызваны. Замыкание, которое передаёт право владения на полученные значения из своего тела, использует только `FnOnce` и ни один из других признаков `Fn`, потому что оно может быть вызвано только один раз.
2. `FnMut` применяется к замыканиям, которые не передают полученные значения из своего тела, но могут изменять полученные значения. Такие замыкания могут вызываться более одного раза.
3. `Fn` применяется к замыканиям, которые не передают право владения на полученные значения из своего тела и не изменяют полученные значения, а также к замыканиям, которые ничего не получают из своего окружения. Такие замыкания могут выполняться более одного раза и не меняют ничего в своём окружении, что важно в таких случаях, как одновременный вызов замыкания несколько раз.

Давайте рассмотрим определение способа `unwrap_or_else` у `Option<T>`, который мы использовали в приложении 13-1:

```rust,ignore
impl<T> Option<T> {
    pub fn unwrap_or_else<F>(self, f: F) -> T
    where
        F: FnOnce() -> T
    {
        match self {
            Some(x) => x,
            None => f(),
        }
    }
}
```

Напомним, что `T` - это обобщенный вид данных, отображающий вид значения в `Some` исходе `Option`. Этот вид данных `T` также является возвращаемым видом способа (функции) `unwrap_or_else`: например, рукопись, вызывающая `unwrap_or_else` у `Option<String>`, получит `String`.

Далее, обратите внимание, что способ (функция) `unwrap_or_else` имеет дополнительное свойство гибкого вида данных `F`. Здесь `F` - это вид входной переменной  `f`, который является замыканием, заданным нами при вызове `unwrap_or_else`.

Ограничением сущности, заданным для обобщённого вида данных `F`, является `FnOnce() -> T`, это означает, что `F` должен вызываться один раз, не принимать никаких переменных и возвращать `T`. Использование `FnOnce` в ограничении сущности говорит о том, что `unwrap_or_else` должен вызывать `f` не более одного раза. В теле `unwrap_or_else` мы видим, что если `Option` будет равен `Some`, то `f` не будет вызван. Если же значение `Option` будет равным `None`, то `f` будет вызван один раз. Поскольку все замыкания используют `FnOnce`, `unwrap_or_else` принимает все три вида замыканий и является настолько вездесущим, насколько это возможно.

> Примечание: Способы (функции) также могут использовать все три сущности `Fn`. Если то, что мы хотим сделать, не требуя получения значения из среды, мы можем передать имя какого-либо способа (функции) вместо замыкания. Например, для значения `Option<Vec<T>>` мы можем вызвать `unwrap_or_else(Vec::new)`, чтобы получить новый пустой вектор, если значение окажется `None`. Сборщик самостоятельно использует любую из сущностей `Fn`, применимую для определения способа (функции).

Теперь рассмотрим способ встроенной библиотеки `sort_by_key`, определённый у срезов, чтобы увидеть, чем он отличается от `unwrap_or_else` и почему `sort_by_key` использует `FnMut` вместо `FnOnce` для ограничения сущности. Замыкание принимает единственную переменную в виде ссылки на текущую переменную в рассматриваемом срезе и возвращает значение вида данных `K`, к которому применимо упорядочивание. Этот способ полезен, когда вы хотите упорядочить срез по определённому значению каждой переменной. В приложении 13-7 у нас есть список образцов `Прямоугольник`, и мы используем `sort_by_key`, чтобы упорядочить их по призаку `width` от меньшего к большему:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-07/src/main.rs}}
```

<span class="caption">Приложение 13-7: Использование <code>sort_by_key</code> для упорядочивания прямоугольников по ширине</span>

Эта рукопись выводит:

```console
{{#include ../listings/ch13-functional-features/listing-13-07/output.txt}}
```

Причина, по которой `sort_by_key` определена как принимающая замыкание `FnMut`, заключается в том, что она вызывает замыкание несколько раз: по одному разу для каждой переменной в срезе. Замыкание `|r| r.ширина` не получает, не изменяет и не передаёт ничего из своего окружения, поэтому оно удовлетворяет требованиям связанности признаков.

И наоборот, в приложении 13-8 показан пример замыкания, которое использует только признак `FnOnce`, потому что оно передаёт значение из среды. Сборщик не позволит нам использовать это замыкание с `sort_by_key`:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-08/src/main.rs}}
```

<span class="caption">Приложение 13-8: Попытка использовать замыкание <code>FnOnce</code> с <code>sort_by_key</code></span>

Это надуманный, замысловатый способ (который не работает) подсчёта количества вызовов `sort_by_key` во время упорядочивания `список`. Эта рукопись пытается выполнить подсчёт, передавая `значение` - `String` из окружения замыкания - в вектор `действия_упорядочивания`. Замыкание получает `значение` и затем передаёт `значение` из замыкания, передавая владение на `значение` вектору `действия_упорядочивания`. Это замыкание можно вызвать один раз; попытка вызвать его второй раз не сработает, потому что `значение` уже не будет находиться в той среде, из которой его можно будет снова поместить в `действия_упорядочивания`! Поэтому это замыкание использует только `FnOnce`. Когда мы попытаемся собрать эту рукопись, мы получим ошибку сообщающую о том что `значение` не может быть передано из замыкания, потому что замыкание должно использовать `FnMut`:

```console
{{#include ../listings/ch13-functional-features/listing-13-08/output.txt}}
```

Ошибка указывает на строку в теле замыкания, которая передаёт `значение` из окружения. Чтобы исправить это, нужно изменить тело замыкания так, чтобы оно не передавало право владения значения из окружения. Для подсчёта количества вызовов замыканий более простым способом является хранение счётчика в окружении. Замыкание в приложении 13-9 работает с `sort_by_key`, поскольку оно получает только изменяемую ссылку на счётчик `количество_упорядочиваний` и поэтому может быть вызвано более одного раза:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-09/src/main.rs}}
```

<span class="caption">Приложение 13-9: Решение для использование замыкания с сущностью<code>FnMut</code> со способом <code>sort_by_key</code></span>

Сущности `Fn` важны при определении или использовании способов (функций) или видов данных, использующих замыкания. В следующем разделе мы обсудим повторители. Многие способы повторителей принимают переменные в виде замыканий, поэтому не забывайте об этих подробностях, пока мы продвигаемся дальше!


