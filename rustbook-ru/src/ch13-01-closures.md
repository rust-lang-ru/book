<!-- Old heading. Do not remove or links may break. -->

<a id="closures-anonymous-functions-that-can-capture-their-environment"></a>

## Замыкания: анонимные функции, которые запечатлевают ("захватывают") своё окружение

Замыкания в Ржавчине - это анонимные функции, которые можно сохранять в переменных или передавать в качестве переменных другим функциям. Вы можете создать замыкание в одном месте, а затем вызвать его в каком-нибудь другом, чтобы выполнить обработку в ином среде. В отличие от функций, замыкания могут использовать значения из области видимости в которой они были определены. Мы выполним, как эти функции замыканий открывают возможности для повторного использования рукописи и изменения его поведения.

<!-- Old headings. Do not remove or links may break. -->

<a id="creating-an-abstraction-of-behavior-with-closures"></a>
<a id="refactoring-using-functions"></a>
<a id="refactoring-with-closures-to-store-code"></a>

### Захват переменных окружения с помощью замыкания

Сначала мы рассмотрим, как с помощью замыканий можно использовать предметы из области, в которой они вместе были определены, для их последующего использования. Вот задумка: Время от времени наше предприятие по производству футболок в качестве акции дарит эксклюзивные футболки, выпущенные ограниченным тиражом, каким-нибудь пользователям из нашего списка рассылки. Люди из списка рассылки при желании могут выбрать любимый цвет в своём профиле. Если человек, выбранный для получения бесплатной футболки, указал свой любимый цвет, он получает футболку этого цвета. Если человек не указал свой любимый цвет, он получит рубашку того цвета, которых у предприятия на данное мгновение больше всего.

Существует множество способов выполнить это. В данном примере мы будем использовать перечисление `ShirtColor`, которое может быть двух исходов `Red` и `Blue` (для простоты ограничим количество доступных цветов этими двумя). Запасы предприятия мы представим стопкой `Inventory`, которая состоит из поля `shirts`, содержащего `Vec<ShirtColor>`, в котором перечислены рубашки тех цветов, которые есть в наличии. Способ `giveaway`, определённый в `Inventory`, принимает необязательный свойство - цвет, предпочитаемый пользователем, выбранным для получения бесплатной рубашки, и возвращает тот цвет рубашки, который он получит в действительности. Эта схема показана в приложении 13-1:

<span class="filename">Имя файла: src/main.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-01/src/main.rs}}
```

<span class="caption">Приложение 13-1: Случай с раздачей рубашек предприятием</span>

В магазине `store`, определённом в `main`, осталось две синие и одна красная рубашки для этой ограниченной акции. Мы вызываем способ `giveaway` для пользователя предпочитающего красную рубашку и для пользователя без каких-либо предпочтений.

Опять же, эта рукопись могла быть выполнена множеством способов, но в данном случае, чтобы сосредоточиться на замыканиях, мы придерживались изученных ранее подходов, за исключением тела способа `giveaway`, в котором используется замыкание. В способе `giveaway` мы получаем пользовательское предпочтение цвета как свойство вида данных `Option<ShirtColor>` и вызываем способ `unwrap_or_else` на `user_preference`. Способ <a data-md-type="raw_html" href="../std/option/enum.Option.html#method.unwrap_or_else">`unwrap_or_else` перечисления `Option<T>`</a><!-- ignore --> определён встроенной библиотекой. Он принимает одну переменную: замыкание без переменных, которое возвращает значение `T` (преобразуется в вид значения, которое окажется в исходе `Some` перечисления `Option<T>`, в нашем случае `ShirtColor`). Если `Option<T>` окажется исходом `Some`, `unwrap_or_else` вернёт значение из `Some`. А если `Option<T>` будет является исходом `None`, `unwrap_or_else` вызовет замыкание и вернёт значение, возвращённое замыканием.

В качестве переменной `unwrap_or_else` мы передаём замыкание `|| self.most_stocked()`. Это замыкание, которое не принимает никаких свойств (если бы у замыкания были свойства, они были бы перечислены между двумя вертикальными полосами). В теле замыкания вызывается `self.most_stocked()`. Здесь мы определили замыкание, а использование `unwrap_or_else` такова, что выполнится оно позднее, когда потребуется получить итог.

Выполнение этой рукописи выводит:

```console
{{#include ../listings/ch13-functional-features/listing-13-01/output.txt}}
```

Важной особенностью здесь является то, что мы передали замыкание, которое вызывает `self.most_stocked()` текущего образца данных `Inventory`. Обычной библиотеке не нужно знать ничего о видах `Inventory` или `ShirtColor`, которые мы определили, или о ходу мыслей, которую мы хотим использовать в этом задумки. Замыкание определяет неизменяемую ссылку на `self` `Inventory` и передаёт её с указанным нами рукописью в способ `unwrap_or_else`. А вот функции не могут определять своё окружение таким образом.

### Выведение и изложение видов замыкания

Есть и другие различия между функциями и замыканиями. Замыкания обычно не требуют определенния видо данныхв входных свойств или возвращаемого значения, как это делается в функциях `fn`. Изложения видов данных требуются для функций, потому что виды данных являются частью явного внешней оболочки, предоставляемого пользователям. Жёсткое определение таких внешних оболочек важно для того, чтобы все были согласованы в том, какие виды значений использует и возвращает функция. А вот замыкания, напротив, не употребляются взначении подобных открытых внешних оболочек: они хранятся в переменных, используются не имея имени и незримо для пользователей нашей библиотеки.

Замыкания, как правило, небольшие и уместны в каком-то узконаправленном среде, а не в произвольных случаях. В этих ограниченных средах сборщик может вывести виды свойств и возвращаемого вида данных, подобно тому, как он может вывести виды данных большинства переменных (есть редкие случаи, когда сборщику также нужны изложении видов замыканий).

Как и в случае с переменными, мы можем добавить изложении видов данных, если хотим повысить ясность и чёткость описания ценой увеличения многословности, большей чем это необходимо. Определение видов данных для замыкания будет выглядеть как определение, показанное в приложении 13-2. В этом примере мы определяем замыкание и храним его в переменной, а не определяем замыкание в том месте, куда мы передаём его в качестве переменной, как это было в приложении 13-1.

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-02/src/main.rs:here}}
```

<span class="caption">Приложение 13-2: Добавление необязательных наставлений видов свойств и возвращаемых значений в замыкании</span>

С добавлением наставлений видов данных правила написания замыканий выглядит более похожим на правила написания функций. Здесь мы, для сравнения, определяем функцию, которая добавляет 1 к своему свойству, и замыкание, которое имеет такое же поведение. Мы добавили несколько пробелов, чтобы выровнять соответствующие части. Это показывает, что правила написания замыкания похож на правила написания функции, за исключением использования труб (вертикальная черта) и количества необязательного правил написания:

```rust,ignore
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
```

В первой строке показано определение функции, а во второй - полностью определенное определение замыкания. В третьей строке мы удаляем изложении видов данных из определения замыкания. В четвёртой строке мы убираем скобки, которые являются необязательными, поскольку тело замыкания содержит только одно действие. Это всё правильные определения, которые будут иметь одинаковое поведение при вызове. Строки `add_one_v3` и `add_one_v4` требуют, чтобы замыкания были вычислены до сборки, поскольку виды данных будут выведены из их использования. Это похоже на `let v = Vec::new();`, когда в `Vec` необходимо вставить либо изложении видов данных, либо значения некоторого вида данных, чтобы Ржавчина смогла вывести вид данных.

Для определений замыкания сборщик выводит определенные виды данных для каждого из свойств и возвращаемого значения. Например, в приложении 13-3 показано определение короткого замыкания, которое просто возвращает значение, полученное в качестве свойства. Это замыкание не очень полезно, кроме как для целей данного примера. Обратите внимание, что мы не добавили в определение никаких наставлений видо данных. Поскольку наставлений видов данных нет, мы можем вызвать замыкание для любого вида данных, что мы и сделали в первый раз с `String`. Если затем мы попытаемся вызвать `example_closure` для целого числа, мы получим ошибку.

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-03/src/main.rs:here}}
```

<span class="caption">Приложение 13-3: Попытка вызова замыкания, виды которого выводятся из двух разных видов данных</span>

Сборщик вернёт нам вот такую ошибку:

```console
{{#include ../listings/ch13-functional-features/listing-13-03/output.txt}}
```

При первом вызове `example_closure` со значением `String` сборщик определяет вид данных `x` и возвращаемый вид данных замыкания как `String`. Эти виды данных затем определятся в замыкании в `example_closure`, и мы получаем ошибку вида данных при следующей попытке использовать другой вид данных с тем же замыканием.

### Захват ссылок или передача владения

Замыкания могут захватывать значения из своего окружения тремя способами, которые соответствуют тем же трём способам, которыми функция может принимать свойства: заимствование неизменяемых, заимствование изменяемых и получение владения. Замыкание самостоятельно определяет, какой из этих способов использовать, исходя из того, что тело функции делает с полученными значениями.

В приложении 13-4 мы определяем замыкание, которое захватывает неизменяемую ссылку на вектор с именем `list`, поскольку неизменяемой ссылки достаточно для выводе значения:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-04/src/main.rs}}
```

<span class="caption">Приложение 13-4: Определение и вызов замыкания, которое захватывает неизменяемую ссылку</span>

Этот пример также отображает, то что переменная может быть привязана к определению замыкания, и в дальнейшем мы можем вызвать замыкание, используя имя переменной и круглые скобки, как если бы имя переменной было именем функции.

Поскольку мы можем иметь несколько неизменяемых ссылок на `list` одновременно, `list` остаётся доступным из рукописи до определения замыкания, после определения замыкания, а также до вызова замыкания и после. Эта рукопись собирается, выполняется и выводит:

```console
{{#include ../listings/ch13-functional-features/listing-13-04/output.txt}}
```

В следующем приложении 13-5 мы изменили тело замыкания так, чтобы оно добавляло переменную в вектор `list`. Теперь замыкание захватывает изменяемую ссылку:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-05/src/main.rs}}
```

<span class="caption">Приложение 13-5. Определение и вызов замыкания, захватывающего изменяемую ссылку</span>

Эта рукопись собирается, запускается и выводит:

```console
{{#include ../listings/ch13-functional-features/listing-13-05/output.txt}}
```

Обратите внимание, что между определением и вызовом замыкания `borrows_mutably` больше нет `println!`: когда определяется `borrows_mutably`, оно захватывает изменяемую ссылку на `list`. После вызова замыкания мы больше не используем его, поэтому изменяемое заимствование заканчивается. Между определением замыкания и вызовом замыкания неизменяемое заимствование для выводе недоступно, потому что при наличии изменяемого заимствования никакие другие заимствования недопустимы. Попробуйте добавить туда `println!` и посмотрите, какое сообщение об ошибке вы получите!

Если вы хотите заставить замыкание принять владение значениями, которые оно использует в окружении, даже если в теле замыкания нет рукописи, требующего владения, вы можете использовать ключевое слово `move` перед списком свойств.

Эта техника в основном полезна при передаче замыкания новому потоку, чтобы переместить данные так, чтобы они принадлежали новому потоку. Мы подробно обсудим потоки и то, зачем их использовать, в главе 16, когда будем говорить о одновременности, а пока давайте вкратце рассмотрим порождение нового потока с помощью замыкания, в котором используется ключевое слово `move`. В приложении 13-6 показана рукопись из приложения 13-4, измененный для выводе вектора в новом потоке, а не в основном потоке:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-06/src/main.rs}}
```

<span class="caption">Приложение 13-6: Использование <code>move</code> для принуждения замыкания потока принять на себя владение <code>list</code></span>

Мы порождаем новый поток, передавая ему в качестве переменной замыкание для выполнения. Тело замыкания выводит список. В приложении 13-4 замыкание захватило `list` только с помощью неизменяемой ссылки, потому что это наименьше необходимый доступ к `list` для его выводе. В этом примере, несмотря на то, что тело замыкания по-прежнему требует только неизменяемой ссылки, нам нужно указать, что `list` должен быть перемещён в замыкание, поместив ключевое слово `move` в начало определения замыкания. Новый поток может завершиться раньше, чем завершится основной поток, или основной поток может завершиться первым. Если основной поток сохранил владение `list`, но завершился раньше нового потока и удалил `list`, то неизменяемая ссылка в потоке будет недействительной. Поэтому сборщик требует, чтобы `list` был перемещён в замыкание, переданное новому потоку, чтобы ссылка была действительной. Попробуйте убрать ключевое слово `move` или использовать `list` в основном потоке после определения замыкания и посмотрите, какие ошибки сборщика вы получите!

<!-- Old headings. Do not remove or links may break. -->

<a id="storing-closures-using-generic-parameters-and-the-fn-traits"></a>
<a id="limitations-of-the-cacher-implementation"></a>
<a id="moving-captured-values-out-of-the-closure-and-the-fn-traits"></a>

### Перемещение захваченных значений из замыканий и сущности `Fn`

После того, как замыкание захватило ссылку или владение значением из среды, в которой оно определено (тем самым влияя на то, что перемещается *в* замыкание), рукопись в теле замыкания определяет, что происходит со ссылками или значениями, в мгновение последующего выполнения замыкания (тем самым влияя на то, что перемещается *из* замыкания). Тело замыкания может делать любое из следующих действий: перемещать захваченное значение из замыкания, изменять захваченное значение, не перемещать и не изменять значение или вообще ничего не захватывать из среды.

То, как замыкание получает и обрабатывает значения из своего окружения, указывает на то, какие сущности используют замыкание, а с помощью сущностей функции и стопки могут определять, какие виды замыканий они могут использовать. Замыканиям самостоятельно присваивается выполнение одного, двух или всех трёх из нижеперечисленных сущностей `Fn`, аддитивным образом, в зависимости от того, как тело замыкания обрабатывает значения:

1. `FnOnce` применяется к замыканиям, которые могут быть вызваны один раз. Все замыкания используют по крайней мере эту сущность, потому что все замыкания могут быть вызваны. Замыкание, которое перемещает захваченные значения из своего тела, использует только `FnOnce` и ни один из других признаков `Fn`, потому что оно может быть вызвано только один раз.
2. `FnMut` применяется к замыканиям, которые не перемещают захваченные значения из своего тела, но могут изменять захваченные значения. Такие замыкания могут вызываться более одного раза.
3. `Fn` применяется к замыканиям, которые не перемещают захваченные значения из своего тела и не изменяют захваченные значения, а также к замыканиям, которые ничего не захватывают из своего окружения. Такие замыкания могут выполняться более одного раза и не меняют ничего в своём окружении, что важно в таких случаях, как одновременный вызов замыкания несколько раз.

Давайте рассмотрим определение способа `unwrap_or_else` у `Option<T>`, который мы использовали в приложении 13-1:

```rust,ignore
impl<T> Option<T> {
    pub fn unwrap_or_else<F>(self, f: F) -> T
    where
        F: FnOnce() -> T
    {
        match self {
            Some(x) => x,
            None => f(),
        }
    }
}
```

Напомним, что `T` - это гибкий вид данных, отображающий вид значения в `Some` исходе `Option`. Этот вид данных `T` также является возвращаемым видом функции `unwrap_or_else`: например, рукопись, вызывающая `unwrap_or_else` у `Option<String>`, получит `String`.

Далее, обратите внимание, что функция `unwrap_or_else` имеет дополнительное свойство гибкого вида данных `F`. Здесь `F` - это вид входного свойства `f`, который является замыканием, заданным нами при вызове `unwrap_or_else`.

Ограничением сущности, заданным для обобщённого вида данных `F`, является `FnOnce() -> T`, что означает, что `F` должен вызываться один раз, не принимать никаких переменных и возвращать `T`. Использование `FnOnce` в ограничении сущности говорит о том, что `unwrap_or_else` должен вызывать `f` не более одного раза. В теле `unwrap_or_else` мы видим, что если `Option` будет равен `Some`, то `f` не будет вызван. Если же значение `Option` будет равным `None`, то `f` будет вызван один раз. Поскольку все замыкания используют `FnOnce`, `unwrap_or_else` принимает самые разные виды замыканий и является настолько гибким, насколько это возможно.

> Примечание: Функции также могут использовать все три сущности `Fn`. Если то, что мы хотим сделать, не требует захвата значения из среды, мы можем передавать имя какой-либо функции, а не замыкания, когда нам нужно что-то, выполняющее одну из сущностей `Fn`. Например, для значения `Option<Vec<T>>` мы можем вызвать `unwrap_or_else(Vec::new)`, чтобы получить новый пустой вектор, если значение окажется `None`.

Теперь рассмотрим способ встроенной библиотеки `sort_by_key`, определённый у срезов, чтобы увидеть, чем он отличается от `unwrap_or_else` и почему `sort_by_key` использует `FnMut` вместо `FnOnce` для ограничения сущности. Замыкание принимает единственная переменная в виде ссылки на текущую переменную в рассматриваемом срезе и возвращает значение вида данных `K`, к которому применимо упорядочивание. Эта функция полезна, когда вы хотите упорядочить срез по определённому свойству каждой переменной. В приложении 13-7 у нас есть список образцов `Rectangle`, и мы используем `sort_by_key`, чтобы упорядочить их по свойству `width` от меньшего к большему:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-07/src/main.rs}}
```

<span class="caption">Приложение 13-7: Использование <code>sort_by_key</code> для упорядочивания прямоугольников по ширине</span>

Эта рукопись выводит:

```console
{{#include ../listings/ch13-functional-features/listing-13-07/output.txt}}
```

Причина, по которой `sort_by_key` определена как принимающая замыкание `FnMut`, заключается в том, что она вызывает замыкание несколько раз: по одному разу для каждой переменной в срезе. Замыкание `|r| r.width` не захватывает, не изменяет и не перемещает ничего из своего окружения, поэтому оно удовлетворяет требованиям связанности признаков.

И наоборот, в приложении 13-8 показан пример замыкания, которое использует только признак `FnOnce`, потому что оно перемещает значение из среды. Сборщик не позволит нам использовать это замыкание с `sort_by_key`:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-08/src/main.rs}}
```

<span class="caption">Приложение 13-8: Попытка использовать замыкание <code>FnOnce</code> с <code>sort_by_key</code></span>

Это надуманный, замысловатый способ (который не работает) подсчёта количества вызовов `sort_by_key` при упорядочиванию `list`. Эта рукопись пытается выполнить подсчёт, перемещая `value` - `String` из окружения замыкания - в вектор `sort_operations`. Замыкание захватывает `value`, затем перемещает `value` из замыкания, передавая владение на `value` вектору `sort_operations`. Это замыкание можно вызвать один раз; попытка вызвать его второй раз не сработает, потому что `value` уже не будет находиться в той среде, из которой его можно будет снова поместить в `sort_operations`! Поэтому это замыкание использует только `FnOnce`. Когда мы попытаемся собрать эту рукопись, мы получим ошибку сообщающую о том что `value` не может быть перемещено из замыкания, потому что замыкание должно использовать `FnMut`:

```console
{{#include ../listings/ch13-functional-features/listing-13-08/output.txt}}
```

Ошибка указывает на строку в теле замыкания, которая перемещает `value` из окружения. Чтобы исправить это, нужно изменить тело замыкания так, чтобы оно не перемещало значения из окружения. Для подсчёта количества вызовов `sort_by_key` более простым способом является хранение счётчика в окружении и увеличение его значения в теле замыкания. Замыкание в приложении 13-9 работает с `sort_by_key`, поскольку оно определяет только изменяемую ссылку на счётчик `num_sort_operations` и поэтому может быть вызвано более одного раза:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-09/src/main.rs}}
```

<span class="caption">Приложение 13-9: Использование замыкания <code>FnMut</code> с <code>sort_by_key</code> разрешено</span>

Сущности `Fn` важны при определении или использовании функций или видов данных, использующих замыкания. В следующем разделе мы обсудим повторители. Многие способы повторителей принимают переменные в виде замыканий, поэтому не забывайте об этих подробностях, пока мы продвигаемся дальше!


