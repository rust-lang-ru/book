## Неустранимые ошибки с макросом `panic!`

Иногда в рукописи происходят плохие вещи, и вы ничего не можете с этим поделать. В этих случаях у Ржавчины есть макрос panic! В действительности существует два способа вызвать сбой: путём выполнения действия, которое вызывает сбой в нашей рукописи (например, обращение к массиву за пределами его размера) или путём явного вызова макроса `panic!`. В обоих случаях мы вызываем сбой в нашей программе. По умолчанию сбой выводит сообщение об ошибке, раскрывает и очищает все содержимое в обойме вызовов действий и способов, после чего завершают работу. С помощью переменного окружения вы также можете заставить Ржавчину отобразить содержимое обоймы вызовов при возникновении сбоя, чтобы было легче отследить источник сбоя.

> ### Раскрытие обоймы действий и способов или прервать выполнения приложения в ответ на сбой?
>
> По умолчанию, когда происходит сбой, приложение начинает этап *раскрытия содержимого обоймы*, означающий в Ржавчине проход обратно по содержимому обоймы вызовов действий и способов, далее очистку данных для каждой обнаруженного действия и способа.  Тем не менее, этот обратный проход по обойме и её очистка порождают много работы. Ржавчина, предоставляет нам иное решение - возможность *немедленного прерывания* (aborting), которое завершает работу приложения без очистки.
>
> Память, которую использовала приложение, должна быть очищена операционной системой. Если в вашем деле необходимо чтобы исполняемый файл был наименьшего размера, вы можете выбрать раскрытие обоймы (и очистка памяти) либо прервать выполнение приложения при возникновении сбоя. Для того чтобы прервать выполнение приложения, добавьте в раздел [profile] вашего <code>Cargo.toml</code> файла строку `panic = 'abort'` . Например, если вы хотите прервать сбой в режиме исполнения, добавьте это:
>
> ```toml
> [profile.release]
> panic = 'abort'
> ```

Давайте попробуем вызвать `panic!` в простой программе:

<span class="filename">Файл: src/main.rs</span>

```rust,should_panic,panics
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-01-panic/src/main.rs}}
```

При запуске приложения, вы увидите что-то вроде этого:

```console
{{#include ../listings/ch09-error-handling/no-listing-01-panic/output.txt}}

```

Использование макроса `panic!` вызывает сообщение об ошибке, содержащееся в двух последних строках. Первая строка показывает сообщение сбоя и место в исходной рукописи, где возникла сбой: *src/main.rs:2:5* указывает, что это вторая строка, пятый знак внутри нашего файла *src/main.rs*

В этом случае указанная строка является частью нашей рукописи, и если мы перейдём к этой строке, мы увидим  вызов макроса `panic!`. В других случаях вызов `panic!` мог бы произойти в сторонней рукописи, которая вызывает нашу рукопись, тогда имя файла и номер строки для сообщения об ошибке будет из чужой рукописи, где макрос `panic!` вызван, а не из строк нашей рукописи, которые в конечном итоге привели к вызову `panic!`. Мы можем использовать обратный отсчёт вызовов функций, которые вызвали `panic!` чтобы выяснить, какая часть нашей рукописи вызывает неполадку. Мы обсудим обратный отсчёт более подробно далее.

### Использование обратного отсчёта `panic!`

Давайте посмотрим на другой пример, где, вызов `panic!` происходит в сторонней библиотеке из-за ошибки в нашей рукописи (а не как в примере ранее, из-за вызова макроса нашей рукописью напрямую). В приложении 9-1 приведена рукопись, которая пытается получить доступ по порядковому указателю в векторе за пределами допустимых границ внутри вектора.

<span class="filename">Файл: src/main.rs</span>

```rust,should_panic,panics
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-01/src/main.rs}}
```

<span class="caption">Приложение 9-1: Попытка доступа к переменной ряда за пределами границ вектора, которая вызовет <code>panic!</code></span>

Здесь мы пытаемся получить доступ к 100-й переменной вектора (которая находится по порядковому указателю 99, потому 1-ая переменная имеет `[0]` порядковый указатель ), но вектор имеет только 3 переменных. В этой случае, Ржавчина будет вызывать сбой. Использование `[]` должно возвращать переменную, но вы передаёте неверный порядковый указатель: не существует переменной, которую Ржавчина могла бы вернуть.

В языке C, например, попытка прочесть за пределами границ или размера (в нашем случае векторе) приведёт к *неопределённому поведению, undefined behavior, UB*. Вы всё равно получите значение, которое находится в том месте памяти компьютера, которое соответствовало бы этой переменной в векторе, несмотря на то, что память по тому адресу совсем не принадлежит вектору (всё просто: C рассчитал бы место хранения переменной с порядковым указателем 99 и считал бы то, что там хранится, упс). Это называется *чтением за пределом буфера, buffer overread,* и может привести к уязвимостям безопасности. Если злоумышленник может управлять порядковым указателем таким образом, то у него появляется возможность считывать данные, к которым он не должен иметь доступа для чтения.

Чтобы защитить вашу программу от такого рода уязвимостей при попытке получить доступ к переменной ряда с порядковым указателем, которого не существует, Ржавчина остановит выполнение и откажется продолжить работу приложения. Давайте попробуем так сделать и посмотрим на поведение Ржавчины:

```console
{{#include ../listings/ch09-error-handling/listing-09-01/output.txt}}
```

Следующая строка говорит, что мы можем установить переменную среды `RUST_BACKTRACE`, чтобы получить обратный отсчёт того, что именно стало причиной ошибки. <em>Обратный отсчёт</em> создаёт список всех функций, которые были вызваны до какой-то определённой точки выполнения приложения. Обратный отсчёт в Ржавчине работает так же, как и в других языках. По этому предлагаем вам читать данные обратного отсчёта как и везде - читать сверху вниз, пока не увидите сведения о файлах написанных вами. Это место, где возникла неполадка. Другие строки, которые выше над строками с упоминанием наших файлов, - это рукопись, которая вызывается нашей рукописью; строки ниже являются рукописью, которая вызывает нашу рукопись. Эти строки могут включать основную рукопись Ржавчины, рукопись встроенной библиотеки или используемые дополнения. Давайте попробуем получить обратный отсчёт с помощью установки переменной среды <code>RUST_BACKTRACE</code> в любое значение, кроме 0. Приложение 9-2 показывает вывод, подобный тому, что вы увидите.

<!-- manual-regeneration
cd listings/ch09-error-handling/listing-09-01
RUST_BACKTRACE=1 cargo run
copy the backtrace output below
check the backtrace number mentioned in the text below the listing
-->

```console
$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/std/src/panicking.rs:584:5
   1: core::panicking::panic_fmt
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:142:14
   2: core::panicking::panic_bounds_check
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:84:5
   3: <usize as core::slice::index::SliceIndex<[T]>>::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:242:10
   4: core::slice::index::<impl core::ops::index::Index<I> for [T]>::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:18:9
   5: <alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/alloc/src/vec/mod.rs:2591:9
   6: panic::main
             at ./src/main.rs:4:5
   7: core::ops::function::FnOnce::call_once
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/ops/function.rs:248:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
```

<span class="caption">Приложение 9-2: Обратный отсчёт, созданная вызовом <code>panic!</code>, когда установлена переменная окружения <code>RUST_BACKTRACE</code></span>

Тут много вывода! Вывод, который вы увидите, может отличаться от представленного, в зависимости от вашей операционной системы и исполнения Ржавчины. Для того, чтобы получить обратный отсчёт с этими сведениями, должны быть включены <em>знаки отладки, debug symbols</em>. Знаки отладки включены по умолчанию при использовании `cargo build` или `cargo run` без клейма `--release`, как у нас в примере.

В выводе обратного отсчёта приложения 9-2, строка #6 указывает на строку в нашем деле, которая вызывала неполадку: строка 4 из файла *src/main.rs.* Если мы не хотим, чтобы наша приложение вызвала сбой, мы должны начать исследование с места, на которое указывает первая строка с упоминанием нашего файла. В приложении 9-1, где мы для отображения обратного отсчёта сознательно написали рукопись, которая вызывает сбой, способ исправления сбоя состоит в том, чтобы не запрашивать переменную за пределами границ вектора. Когда ваша рукопись вызовет сбой в будущем, вам нужно будет выяснить, какое выполняющееся рукописью действие, с какими значениями вызывает сбой и что эта рукопись должна делать вместо этого.

Мы вернёмся к обсуждению макроса `panic!`, и того когда нам следует и не следует использовать `panic!` для обработки ошибок в разделе <a data-md-type="raw_html" href="ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic">"`panic!` или НЕ `panic!`"</a><!--  --> этой Главы. Далее мы рассмотрим, как восстановить выполнение приложения после исправляемых ошибок, использующих вид данных `Result`.
