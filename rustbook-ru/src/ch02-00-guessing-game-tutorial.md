# Программируем игру в загадки

Давайте окунёмся в Ржавчине, вместе поработав над опытным делом! В этой главе вы познакомитесь с несколькими общими подходами Ржавчина показав, как использовать их в существующей программе. Вы узнаете о `let` , `match`, способах, сопряженных функциях, внешних дополнениях и многом другом! В следующих главах мы рассмотрим эти мысли более подробно. В этой главе вы просто примените в основах.

Мы выполняем привычную для начинающих программистов задачу — игру в загадки. Вот как это работает: программа порождает случайное целое число в ряде от 1 до 100. Затем она предлагает игроку его угадать. После ввода числа программа укажет, меньше или больше было загаданное число. Если догадка верна, игра выведет поздравительное сообщение и завершится.

## Настройка нового дела

Для настройки нового дела перейдите в папку *projects*, которую вы создали в главе 1, и создайте новое дело с использованием Cargo, как показано ниже:

```console
$ cargo new guessing_game
$ cd guessing_game
```

Первый приказ, `cargo new`, принимает в качестве первой переменной имя дела (`guessing_game`). Второй приказ изменяет папку на новую папку дела.

Загляните в созданный файл *Cargo.toml*:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial
rm -rf no-listing-01-cargo-new
cargo new no-listing-01-cargo-new --name guessing_game
cd no-listing-01-cargo-new
cargo run > output.txt 2>&1
cd ../../..
-->

<span class="filename">Файл: Cargo.toml</span>

```toml
{{#include ../listings/ch02-guessing-game-tutorial/no-listing-01-cargo-new/Cargo.toml}}
```

Как вы уже видели в главе 1, `cargo new` создаёт программу «Hello, world!». Посмотрите файл *src/main.rs*:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-01-cargo-new/src/main.rs}}
```

Теперь давайте соберем программу «Hello, world!» и сразу на этом же этапе запустим её с помощью приказов `cargo run`:

```console
{{#include ../listings/ch02-guessing-game-tutorial/no-listing-01-cargo-new/output.txt}}
```

Приказ `run` пригодится, когда необходимо ускоренно выполнить повторение дела. Именно так мы собираемся делать в этом деле, быстро проверяя каждую повторение, прежде чем перейти к следующей.

Снова откройте файл *src/main.rs*. всю рукопись вы будете писать в нем.

## Обработка догадки

Первая часть программы запрашивает ввод данных пользователем, обрабатывает их и проверяет, что они в ожидаемой виде. Начнём с того, что позволим игроку ввести догадку. Вставьте рукопись из приложения 2-1 в *src/main.rs*.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:all}}
```

<span class="caption">Приложение 2-1: Рукопись, которая получает догадку от пользователя и выводит её на экран</span>

Эта рукопись содержит много сведений, поэтому давайте рассмотрим её построчно. Чтобы получить пользовательский ввод и затем вывести итог, нам нужно включить в область видимости библиотеку ввода/вывода `io`. Библиотека `io` является частью встроенной библиотеки, известной как `std`:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:io}}
```

По умолчанию в Ржавчине есть рукопись (содержимое), определённых во встроенной библиотеке, которые он добавляет в область видимости каждой программы. Этот набор называется *встроенным*, и вы можете изучить его содержание [в пособии встроенной библиотеки].

Если вид данных, который требуется использовать, отсутствует во встроенном наборе, его нужно явно ввести в область видимости с помощью приказчика `use`. Использование библиотеки `std::io` предоставляет ряд полезных полезных возможностей, включая способность принимать пользовательский ввод.

Как уже отмечалось в главе 1, функция `main` является точкой входа в программу:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:main}}
```

Ключевое слово `fn` объявляет новую функцию, круглые скобки `()` показывают, что у функции нет входных свойств, узорчатая скобка `{` - обозначение начала тела функции.

Также в главе 1 упоминалось, что `println!` — это макрос, который выводит строку на экран:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:print}}
```

Эта рукопись показывает сведения о ходе игры и запрашивает пользовательский ввод.

### Хранение значений с помощью переменных

Далее мы создаём *переменную* для хранения пользовательского ввода, как показано ниже:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:string}}
```

Вот теперь программа становится важнее! В этой маленькой строке на самом деле происходит очень многое. Для создания переменной мы используем приказчик `let`. Вот ещё один пример:

```rust,ignore
let apples = 5;
```

Эта строка создаёт новую переменную с именем `apples` и привязывает её к значению 5. В Ржавчине переменные неизменяемы по умолчанию, то есть как только мы присвоим переменной значение, оно не изменится. Мы подробно обсудим этот подход в разделе ["Переменные и изменчивость".]<!-- ignore --> в главе 3. Чтобы сделать переменную изменяемой, мы добавляем `mut` перед её именем:

```rust,ignore
let apples = 5; // неизменяемая
let mut bananas = 5; // изменяемая
```

>  Примечание: сочетание знаков `//` начинает примечание, которое продолжается до конца строки. Ржавчина пренебрегает всё, что находится в примечаниях. Мы обсудим примечания более подробно в [Главе 3]<!-- ignore -->.
>

Возвращаясь к программе игры "Угадайка" — теперь вы знаете, что `let mut guess` предоставит изменяемую переменную с именем `guess`. Знак равенства (`=`) сообщает Ржавчине, что сейчас нужно связать что-то с этой переменной. Справа от знака равенства находится значение, связанное с `guess`, которое является итогом вызова функции `String::new`, возвращающей новый образец данных `String`. <a data-md-type="raw_html" href="../std/string/struct.String.html">`String`</a> — это вид данных `строка`, предоставляемый встроенной библиотекой, который является расширяемым отрывком писания в представлении UTF-8.

Правила написания `::` в строке `::new` указывают, что `new` является сопряженной функцией вида данных `String`. *Сопряженная функция* — это функция, используемая для вида данных, в данном случае `String`. Функция `new` создаёт новую пустую строку. Функцию `new` можно встретить во многих видах данных, это привычное название для функции, которая создаёт новое значение какого-либо вида данных.

В конечном итоге строка `let mut guess = String::new();` создала изменяемую переменную, которая связывается с новым пустым образцом `String`. Фух!

### Получение пользовательского ввода

Напомним: мы подключили возможность ввода/вывода из встроенной библиотеки с помощью `use std::io;` в первой строке программы. Теперь мы вызовем функцию `stdin` из раздела `io`, которая позволит нам обрабатывать пользовательский ввод:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:read}}
```

Если бы мы не подключили библиотеку `io` с помощью `use std::io` в начале программы, мы все равно могли бы использовать эту функцию, записав её вызов как `std::io::stdin`. Функция `stdin` возвращает образец [`std::io::Stdin`], который является видом данных, представляющим указатель принятого ввода для вашего окна вызова.

Далее строка `.read_line(&mut guess)` вызывает способ [`read_line`] на указатель принятой переменной для получения ввода от пользователя. Мы также передаём `&mut guess` в качестве переменной `read_line`, сообщая ему, в какой строке хранить пользовательский ввод. Главная задача `read_line` — принять все, что пользователь вводит в обычный ввод, и сложить это в строку (не переписывая её содержимое), поэтому мы передаём эту строку в качестве переменной. Строковая переменная должна быть изменяемая, чтобы при вызове способа можно изменить содержимое строки в переменной `mut guess`.

Знак `&` указывает, что эта переменная является *ссылкой*, которая предоставляет возможность нескольким частям вашей рукописи получить доступ к одному отрывку данных без необходимости воспроизводить эти данные в память несколько раз. Ссылки — это сложная и очень полезная возможность, так одним из главных преимуществ Ржавчины является безопасность и простота использования ссылок. Чтобы дописать эту программу, вам не понадобится знать много таких подробностей. Пока вам достаточно знать, что ссылки, как и переменные, по умолчанию неизменяемы. Соответственно, чтобы сделать её изменяемой, нужно написать `&mut guess`, а не `&guess`. (В главе 4 ссылки будут описаны более подробно).

<!-- Old heading. Do not remove or links may break. -->

<a id="handling-potential-failure-with-the-result-type"></a>

### Обработка возможного сбоя с помощью способа `Result`

Мы всё ещё работаем над этой строкой рукописи. Сейчас мы обсуждаем третью строку, но обратите внимание, что она по-прежнему является частью одной разумной строки. Следующая часть — способ:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:expect}}
```

Мы могли бы написать эту рукопись так:

```rust,ignore
io::stdin().read_line(&mut guess).expect("Failed to read line");
```

Однако одну длинную строку трудно читать, поэтому лучше разделить её. При вызове способа с помощью правил написания `.method_name()` часто целесообразно вводить новую строку и другие пробельные знаки, чтобы разбить длинные строки. Теперь давайте обсудим, что делает эта строка.

Как упоминалось ранее, `read_line` помещает всё, что вводит пользователь, в строку, которую мы ему передаём, но также возвращает значение `Result`. <a data-md-type="raw_html" href="../std/result/enum.Result.html">`Result`</a><!-- ignore --> — это [*перечисление*]<!-- ignore -->, часто называемое *enum*, то есть вид данных, который может находиться в одном из нескольких возможных состояний. Мы называем каждое такое состояние *исходом*.

В [Главе 6](ch06-00-enums.html) рассмотрим перечисления более подробно. Задачей видов `Result` является кодирование сведений для обработки ошибок.

Исходами `Result` являются `Ok` и `Err`. Исход `Ok` указывает, что действие завершилось успешно, а внутри `Ok` находится успешно преобразованное значение. Исход `Err` означает, что действие не удалось (завершилось с ошибкой), а `Err` содержит сведения о причинах сбоя.

Значения вида данных `Result`, как и значения любого вида данных, имеют определённые для них способы. У образца данных `Result` есть [способ `expect`]<!-- ignore -->, который можно вызвать. Если этот образец данных `Result` является значением `Err`, `expect` вызовет сбой программы и отобразит сообщение, которое вы передали в качестве значения в описании `expect`. Если способ `read_line` возвращает `Err`, то это, скорее всего, итог ошибки основной операционной системы. Если образец данных `Result` является значением `Ok`, `expect` возьмёт возвращаемое значение, которое удерживает `Ok`, и вернёт вам только это значение, чтобы вы могли его использовать далее. В данном случае это значение представляет собой количество байтов, введённых пользователем.

Если не вызвать `expect`, программа собирается, но будет получено предупреждение:

```console
{{#include ../listings/ch02-guessing-game-tutorial/no-listing-02-without-expect/output.txt}}
```

Ржавчина предупреждает о неиспользованном значении `Result`, возвращаемого из `read_line`, показывая, что программа не учла возможность возникновения ошибки.

Правильный способ убрать предупреждение — это написать обработку ошибок, но в нашем случае мы просто хотим со сбоем завершить программу при возникновении сбоев (ошибок), поэтому используем `expect`. О способах восстановления после ошибок вы узнаете в [главе 9].

### Вывод значений с помощью исполнителей `println!`

Кроме закрывающей узорчатой скобки, в рукописи на данное мгновение есть ещё только одно место для обсуждения:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:print_guess}}
```

Эта рукопись выводит строку, которая теперь содержит ввод пользователя. Набор узорчатых скобок `{}` является исполнителем: думайте о `{}` как о маленьких клешнях краба, которые удерживают значение на месте. При выводе значения переменной имя переменной может заключаться в узорчатые скобки. При выводе итога вычисления выражения поместите пустые узорчатые скобки в строку вида, затем после строки вида данных укажите список выражений, разделённых запятыми, которые будут выведены в каждом исполнителе пустой узорчатой скобки в том же порядке. вывод переменной и итога выражения одним вызовом `println!` будет выглядеть так:

```rust
let x = 5;
let y = 10;

println!("x = {x} and y + 2 = {}", y + 2);
```

Эта рукопись выведет `x = 5 and y + 2 = 12`.

### Проверка первой части

Давайте проверим первую часть игры. Запустите её используя `cargo run`:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
```

На данном этапе первая часть игры завершена: мы получаем ввод с клавиатуры и затем выводим его.

## Создание тайного числа

Далее нам нужно создать тайное число, которое пользователь попытается угадать. Тайное число должно быть каждый раз разным, чтобы в игру можно было играть несколько раз. Мы будем использовать случайное число в ряде от 1 до 100, чтобы игра не была слишком сложной. Ржавчина пока не включает возможность порождения случайных чисел в свою встроенную библиотеку. Однако приказ Ржавчины предоставляет дополнение - [ящик `rand`] с подобными возможностями.

### Использование ящика для получения дополнительного возможностей

Помните, что дополнение (crate) - это собрание файлов исходной рукописи Ржавчины. Дело, создаваемое нами, представляет собой <em>двоичное дополнение (binary crate)</em>, которое является исполняемым файлом. Дополнение <code>rand</code> - это <em>библиотечное дополнение (library crate)</em>, содержащее рукопись, которая предназначена для использования в других программах и поэтому не может исполняться сама по себе.

Согласование работы внешних дополнений является тем местом, где Cargo на самом деле блистает. Чтобы начать писать рукопись, использующую `rand`, необходимо изменить файл *Cargo.toml*, включив в него в качестве зависимости дополнение `rand`. Итак, откройте этот файл и добавьте следующую строку внизу под заголовком разделы `[dependencies]`, созданным для вас Cargo. Обязательно укажите `rand` в точности так же, как здесь, с таким же номером исполнения, иначе примеры рукописи из этого урока могут не заработать.

<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->

<span class="filename">Имя файла: Cargo.toml</span>

```toml
{{#include ../listings/ch02-guessing-game-tutorial/listing-02-02/Cargo.toml:8:}}
```

В файле *Cargo.toml* всё, что следует за заголовком, является частью этого раздела, который продолжается до тех пор, пока не начнётся следующий. В `[dependencies]` вы сообщаете Cargo, от каких внешних ящиков зависит ваше дело и какие исполнения этих ящиков вам нужны. В этом случае мы указываем ящик `rand` со определетелем исполнения `0.8.5`. Cargo понимает [управление исполнениями] (иногда называемое *SemVer*), которое является ключом для определения исполнений. Число `0.8.5` на самом деле является сокращением от `^0.8.5`, что означает любое исполнение не ниже <code>0.8.5</code>, но ниже <code>0.9.0</code>.

Cargo рассчитает, что эти исполнения имеют общедоступное API, совместимое с исполнением <code>0.8.5</code>, и вы получите последние исполнения исправлений, которые по-прежнему будут собираться с рукописью из этой Главы. Не обеспечивается, что исполнение <code>0.9.0</code> или выше будет иметь тот же API, что и в следующих примерах.

Теперь, не меняя ничего в рукописи, давайте соберём дело, как показано в приложении 2-2.

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
rm Cargo.lock
cargo clean
cargo build -->

```console
$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
  Downloaded libc v0.2.127
  Downloaded getrandom v0.2.7
  Downloaded cfg-if v1.0.0
  Downloaded ppv-lite86 v0.2.16
  Downloaded rand_chacha v0.3.1
  Downloaded rand_core v0.6.3
   Compiling libc v0.2.127
   Compiling getrandom v0.2.7
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.16
   Compiling rand_core v0.6.3
   Compiling rand_chacha v0.3.1
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
```

<span class="caption">Приложение 2-2: итог выполнения <code>cargo build</code> после добавления ящика rand в качестве дополнения</span>

Вы можете увидеть другие номера исполнений (но все они будут совместимы с рукописью благодаря SemVer), другие строки (в зависимости от операционной системы), а также строки могут быть расположены в другом порядке.

Когда мы подключаем внешнее дополнение, Cargo берет последние исполнения всего, что нужно этого дополнения, из *перечня (registry)*, который является повтором данных с [Crates.io]. Crates.io — это место, где участники сообщества Ржавчины размещают свои дела с открытой исходной рукописью для использования другими.

После обновления перечня Cargo проверяет раздел `[dependencies]` и загружает все указанные в списке дополнения, которые ещё не были загружены. В нашем случае, хотя мы указали только `rand` в качестве дополнения, Cargo также захватил другие дополнения, от которых зависит работа `rand`. После загрузки всех дополнений Ржавчины происходит их сборка, а затем собирает дело с имеющимися дополнениями.

Если сразу же запустить `cargo build` снова, не внося никаких изменений, то кроме строки `Finished` вы не получите никакого вывода. Cargo знает, что он уже загрузил и собрал дополнения, и вы не вносили никаких изменений в файл *Cargo.toml*. Cargo также знает, что вы ничего не изменили в своей рукописи, поэтому он не пересоберет и его. Если делать нечего, он просто завершает работу.

Если вы откроете файл *src/main.rs*, внесёте обыкновенное изменение, а затем сохраните его и снова соберёте, вы увидите только две строки вывода:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->

```console
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
```

Эти строки показывают, что Cargo обновляет сборку только с вашим крошечным изменением в файле *src/main.rs*. Ваши дополнения не изменились, поэтому Cargo знает, что может повторно использовать то, что уже скачано и собрано для них.

#### Обеспечение воспроизводимых сборок с помощью файла *Cargo.lock*

В Cargo есть рычаг, обеспечивающий возможность пересобрать всё тот же артефакт каждый раз, когда вы или кто-либо другой собирает вашу рукопись. Пока вы не укажете обратное, Cargo будет использовать только те исполнения дополнений, которые были заданы ранее. Например, допустим, что на следующей неделе выходит исполнение 0.8.6 дополнения `rand` , и оно содержит важное исправление ошибки, но также отступление, которое может сломать вашу рукопись. Чтобы справиться с этим, Ржавчина создаёт файл *Cargo.lock* при первом запуске `cargo build`, поэтому теперь он есть в папке *guessing_game*.

Когда вы создаёте дело в первый раз, Cargo определяет все исполнения дополнений, которые соответствуют условиям, а затем записывает их в файл *Cargo.lock*. Когда вы будете собирать своё дело в будущем, Cargo увидит, что файл *Cargo.lock* существует, и будет использовать указанные там исполнения, а не выполнять всю работу по выяснению исполнений заново. Это позволяет самостоятельно создавать воспроизводимую сборку. Другими словами, ваше дело останется на <code>0.8.5</code> до тех пор, пока вы явно не обновите его благодаря файлу *Cargo.lock*. Поскольку файл <em>Cargo.lock</em> важен для воспроизводимых сборок, он часто хранится в устройстве управления исполнениями вместе с остальной рукописью дела.

#### Обновление дополнения для получения нового исполнения

Если вы *захотите* обновить дополнение, Cargo предоставляет приказ `update`, который пренебрегает файлом *Cargo.lock* и определяет последние исполнения, соответствующие сведениям из файла *Cargo.toml*. После этого Cargo запишет эти исполнения в файл *Cargo.lock*. Иначе по умолчанию Cargo будет искать только исполнения больше 0.8.5, но при этом меньше 0.9.0. Если дополнение <code>rand</code> имеет два новые исполнения — 0.8.6 и 0.9.0 — то при запуске <code>cargo update</code> вы увидите следующее:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.8.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -->

```console
$ cargo update
    Updating crates.io index
    Updating rand v0.8.5 -> v0.8.6
```

Cargo пренебрегает исполнение 0.9.0. В это мгновение также появится изменение в файле *Cargo.lock*, указывающее на то, что исполнение `rand`, которая теперь используется, равна 0.8.6. Чтобы использовать `rand` исполнения 0.9.0 или любое другое исполнение из последовательности 0.9.*x*, необходимо обновить файл *Cargo.toml* следующим образом:

```toml
[dependencies]
rand = "0.9.0"
```

В следующий раз, при запуске `cargo build`, Cargo обновит перечень доступных дополнений и пересмотрит ваши требования к `rand` в соответствии с новой исполнением, которую вы указали.

Можно много рассказать про [Cargo]<!-- ignore --> и [его внутреннее устройство]<!-- ignore --> которые мы обсудим в главе 14, сейчас это все что вам нужно знать. Cargo позволяет очень легко повторно использовать библиотеки, поэтому Ржавчина разработчики имеют возможность писать меньшие дела, которые составлены из многих дополнений.

### Создание случайного числа

Давайте начнём использовать `rand`, чтобы создать число для угадывания. Следующим шагом будет обновление *src/main.rs*, как показано в приложении 2-3.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-03/src/main.rs:all}}
```

<span class="caption">Приложение 2-3: Добавление рукописи, которая порождает случайное число</span>

Сначала мы добавляем строку `use rand::Rng`. Сущность `Rng` определяет способы, использующие породителями случайных чисел, и эта сущность должна быть в области видимости, чтобы эти способы можно было использовать. В главе 10 мы рассмотрим сущности подробно.

Затем мы добавляем две строки посередине. В первой строке мы вызываем функцию `rand::thread_rng`, дающую нам породитель случайных чисел, который мы собираемся использовать: тот самый, который является местным для текущего потока выполнения и запускается операционной системой. Затем мы вызываем его способ `gen_range`. Этот способ определяется дополнением `Rng`, которое мы включили в область видимости с помощью приказчика `use rand::Rng`. Способ `gen_range` принимает в качестве переменной выражение числового ряда и порождает случайное число в этом ряде. Вид данных используемого выражения числового ряда принимает разновидность `start..=end` и включает нижнюю и верхнюю границы, поэтому, чтобы запросить число от 1 до 100, нам нужно указать `1..=100`.

> Примечание: непросто сразу разобраться, какие сущности использовать, какие способы и функции вызывать из дополнения, поэтому каждое дополнение имеет пособие с указаниями по его использованию. Ещё одной замечательной особенностью Cargo является использование приказов `cargo doc --open`, которые собирают самостоятельное отдельное пособие (не требующего подключение к мировой сети), предоставляемое всеми вашими дополнениями, и открывает его в обозревателе. К примеру, если вы хотите узнать все возможности из дополнения `rand`, запустите приказ `cargo doc --open` и нажмите на вкладку `rand` в боковой панели слева.

Во второй новой строке мы увидим загаданное число. Во время разработки программы полезно иметь возможность её проверять, но в конечном исполнения мы это удалим. Конечно, ведь это совсем не похоже на игру, если программа выводит ответ сразу после запуска!

Попробуйте запустить программу несколько раз:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
```

Вы должны получить разные случайные числа, и все они должны быть числами в ряде от 1 до 100. Отличная работа!

## Сравнение догадки с тайным числом

Теперь, когда у нас есть пользовательский ввод и случайное число, мы можем сравнить их. Этот шаг показан в приложении 2-4. Учтите, что эта рукопись ещё не собирается, подробнее мы объясним дальше.

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-04/src/main.rs:here}}
```

<span class="caption">Приложение 2-4: Обработка возможных возвращаемых значений при сравнении двух чисел</span>

Сначала добавим ещё один приказчик `use`, который подключает дополнение с именем `std::cmp::Ordering` в область видимости из встроенной библиотеки. Способ `Ordering` является ещё одним перечислением и имеет исходы `Less`, `Greater` и `Equal`. Это три возможных исхода при сравнении двух величин.

После чего ниже добавляем пять новых строк, использующих способ `Ordering`. Способ `cmp` сравнивает два значения и может вызываться для всего, что можно сравнить. Он принимает ссылку на все, что требуется сравнить: здесь сравнивается `guess` с `secret_number`. В итоге возвращается исход перечисления способа `Ordering`, которое мы ввели в область видимости с помощью приказчика `use`. Для принятия решения о том, что делать дальше, мы используем выражение [`match`], определяющее, какой исход способа <code>Ordering</code> был возвращён из вызова способа `cmp` со значениями `guess` и `secret_number`.

Выражение `match` состоит из *веток (arms)*. Ветка состоит из *образца* для сопоставления и указания, которое будет выполнено, если значение, переданное в функцию `match`, соответствует образцу данных (условию) этой ветки. Ржавчина принимает значение, полученное из выражения `guess.cmp(&secret_number)` и переданное в функцию `match`, и по очереди просматривает образец данных (условие) каждой ветки. Образцы (условия) и функция `match` — это мощные возможности Ржавчины, позволяющие выразить множество случаев, с которыми может столкнуться ваша рукопись, и обеспечить их обработку. Эти возможности будут подробно раскрыты в главе 6 и главе 18 соответственно.

Давайте рассмотрим пример с выражением `match`, которое мы здесь используем. Скажем, пользователь указал число 50, а случайно созданное тайное число на этот раз — 38.

Когда рукопись сравнивает 50 с 38, способ `cmp` вернёт `Ordering::Greater`, поскольку 50 больше, чем 38. Выражение `match` получит значение `Ordering::Greater` и начнёт проверять образец данных в каждой ветке. Он просмотрит образец данных первой ветки, `Ordering::Less`, и увидит, что значение `Ordering::Greater` не соответствует `Ordering::Less`, поэтому пренебрегает условием (образцом) этой ветки и перейдёт к следующей (следующему условию). Образец данных (условие) следующей ветки — `Ordering::Greater`, который *соответствует* `Ordering::Greater`! Указание этой ветки будет выполнено и выведет `Too big!` на экран. Выражение `match` заканчивается после первого успешного совпадения, поэтому оно не будет далее производить сравнения, в нашем случае с последней веткой.

Однако рукопись в приложении 2-4 всё ещё не собирается. Давайте попробуем:

<!--
The error numbers in this output should be that of the code **WITHOUT** the
anchor or snip comments
-->

```console
{{#include ../listings/ch02-guessing-game-tutorial/listing-02-04/output.txt}}
```

Суть ошибки заключается в наличии *несовпадающих видов данных*. У Ржавчины строгий постоянный перечень видов данных. Однако в нем также есть рычаг вывода видов данных. Когда мы написали `let mut guess = String::new()`, Ржавчина смогла сделать вывод, что `guess` должна быть видом данных `String` и не заставила нас указывать вид данных. С другой стороны, `secret_number` — это числовой вид данных. Несколько видов данных чисел в Ржавчине могут иметь значение от 1 до 100: `i32`, 32-битное число; `u32`, беззнаковое 32-битное число; `i64`, 64-битное число, и так далее. Если переменной не присвоен/определён вид данных, Ржавчина по умолчанию использует `i32`, который будет видом данных `secret_number`, если вы не добавите сведения о виде данных где-то ещё, чтобы заставить Ржавчину вывести другой числовой вид данных. Причина ошибки заключается в том, что Ржавчина не может сравнить строку и числовой вид данных.

В конечном итоге необходимо преобразовать переменную вида данных `String`, считываемую программой в качестве входных данных, в существующий числовой вид данных, чтобы иметь возможность числового сравнения с загаданным числом. Для этого добавьте в тело функции `main` следующую строку:

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/src/main.rs:here}}
```

Вот эта строка:

```rust,ignore
let guess: u32 = guess.trim().parse().expect("Please type a number!");
```

Мы создаём переменную с именем `guess`. Но подождите, разве в программе уже нет переменной с этим именем `guess`? Так и есть, но Ржавчина позволяет нам затенять предыдущее значение <code>guess</code> новым. <em>Затенение</em> позволяет нам повторно использовать имя переменной `guess`, чтобы избежать создания двух единственных переменных, таких как `guess_str` и `guess`, например. Мы рассмотрим это более подробно в главе 3, а пока знайте, что эта функция часто используется, когда необходимо преобразовать значение из одного вида данных в другой.

Мы связываем эту новую переменную с выражением `guess.trim().parse()`. Переменная `guess` в этом выражении относится к исходной переменной `guess`, которая содержала входные данные в виде данных строки. Способ `trim` в образце `String` удалит любые пробельные знаки в начале и конце строки (в том числе переходы на новую строку) для того, чтобы мы могли преобразовать строку в числовой вид данных `u32`, который содержит только числовые данные без знака. Пользователь должен нажать <span class="keystroke">enter</span>, чтобы использовать `read_line` и ввести свою догадку, при этом в строку добавится знак перехода на новую строку. Например, если пользователь набирает <span class="keystroke">5</span> и нажимает <span class="keystroke">enter</span>, `guess` будет выглядеть так: `5\n`. Знак `\n` означает "новая строка". (В Windows нажатие <span class="keystroke">enter</span> сопровождается возвратом каретки и новой строкой, `\r\n`). Способ `trim` убирает `\n` или `\r\n`, оставляя только `5`.

Способ [`parse` (только для строк)]<!-- ignore --> преобразует строку в другой вид данных. Здесь мы используем его для преобразования строки в число. Нам нужно сообщить Ржавчине точный числовой вид данных, который мы хотим получить, используя `let guess: u32`. Двоеточие ( `:` ) после `guess` говорит Ржавчине, что мы определяем вид данных переменной. В Ржавчине есть несколько встроенных числовых видов данных; `u32`, показанный здесь, представляет собой 32-битное целое число без знака. Это хороший выбор по умолчанию для небольшого положительного числа. Вы узнаете о других числовых видах данных в главе 3.

Кроме того, изложение <code>u32</code> в этом примере программы и сравнение с <code>secret_number</code> означает, что Ржавчина сделает вывод, что <code>secret_number</code> должен быть <code>u32</code>. Итак, теперь сравнение будет между двумя значениями одного вида данных!

Способ `parse` будет работать только со знаками, которые могут быть преобразованы в числа, и поэтому легко может вызвать ошибки. Если, например, строка содержит знаки `A👍%`, преобразовать её в число невозможно. Так как способ `parse` может потерпеть неудачу, он возвращает вид данных `Result` — так же как и способ `read_line` (обсуждалось ранее в разделе <a data-md-type="raw_html" href="#handling-potential-failure-with-result">«Обработка возможной ошибки с помощью способа `Result`»</a>). Мы будем точно так же обрабатывать данный <code>Result</code>, вновь используя способ `expect`. Если `parse` вернёт исход `Result` `Err`, так как не смог создать число из строки, вызов `expect` со сбоем завершит игру и отобразит переданное ему сообщение. Если `parse` сможет успешно преобразовать строку в число, он вернёт исход `Result` `Ok`, а `expect` вернёт число, полученное из значения `Ok`.

Давайте запустим программу теперь:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
cargo run
  76
-->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
```

Хорошо! Несмотря на то, что были добавлены пробелы в строке ввода, программа всё равно поняла, что пользователь имел в виду число 76. Запустите программу несколько раз, чтобы проверить разное поведение при различных случаях ввода: задайте число правильно, задайте слишком большое число и задайте слишком маленькое число.

Сейчас у нас работает большая часть игры, но пользователь может сделать только одну догадку. Давайте изменим это, добавив круговорот!

## Возможность нескольких догадок с помощью круговоротов

Ключевое слово `loop` создаёт бесконечный круговорот. Мы добавляем круговорот, чтобы дать пользователям больше возможностей угадать число:

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-04-looping/src/main.rs:here}}
```

Как видите, мы переместили всё, начиная с подсказки ввода догадки, в круговорот. Не забудьте добавить ещё по четыре пробела на отступы строк внутри круговорота и запустите программу снова. Теперь программа будет бесконечно запрашивать ещё одну догадку, что в действительности создаёт новую неполадку. Похоже, пользователь не сможет выйти из игры!

Пользователь может прервать выполнение программы с помощью сочетания клавиш <span class="keystroke">ctrl+c</span>. Но есть и другой способ спастись от этого ненасытного монстра, о котором говорилось при обсуждении `parse` в [«Сравнение догадки с тайным числом»](#comparing-the-guess-to-the-secret-number): если пользователь введёт нечисловой ответ, программа завершится со сбоем. Мы можем воспользоваться этим, чтобы позволить пользователю выйти из игры, как показано здесь:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

Ввод `quit` приведёт к выходу из игры, но, как вы заметите, так же будет и при любом другом нечисловом вводе. Однако это, мягко говоря, не разумно. Мы хотим, чтобы игра самостоятельно остановилась, когда будет угадано правильное число.

### Выход после правильной догадки

Давайте запрограммируем игру на выход при выигрыше пользователя, добавив приказчик `break`:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-05-quitting/src/main.rs:here}}
```

Добавление строки `break` после `You win!` заставляет программу выйти из круговорота, когда пользователь правильно угадает тайное число. Выход из круговорота также означает выход из программы, так как круговорот является последней частью `main`.

### Обработка недопустимого ввода

Чтобы улучшить поведение игры, вместо возникновения сбоя и принудительного завершения программы, когда пользователь вводит не число, давайте заставим игру пренебрегать этим обстоятельством, позволяя пользователю продолжить угадывание. Для этого необходимо изменить строку, в которой `guess` преобразуется из `String` в `u32`, как показано в приложении 2-5.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-05/src/main.rs:here}}
```

<span class="caption">Приложение 2-5. Пренебрежение нечисловой догадкой и запрос новой догадки вместо завершения программы</span>

Мы заменяем вызов `expect` на выражение `match`, чтобы перейти от получения сбоя завершения при возникновении ошибки к  её обработке. Помните, что `parse` возвращает вид данных `Result`, а `Result` — это перечисление, которое имеет исходы `Ok` и `Err`. Здесь мы используем выражение `match`, как и в случае с итогом `Ordering` способа `cmp`.

Если `parse` успешно преобразует строку в число, он вернёт значение `Ok`, содержащее полученное число. Это значение `Ok` будет соответствовать образцу данных первой ветки, а выражение `match` просто вернёт значение `num`, которое `parse` произвёл и поместил внутрь значения `Ok`. Это число окажется в нужной нам переменной `guess`, которую мы создали.

Если способ `parse` *не способен* превратить строку в число, он вернёт значение `Err`, которое содержит более подробные сведения об ошибке. Значение `Err` не совпадает с образцом `Ok(num)` в первой ветке `match`, но совпадает с образцом `Err(_)` второй ветки. Подчёркивание `_` является всеохватывающим выражением. В этой ветке мы говорим, что хотим обработать совпадение всех значений `Err`, независимо от того, какие сведения (значение) находится внутри. Поэтому программа выполнит рукопись второй ветки, приказчик `continue`, который сообщает программе перейти к следующему повторению круговорота `loop` и запросить ещё одну догадку. В этом случае программа правильно пренебрегает всеми ошибками, с которыми <code>parse</code> может столкнуться!

Всё в программе теперь должно работать как положено. Давайте попробуем:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 4.45s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
```

Потрясающе! С помощью одной маленькой последней правки мы закончим игру в угадывание. Напомним, что программа все ещё выводит тайное число. Это хорошо подходило для проверки, но это портит игру. Давайте удалим `println!`, который выводит тайное число. В Приложении 2-6 показан окончательный исход рукописи.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-06/src/main.rs}}
```

<span class="caption">Приложение 2-6: Полная рукопись игры</span>

На данное мгновение вы успешно создали игру в загадки. Поздравляем!

## Заключение

Это дело — отличный способ познакомить вас со многими новыми подходами Ржавчины: `let`, `match`, функции, использование внешних ящиков и многое другое. В следующих нескольких главах вы изучите эти подходы более подробно. Глава 3 охватывает понятия, которые есть в большинстве языков программирования, такие как переменные, виды данных и функции, и показывает, как использовать их в Ржавчине. В главе 4 рассматривается владение — особенность, которая отличает Ржавчину от других языков. В главе 5 обсуждаются стопки и правила написания способов, а в главе 6 объясняется, как работают перечисления.


[в пособии встроенной библиотеки]: ../std/prelude/index.html
["Переменные и изменчивость".]: ch03-01-variables-and-mutability.html#variables-and-mutability
[Главе 3]: ch03-04-comments.html
[`std::io::Stdin`]: ../std/io/struct.Stdin.html
[`read_line`]: ../std/io/struct.Stdin.html#method.read_line
[*перечисление*]: ch06-00-enums.html
[способ `expect`]: ../std/result/enum.Result.html#method.expect
[главе 9]: ch09-02-recoverable-errors-with-result.html
[смысловое управление исполнениями]: http://semver.org
[Crates.io]: https://crates.io/
[Cargo]: https://doc.rust-lang.org/cargo/
[его внутреннее устройство]: https://doc.rust-lang.org/cargo/reference/publishing.html
[`match`]: ch06-02-match.html
[`parse` строк]: ../std/primitive.str.html#method.parse