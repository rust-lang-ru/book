## Сущности: определение общего поведения

*Сущность* сообщает сборщику Ржавчина о возможности, которой обладает определённый  данных и которой он может поделиться с другими видами данных. Можно использовать сущности, чтобы определять общее поведение абстрактным способом. Мы можем использовать *ограничение сущности* (trait bounds) чтобы указать, что общим видом данных может быть любой вид, который имеет определённое поведение.

> Примечание: Сущности похожи на возможность часто называемую *внешней оболочкими* в других языках программирования, хотя и с некоторыми отличиями.

### Определение сущности

Поведение вида данных определяется теми способами, которые мы можем вызвать у данного вида данных. Различные виды данных разделяют одинаковое поведение, если мы можем вызвать одни и те же способы у этих видов данных. Определение сущностей - это способ объединять ярлыки способов вместе для того, чтобы описать общее поведение, необходимое для достижения определённой цели.

Например, пусть есть несколько стопок, которые имеют различный вид данных и различный размер писания: стопки `NewsArticle`, которая содержит новость, выведенную в каком-то месте мира; стопки `Tweet`, которая содержит 280 знаковую строку твита и мета-данные, обозначающие является ли твит новым или ответом на другой твит.

Мы хотим создать ящик библиотеки медиа-агрегатора `aggregator`, которая может отображать сводку данных сохранённых в образцах стопок `NewsArticle` или `Tweet`. Чтобы этого достичь, нам необходимо иметь возможность для каждой стопки получить короткую сводку на основе имеющихся данных, и для этого мы запросим сводку вызвав способ `summarize`. Приложение 10-12 показывает определение сущности `Summary`, который выражает это поведение.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-12/src/lib.rs}}
```

<span class="caption">Приложение 10-12: Определение сущности <code>Summary</code>, который содержит поведение предоставленное способом <code>summarize</code></span>

Здесь мы объявляем сущность с использованием ключевого слова `trait`, а затем его название, которым в нашем случае является `Summary`. Также мы объявляем ящик как `pub` что позволяет ящикам, зависящим от нашего ящика, тоже использовать наш ящик, что мы увидим в последующих примерах. Внутри узорчатых скобок объявляются ярлыки способов, которые описывают поведения видов данных, выполняющих данную сущность, в данном случае поведение определяется только одной ярлыком способа `fn summarize(&self) -> String`.

После ярлыков способа, вместо предоставления выполнения в узорчатых в скобках, мы используем точку с запятой. Каждый вид, выполняющий данную сущность, должен предоставить своё собственное поведение для данного способа. Сборщик обеспечит, что любой вид данных содержащий сущность `Summary`, будет также иметь и способ `summarize` объявленный с точно такой же ярлыком.

Сущность может иметь несколько способов в описании его тела: ярлыки способов перечисляются по одной на каждой строке и должны закачиваться знаком <code>;</code>.

### Использование сущности у вида

Теперь, после того как мы определили желаемое поведение используя сущность `Summary`, можно использовать его у видов данных в нашем медиа-агрегаторе. Приложение 10-13 показывает использование сущности `Summary` у стопки `NewsArticle`, которая использует для создания сводки в способе `summarize` заголовок, составителя и место обнародования статьи. Для стопки `Tweet` мы определяем использование `summarize` используя имя пользователя и следующий за ним полный писание твита, полагая что содержание твита уже ограничено 280 знаками.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-13/src/lib.rs:here}}
```

<span class="caption">Приложение 10-13: Использование сущности <code>Summary</code> для стопок <code>NewsArticle</code> и <code>Tweet</code></span>

Использование сущности у вида данных подобно выполнению обычных способов. Разница в том что после `impl` мы ставим имя сущности, который мы хотим использовать, затем используем ключевое слово `for`, а затем указываем имя вида данных, для которого мы хотим сделать использование сущности. Внутри раздела `impl` мы помещаем ярлык способа объявленную в сущности. Вместо добавления точки с запятой в конце, после каждой ярлыки используются узорчатые скобки и тело способа заполняется определенным поведением, которое мы хотим получить у способов сущности для определенного вида данных.

Теперь когда библиотека выполнила сущность `Summary` для `NewsArticle` и `Tweet`, программисты использующие ящик могут вызывать способы сущности у образцов видов данных `NewsArticle` и `Tweet` точно так же как если бы это были обычные способы. Единственное отличие состоит в том, что программист должен ввести сущность в область видимости точно так же как и виды данных. Здесь пример того как двоичный ящик может использовать наш `aggregator`:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-01-calling-trait-method/src/main.rs}}
```

Данная рукопись выведет: `1 new tweet: horse_ebooks: of course, as you probably already know, people`.

Другие ящики, которые зависят от `aggregator`, тоже могу включить сущность `Summary` в область видимости для использования `Summary` в их собственных видах данных. Одно ограничение, на которое следует обратить внимание, заключается в том, что мы можем использовать сущность для вида данных только в том случае, если хотя бы один из сущностей вида данных является местным для нашего ящика. Например, мы можем использовать обычную библиотечную сущность `Display` на собственном виде данных `Tweet` как часть возможности нашего ящика `aggregator` потому что вид данных `Tweet` является местным для ящика `aggregator`. Также мы можем использовать `Summary` для `Vec<T>` в нашем ящике `aggregator`, потому что сущность `Summary` является местным для нашего ящика `aggregator`.

Но мы не можем использовать внешние сущности для внешних видов данных. Например, мы не можем использовать сущность `Display` для `Vec<T>` внутри нашего ящика `aggregator`, потому что `Display` и `Vec<T>` оба определены во встроенной библиотеке а не местно в нашем ящике `aggregator`. Это ограничение является частью свойства называемого *согласованность* (coherence), а ещё точнее *сиротское правило* (orphan rule), которое называется так потому что не представлен родительский вид данных. Это правило заверяет, что рукопись других людей не может сломать вашу рукопись и наоборот. Без этого правила два ящика могли бы использовать одну сущность для одинакового вида данных и Ржавчина не сможет понять, каким исполнением нужно пользоваться.

### Выполнение поведения по умолчанию

Иногда полезно иметь поведение по умолчанию для некоторых или всех способов в сущности вместо того, чтобы требовать выполнения всех способов в каждом виде данных, выполняющим данную сущность. Затем, когда мы выполняем сущность для определённого вида данных, можно сохранить или переопределить поведение каждого способа по умолчанию уже внутри видов данных.

В примере 10-14 показано, как указать строку по умолчанию для способа `summarize` из сущности `Summary` вместо определения только ярлыки способа, как мы сделали в примере 10-12.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-14/src/lib.rs:here}}
```

<span class="caption">Приложение 10-14: Определение сущности <code>Summary</code> с использованием способа <code>summarize</code> по умолчанию</span>

Для использования выполнения по умолчанию при создании сводки у образцов `NewsArticle` вместо определения пользовательского выполнения, мы указываем пустой раздел`impl` с `impl Summary for NewsArticle {}`.

Хотя мы больше не определяем способ `summarize` непосредственно в `NewsArticle`, мы предоставили выполнение по умолчанию и указали, что `NewsArticle` использует сущность `Summary`. В итоге мы всё ещё можем вызвать способ `summarize` у образца данных `NewsArticle`, например так:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-02-calling-default-impl/src/main.rs:here}}
```

Эта рукопись выводит `New article available! (Read more...)` .

Создание выполнения по умолчанию не требует от нас изменений чего-либо в выполнении `Summary` для `Tweet` в приложении 10-13. Причина заключается в том, что правила написания для переопределения выполнения по умолчанию является таким же, как правила написания для выполнения способа сущности, который не имеет выполнения по умолчанию.

Выполнения по умолчанию могут вызывать другие способы в том же сущности, даже если эти другие способы не имеют выполнения по умолчанию. Таким образом, сущность может предоставить много полезной возможности и только требует от разработчиков  указывать небольшую его часть. Например, мы могли бы определить сущность `Summary` имеющий способ `summarize_author`, выполнение которого требуется, а затем определить способ `summarize` который имеет выполнение по умолчанию, которая внутри вызывает способ `summarize_author`:

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/lib.rs:here}}
```

Чтобы использовать такую исполнение сущности `Summary`, нужно только определить способ `summarize_author`, при выполнения сущности для вида данных:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/lib.rs:impl}}
```

После того, как мы определим `summarize_author`, можно вызвать `summarize` для образцов стопки `Tweet` и выполнение по умолчанию способа `summarize` будет вызывать определение `summarize_author` которое мы уже предоставили. Так как мы выполнили способ `summarize_author` сущности `Summary`, то сущность даёт нам поведение способа `summarize` без необходимости писать рукопись.

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/main.rs:here}}
```

Эта рукопись выводит `1 new tweet: (Read more from @horse_ebooks...)` .

Обратите внимание, что невозможно вызвать выполнение по умолчанию из переопределённой выполнения того же способа.

### Сущности как свойства

Теперь, когда вы знаете, как определять и использовать сущности, можно изучить, как использовать сущности, чтобы определить функции, которые принимают много различных видов данных. Мы будем использовать сущность `Summary`,  выполненный для видов данных `NewsArticle` и `Tweet` в приложении 10-13, чтобы определить функцию `notify`, которая вызывает способ `summarize` для его свойства `item`, который имеет некоторый вид данных, выполняющий сущность `Summary`. Для этого мы используем правила написания `impl Trait` примерно так:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-04-traits-as-parameters/src/lib.rs:here}}
```

Вместо определенного вида данных у свойства `item` указывается ключевое слово `impl` и имя сущности. Это свойство принимает любой вид данных, который использует указанную сущность. В теле `notify` мы можем вызывать любые способы у образца данных `item` , которые приходят с сущностью `Summary`, такие как способ `summarize`. Мы можем вызвать `notify` и передать в него любой образец данных `NewsArticle` или `Tweet`. Рукопись, которая вызывает данную функцию с любым другим видом данных, таким как `String` или `i32`, не будет собираться, потому что эти виды данных не используют сущность `Summary`.

<!-- Old headings. Do not remove or links may break. -->

<a id="fixing-the-largest-function-with-trait-bounds"></a>

#### Правила написания ограничения сущности

Соглано правил написания `impl Trait` работает для простых случаев, но на самом деле является связанным сахаром для более длинной вида данных, которая называется *ограничением сущности* (trait bound); это выглядит так:

```rust,ignore
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```

Эта более длинная разновидность равнозначна примеру в предыдущем разделе, но она более многословна. Мы помещаем объявление свойства обобщённого вида данных с ограничением сущности после двоеточия внутри угловых скобок.

Соглано правил написания `impl Trait` удобен и делает рукопись более сжатым в простых случаях, в то время как более полные правила написания с ограничением сущности в других случаях может выразить большую сложность. Например, у нас может быть два свойства, которые используют сущность  `Summary`. Использование правил написания  `impl Trait` выглядит так:

```rust,ignore
pub fn notify(item1: &impl Summary, item2: &impl Summary) {
```

Использовать `impl Trait` удобнее если мы хотим разрешить функции иметь разные виды данных для `item1` и `item2` (но оба вида данных должны использовать `Summary`). Если же мы хотим заставить оба свойства иметь один и тот же вид данных, то мы должны использовать ограничение сущности так:

```rust,ignore
pub fn notify<T: Summary>(item1: &T, item2: &T) {
```

Обобщённый вид данных `T` указан для видов свойств `item1` и `item2` и ограничивает функцию так, что определенные значения видов данных переданные переменными для `item1` и `item2` должны быть одинаковыми.

#### Задание нескольких границ сущностей с помощью правил написания `+`

Также можно указать более одного ограничения сущности. Допустим, мы хотели бы чтобы `notify` использовал как разметку вывода так и  `summarize` для свойства `item`: <br>тогда мы указываем что в `notify` свойство `item` должно использовать обе сущности `Display` и `Summary`. Мы можем сделать это используя правила написания `+`:

```rust,ignore
pub fn notify(item: &(impl Summary + Display)) {
```

Соглано правил написания `+` также допустим с ограничениями сущности для обобщённых видов данных:

```rust,ignore
pub fn notify<T: Summary + Display>(item: &T) {
```

При наличии двух ограничений сущности, тело способа `notify` может вызывать `summarize` и использовать `{}` для разметки `item` при его выводе.

#### Более ясные границы сущности с помощью `where`

Использование слишком большого количества ограничений сущности имеет свои недостатки. Каждый обобщённый вид данных имеет свои границы сущности, поэтому функции с несколькими свойствами обобщённого вида данных могут содержать много сведений об ограничениях между названием функции и списком её свойств затрудняющих чтение ярлыки. По этой причине в Ржавчине есть иной правила написания для определения ограничений сущности внутри предложения `where` после ярлыков функции. Поэтому вместо того, чтобы писать так:

```rust,ignore
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
```

можно использовать `where` таким образом:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-07-where-clause/src/lib.rs:here}}
```

Ярлык этой функции менее загромождена: название функции, список свойств, и возвращаемый вид данных находятся рядом, а ярлык не содержит в себе множество ограничений сущности.

### Возврат значений вида данных выполняющего определённый сущность

Также можно использовать правила написания `impl Trait` в возвращаемое положение, чтобы вернуть значение некоторого вида данных выполняющего сущность, как показано здесь:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-05-returning-impl-trait/src/lib.rs:here}}
```

Используя `impl Summary` для возвращаемого вида данных, мы указываем, что функция `returns_summarizable` возвращает некоторый вид данных, который использует сущность `Summary` без обозначения определенного вида данных. В этом случае `returns_summarizable` возвращает `Tweet`, но рукопись, вызывающая эту функцию, этого не знает.

Возможность возвращать вид данных, который определяется только выполняемым им признаком, особенно полезна в среде замыканий и повторителей, которые мы рассмотрим в Главе 13. Замыкания и повторители создают виды данных, которые знает только сборщик или виды данных, которые очень долго указывать. Правила написания `impl Trait` позволяют кратко указать, что функция возвращает некоторый вид данных, который использует сущность `Iterator` без необходимости писать очень длинный вид данных.

Однако, `impl Trait` возможно использовать, если возвращаете только один вид данных. Например, данная рукопись, которая возвращает значения или вида данных `NewsArticle` или вида данных `Tweet`, но в качестве возвращаемого вида данных объявляет `impl Summary` , не будет работать:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-06-impl-trait-returns-one-type/src/lib.rs:here}}
```

Возврат либо `NewsArticle` либо `Tweet` не допускается из-за ограничений того, как выполнен `impl Trait` согласно правил написания в сборщике. Мы рассмотрим, как написать функцию с таким поведением в разделе ["Использование предметов сущностей, которые разрешены для значений или разных видов данных"]<!--  --> Главы 17.

### Использование ограничений сущности для условного выполнения способов

Используя ограничение сущности с разделом `impl`, который использует свойства обобщённого вида данных, можно использовать способы условно, для тех видов данных, которые используют указанную сущность. Например, вид данных `Pair<T>`  в приложении 10-15 всегда использует функцию  `new` для возврата нового образца данных `Pair<T>` (вспомните раздел [“Определение способов”]<!-- ignore --> Главы 5 где `Self` является псевдонимом вида данных для вида раздела `impl`, который в данном случае является `Pair<T>`). Но в следующем разделе `impl` вид данных `Pair<T>` использует способ  `cmp_display` только если его внутренний вид данных `T` использует сущность `PartialOrd` (позволяющий сравнивать) *и* сущность `Display` (позволяющий выводить на вывод).

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-15/src/lib.rs}}
```

<span class="caption">Приложение 10-15: Условная использование способов у обобщённых видов данных в зависимости от ограничений сущности</span>

Мы также можем условно использовать сущность для любого вида данных, который использует другой сущность. Выполнения сущности для любого вида данных, который удовлетворяет ограничениям сущности, называются *общими исполнениями* и широко используются во встроенной библиотеке Ржавчины. Например, обычная библиотека использует сущность `ToString` для любого вида данных, который использует сущность `Display`. Раздел`impl` во встроенной библиотеке выглядит примерно так:

```rust,ignore
impl<T: Display> ToString for T {
    // --snip--
}
```

Поскольку обычная библиотека имеет эту общую выполнение, то можно вызвать способ `to_string` определённый сущностью `ToString` для любого вида данных, который использует сущность `Display`. Например, мы можем превратить целые числа в их соответствующие `String` значения, потому что целые числа используют сущность `Display`:

```rust
let s = 3.to_string();
```

Общие выполнения приведены в пособии к сущности в разделе "Implementors".

Сущности и ограничения сущностей позволяют писать рукопись, которая использует свойства обобщённого вида данных для уменьшения повторения рукописи, а также указывая сборщику, что мы хотим обобщённый вид данных, чтобы иметь определённое поведение.  Затем сборщик может использовать сведения про ограничения сущности, чтобы проверить, что все определенные виды данных, используемые с нашей рукописью, обеспечивают правильное поведение.  В изменяемых строго определенных языках мы получили бы ошибку во время выполнения, если бы вызвали способ для вида данных, который не использует вид данных определяемый способом. Но Ржавчина перемещает эти ошибки на время сборки, поэтому мы вынуждены исправить сбои, прежде чем наша рукопись начнёт работать. Кроме того, мы не должны писать рукопись, которая проверяет своё поведение во время выполнения, потому что это уже проверено во время сборки. Это повышает производительность без необходимости отказываться от гибкости обобщённых видов данных.


["Использование предметов сущностей, которые разрешены для значений или разных видов данных"]: ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
[“Определение способов”]: ch05-03-method-syntax.html#defining-methods