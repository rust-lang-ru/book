## Сущности: определение общего поведения

*Сущность* сообщает сборщику Ржавчины о возможности, которой обладает определённый  данных и которой он может поделиться с другими видами данных. Можно использовать сущности, чтобы определять общее поведение абстрактным способом. Мы можем использовать *ограничение сущности* (trait bounds) чтобы указать, что общим видом данных может быть любой вид, который имеет определённое поведение.

> Примечание: Сущности похожи на возможность и способы, часто называемые *внешней оболочкими* в других языках программирования, хотя и с некоторыми отличиями.

### Определение сущности

Поведение вида данных определяется теми способами, которые мы можем применить к данному виду данных. Различные виды данных имеют одинаковое поведение, если мы можем использовать одни и те же способы у этих видов данных. Определение сущностей - это способ объединять изложение способов вместе для того, чтобы определить общее поведение, необходимое для достижения определённой цели.

Например, пусть есть несколько стопок, которые имеют различный вид данных и различный размер строк рукописи: стопка `NewsArticle`, которая содержит новостную статью, размещенную в определенном месте; стопка `SocialPost`, которая может содержит 280 знаковую строку вместе с мета-данными, обозначающими является ли эта новостная статья вновь обнародованной или ответом на другую статью, ранее выложенную.

Мы хотим создать дополнение библиотеки медиа-агрегатора `aggregator`, которая может отображать сводки данных сохранённых в образцах стопок `NewsArticle` или `SocialPost`.Для этого нам нужна сводка из каждого вида данных, и мы запросим эту сводку, вызвав способ `summarize`. В приложении 10-12 показано определение сущности `Summary`, которая выражает это поведение.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-12/src/lib.rs}}
```

<span class="caption">Приложение 10-12: Определение сущности <code>Summary</code>, которая содержит поведение предоставленное способом <code>summarize</code></span>

Здесь мы объявляем сущность с использованием ключевого слова `trait`, а затем его название, которым в нашем случае является `Summary`. Также мы объявляем дополнение как `pub` что позволяет другим дополнениям, использующим наше собственное дополнение, тоже могли использовать эту сущность, что мы увидим в последующих примерах. Внутри узорчатых скобок объявляются описание способа, которые описывают поведения видов данных, использующих эту сущность, в данном случае поведение определяется только описанием способа `fn summarize(&self) -> String`.

После описания способа, вместо изложения в узорчатых в скобках, мы указываем точку с запятой. Каждый вид данных, использующий данную сущность, должен предоставить своё собственное пользовательское поведение для тела данного способа. Сборщик заверяет, что любой вид данных, использующий сущность `Summary`, будет также иметь и способ `summarize` объявленный с точно таким же описанием.

Сущность может иметь несколько способов в описании её тела: описание способов перечисляются по одному на каждой строке и должны закачиваться знаком <code>;</code>.

### Использование сущности у вида данных

Теперь, после того как мы изложили нужным нам способы, используя сущность `Summary`, можно использовать его у видов данных в нашем медиа-агрегаторе. Приложение 10-13 показывает использование сущности `Summary` у стопки `NewsArticle`, которая использует заголовок, автора и местоположение для создания возвращаемого значения `summarize`. Для стопки `SocialPost`, мы определяем использование `summarize` как имя пользователя, за которым следует все содержимое новостной статьи, предполагая, что содержимое новостной статьи уже ограничено 280 символами.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-13/src/lib.rs:here}}
```

<span class="caption">Приложение 10-13: Использование сущности <code>Summary</code> для стопок <code>NewsArticle</code> и <code>SocialPost</code></span>

Использование сущности у видов данных подобно использованию обычных способов. Разница в том, что после `impl` мы ставим имя сущности, которую мы хотим использовать, затем используем ключевое слово `for`, а затем указываем имя вида данных, для которого мы хотим использовать сущность. Внутри раздела `impl` мы указываем описание способов, которые определены в определении сущности. Вместо добавления точки с запятой в конце после каждой сущности, мы используем узорчатые скобки и заполняем тело способа определенными действиями, которые мы хотим получить у способов сущности для определенного вида данных.

Теперь когда библиотека использовала сущность `Summary` для `NewsArticle` и `SocialPost`, разработчики, использующие дополнение, могут использовать способы сущности у стопок `NewsArticle` и `SocialPost` точно так же, как если бы это были обычные способы. Единственное отличие состоит в том, что разработчик ПО должен ввести сущность в область видимости точно так же, как и виды данных. Здесь пример того как исполняемое дополнение может использовать наш `aggregator` библиотечное дополнение:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-01-calling-trait-method/src/main.rs}}
```

Данная рукопись выведет: `1 new socialpost: horse_ebooks: of course, as you probably already know, people`.

Другие дополнения, которые зависят от `aggregator`, тоже могут ввести сущность `Summary` в область видимости для использования `Summary` в своих собственных видах данных. Одно есть ограничение, на которое следует обратить внимание, заключается в том, что мы можем использовать сущность для вида данных только в том случае, только если сущность или вид данных, или оба являются объявленными (своими) для нашего дополнения. Например, мы можем использовать встроенную библиотечную сущность `Display` на собственном виде данных - стопке `SocialPost` как часть возможности нашего дополнения `aggregator`, так как стопка `SocialPost` является своей для дополнения `aggregator`. Также мы можем использовать сущность `Summary` для `Vec<T>` в нашем дополнении `aggregator`, потому что сущность `Summary` является своей для нашего дополнения `aggregator`.

Но мы не можем использовать внешние сущности для внешних видов данных. Например, мы не можем использовать сущность `Display` для `Vec<T>` внутри нашего дополнения `aggregator`, потому что `Display` и `Vec<T>` оба определены во встроенной библиотеке и не являются своими в нашем дополнении `aggregator`. Мы также можем использовать `Summary` для `Vec<T>` в нашем дополнении `aggregator`, потому что сущность `Summary` является своей для нашего дополнения `aggregator`.

Это ограничение является частью переменные, называемого *согласованность* (coherence), а ещё точнее *сиротское правило* (orphan rule), которое называется так потому, что не представлен родительский вид данных. Это правило заверяет, что рукопись других людей не может сломать вашу и наоборот. Без этого правила два дополнения могли бы использовать одну сущность для одинакового вида данных, и Ржавчина не смогла бы понять, каким именно исполнением нужно пользоваться.

### Выполнение поведения по умолчанию

Иногда полезно иметь поведение по умолчанию для некоторых или всех способов в сущности вместо того, чтобы требовать выполнения всех способов для каждого вида данных, использующим данную сущность. Затем, когда мы используем сущность для определённого вида данных, можно сохранить или переопределить поведение каждого способа по умолчанию уже внутри видов данных.

В примере 10-14 показано, как указать строку по умолчанию для способа `summarize` из сущности `Summary` вместо того, чтобы определить только описание способа, как мы сделали в примере 10-12.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-14/src/lib.rs:here}}
```

<span class="caption">Приложение 10-14: Определение сущности <code>Summary</code> с использованием способа <code>summarize</code> по умолчанию</span>

Для использования выполнения по умолчанию при сложения итогов у образцов `NewsArticle` вместо определения пользовательского выполнения, мы указываем пустой раздел`impl` с `impl Summary for NewsArticle {}`.

Хотя мы больше не определяем способ `summarize` непосредственно в `NewsArticle`, мы предоставили выполнение по умолчанию и указали, что `NewsArticle` использует сущность `Summary`. В итоге мы всё ещё можем вызвать способ `summarize` у образца данных `NewsArticle`, например так:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-02-calling-default-impl/src/main.rs:here}}
```

Эта рукопись выводит `New article available! (Read more...)` .

Создание выполнения по умолчанию не требует от нас изменений чего-либо в использовании `Summary` для `SocialPost` в приложении 10-13. Причина заключается в том, что правила написания для переопределения выполнения по умолчанию является такими же, как правила написания для выполнения способа сущности, который не имеет выполнения по умолчанию.

Выполнения по умолчанию могут вызывать другие способы в той же сущности, даже если эти другие способы не имеют выполнения по умолчанию. Таким образом, сущность может предоставить много полезных возможностей и требовать от разработчиков  указывать небольшую её часть. Например, мы могли бы определить сущность `Summary` имеющую способ `summarize_author`, использование которого требуется, а затем определить способ `summarize`, который имеет выполнение по умолчанию, который внутри вызывает способ `summarize_author`:

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/lib.rs:here}}
```

Чтобы использовать такое исполнение сущности `Summary`, нужно только определить способ `summarize_author`, когда мы используем сущность для вида данных:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/lib.rs:impl}}
```

После того, как мы определим `summarize_author`, можно вызвать `summarize` для образцов стопки `SocialPost` и выполнение по умолчанию способа `summarize` будет вызывать определение `summarize_author`, которое мы уже предоставили. Так как мы изложили способ `summarize_author` сущности `Summary`, то сущность предоставит нам поведение способа `summarize` без необходимости дополнительного написания строк рукописи.

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/main.rs:here}}
```

Эта рукопись выводит `1 new socialpost: (Read more from @horse_ebooks...)` .

Обратите внимание, что невозможно использовать выполнение по умолчанию из переопределённой сущности того же способа.

### Сущности как переменные

Теперь, когда вы знаете, как определять и использовать сущности, мы можем изучить, как использовать сущности, чтобы определить способы (функции), которые принимают много различных видов данных. Мы будем использовать сущность `Summary`, изложенную для видов данных `NewsArticle` и `SocialPost` в приложении 10-13, чтобы определить способ `notify`, который вызывает способ `summarize` для его переменные `item`, который имеет некоторый вид данных, использующий сущность `Summary`. Для этого мы используем правила написания `impl Trait` примерно так:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-04-traits-as-parameters/src/lib.rs:here}}
```

Вместо определенного вида данных для `item`, указывается ключевое слово `impl` и имя сущности. Это переменная принимает любой вид данных, который использует указанную сущность. В теле способа `notify` мы можем вызывать любые способы у образца данных `item` , которые приходят с сущностью `Summary`. Такие как способ `summarize`. Мы можем вызвать `notify` и передать в него любой образец данных - в том числе стопки `NewsArticle` или `SocialPost`. Рукопись, которая вызывает данную способ (функцию) с любым другим видом данных, таким как `String` или `i32`, не будет собираться, потому что эти виды данных не используют сущность `Summary`.

<!-- Old headings. Do not remove or links may break. -->

<a id="fixing-the-наибольшее-function-with-trait-bounds"></a>

#### Правила написания ограничения сущности

Согласно правил написания, `impl Trait` применим для простых случаев, но на самом деле является упрощением для более длинного изложения, который называется *привязка к сущности* (trait bound). Это выглядит так:

```rust,ignore
pub fn notify<T: Summary>(предмет: &T) {
    println!("Breaking news! {}", item.summarize());
}
```

Эта более развёрнутая разновидность равнозначна примеру в предыдущем разделе, но она более многословна. Мы указываем при объявлении обобщённый вид данных с ограничением сущности после двоеточия внутри угловых скобок.

Согласно правил написания, `impl Trait` удобен и делает рукопись более краткой в простых случаях, в то время как общие правила написания, привязанный к сущности в других случаях может иметь большую сложность. Например, у нас может быть две переменных, которые используют сущность  `Summary`. Использование правил написания  `impl Trait` выглядит так:

```rust,ignore
pub fn notify(предмет1: &impl Summary, item2: &impl Summary) {
```

Использовать `impl Trait` удобнее, если мы хотим разрешить способы (функции) иметь разные виды данных для переменных `item1` и `item2` (но оба вида данных должны использовать `Summary`). Если же мы хотим заставить обе переменных иметь один и тот же вид данных, то мы должны использовать привязку сущности так:

```rust,ignore
pub fn notify<T: Summary>(предмет1: &T, item2: &T) {
```

Обобщённый вид данных `T` указан для видов переменных `item1` и `item2` и ограничивает способ (функцию) так, что определенные значения видов данных, переданные в качестве значения для переменных `item1` и `item2` должны быть одинаковыми.

#### Задание нескольких границ сущностей с помощью правил написания `+`

Также можно указать более одной привязки сущности. Допустим, мы хотим, чтобы способ `notify` использовал как разметку вывода, а также `summarize` для переменных `item`: <br>тогда мы указываем, что в `notify` переменная `item` должна использовать обе сущности `Display` и `Summary`. Мы можем сделать это используя правила написания `+`:

```rust,ignore
pub fn notify(предмет: &(impl Summary + Display)) {
```

Согласно правил написания, `+` также допустим с привязкой сущности для обобщённых видов данных:

```rust,ignore
pub fn notify<T: Summary + Display>(предмет: &T) {
```

При наличии двух ограничений сущности, тело способа `notify` может вызывать `summarize` и использовать `{}` для разметки `item` при его выводе.

#### Более ясные границы сущности с помощью `where`

Использование слишком большого количества ограничений сущности имеет свои недостатки. Каждый обобщённый вид данных имеет свои границы сущности, поэтому способы (функции) с несколькими переменными обобщённого вида данных могут содержать много сведений об ограничениях между названием способы (функции) и списком её переменных, затрудняющих чтение изложения. По этой причине в Ржавчине есть иные правила написания для определения привязок сущности внутри предложения `where` после изложения способы (функции). Поэтому вместо того, чтобы писать так:

```rust,ignore
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
```

можно использовать `where` таким образом:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-07-where-clause/src/lib.rs:here}}
```

Описание этого способа (функции) менее краткое: название способы (функции), список переменных, и возвращаемый вид данных находятся рядом, а описание не содержит в себе множество привязок к сущности.

### Возврат значений вида данных, использующих определённые сущности

Также можно использовать правила написания `impl Trait` в положении возврата, чтобы вернуть значение некоторого вида данных, использующего сущность, как показано здесь:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-05-returning-impl-trait/src/lib.rs:here}}
```

Используя `impl Summary` для возвращаемого вида данных, мы указываем, что способ (функция) `returns_summarizable` возвращает некоторый вид данных, который использует сущность `Summary` без обозначения определенного вида данных. В этом случае `returns_summarizable` возвращает `SocialPost`, но рукопись, вызывающая эту способ (функцию), этого не знает.

Возможность возвращать вид данных, который определяется только используемым им признаком, особенно полезна в среде замыканий и повторителей, которые мы рассмотрим в Главе 13. Замыкания и повторители создают виды данных, которые знает только сборщик или виды данных, которые очень долго указывать. Правила написания `impl Trait` позволяют кратко указать, что способ (функция) возвращает некоторый вид данных, который использует сущность `Iterator` без необходимости писать очень длинный вид данных.

Однако, `impl Trait` возможно использовать, если вы возвращаете только один вид данных. Например, данная рукопись, которая возвращает значения вида данных `NewsArticle` или вида данных `SocialPost`, но в качестве возвращаемого вида данных объявляет `impl Summary` , не будет работать:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-06-impl-trait-returns-one-type/src/lib.rs:here}}
```

Возврат `NewsArticle` либо `SocialPost` не допускается из-за ограничений, связанных с тем как выполнен `impl Trait` в сборщике согласно правил написания. Мы рассмотрим, как написать способ (функцию) с таким поведением в разделе ["Использование предметов сущностей, которые разрешены для значений или разных видов данных"]<!--  --> Главы 18.

### Использование привязки к сущности для условного выполнения способов

Используя привязку к сущности с разделом `impl`, который использует переменные обобщённого вида данных, можно использовать способы условно, для тех видов данных, которые используют указанную сущность. Например, вид данных `Pair<T>`  в приложении 10-15 всегда использует способ (функцию)  `new` для возврата нового образца данных `Pair<T>` (вспомните раздел [“Определение способов”]<!-- ignore --> Главы 5, где `Self` является ярлыком вида данных для вида раздела `impl`, который в данном случае является `Pair<T>` ). Но в следующем разделе `impl` вид данных `Pair<T>` использует способ  `cmp_display` только если его внутренний обобщённый вид данных `T` использует сущность `PartialOrd` , которая позволяет сравнивать *и* сущность `Display` (позволяющая производить вывод на экран).

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-15/src/lib.rs}}
```

<span class="caption">Приложение 10-15: Условное использование способов у обобщённых видов данных в зависимости от привязки к сущности</span>

Мы также можем условно использовать сущность для любого вида данных, который использует другую сущность. Использование сущности для любого вида данных, который удовлетворяет привязкой к сущности, называются *общими исполнениями* *(blanket implementations)* и широко используются во встроенной библиотеке Ржавчины. Например, встроенная библиотека использует сущность `ToString` для любого вида данных, который использует сущность `Display`. Раздел `impl` во встроенной библиотеке выглядит примерно так:

```rust,ignore
impl<T: Display> ToString for T {
    // --snip--
}
```

Поскольку встроенная библиотека имеет это общее исполнение, то можно вызвать способ `to_string`, определённый сущностью `ToString` для любого вида данных, который использует сущность `Display`. Например, мы можем превратить целые числа в их значения в виде, соответствующие `String`, потому что целые числа используют сущность `Display`:

```rust
let s = 3.to_string();
```

Общие использования приведены в пособии к сущности в разделе "Исполнители" ("Implementors").

Сущности и привязки сущностей позволяют писать рукопись, которая использует переменные обобщённого вида данных `<T>` для уменьшения самой рукописи и исключения повторов, а также указывая сборщику, что мы хотим чтобы обобщённый вид данных имел определённое поведение.  Затем сборщик может использовать сведения про привязки к сущности, чтобы проверить, что все определенные виды данных, используемые в нашей рукописи, будут использовать правильное поведение. В изменяемых строго определенных языках, мы получили бы ошибку во время выполнения, если бы вызвали способ для вида данных, который не использует вид данных определяемый способом. Но Ржавчина сообщает нам эти ошибки во время сборки, поэтому мы вынуждены исправить их, прежде чем наша рукопись будет собрана и запущена. Кроме того, мы не должны писать рукопись, которая проверяет своё поведение во время выполнения, потому что это уже проверено во время сборки. Это повышает производительность без необходимости отказываться от возможностей применения обобщённых видов данных.


["Использование предметов сущностей, которые разрешены для значений или разных видов данных"]: ch18-02-trait-objects.html#Использование-сущность-предметов-допускающих-значения-разных-видов-данных
[“Определение способов”]: ch05-03-method-syntax.html#Определение-способов