## Futures и Async правила написания

Ключевые элементы несогласованного программирования в Ржавчине — это _futures_ и ключевые слова Ржавчина `async` и `await`.

_future_ — это значение, которое может быть не готово сейчас, но станет готовым в какой-то момент в будущем. (Этот же взгляд встречается во многих языках, иногда
под другими названиями, такими как _task_ или _promise_.) Ржавчина предоставляет сущность `Future` в качестве строительного блока, чтобы различные несогласованные действия могли быть воплощены с
различными видами данных, но с общей внешней оболочкой. В Ржавчина фьючерсы — это
виды данных, которые воплощают сущность `Future`. Каждая фьючерсная способ (функция) содержит свои собственные сведения
о достигнутом успехе и о том, что означает «готово».

Вы можете применить ключевое слово `async` к блокам и функциям, чтобы указать, что их
можно прерывать и возобновлять. Внутри несогласованного раздела или несогласованной способы (функции) вы можете
использовать ключевое слово `await`, чтобы _await фьючерсной способы (функции)_ (то есть ждать, пока она станет
готовой). Любая точка, где вы ожидаете future внутри несогласованного раздела или способы (функции), является
потенциальным местом для остановки и возобновления этого несогласованного раздела или способы (функции).
Процесс проверки future на предмет доступности его значения называется
_опросом_.

Некоторые другие языки, такие как C# и JavaScript, также используют ключевые слова `async` и `await`
для несогласованного программирования. Если вы знакомы с этими языками, вы можете
заметить некоторые существенные различия в том, как Ржавчина выполняет действия, включая то, как он
обрабатывает правила написания. На это есть веская причина, как мы увидим!

При написании несогласованного Ржавчина мы используем ключевые слова `async` и `await` большую часть времени. Ржавчина собирает их в равноценная рукопись с помощью сущности `Future`, так же как он собирает циклы `for` в равноценную рукопись с помощью сущности `Iterator`. Поскольку
Ржавчина предоставляет сущность `Future`, вы также можете воплотить ее для своих
собственных видов данных, когда вам это нужно. Многие из функций, которые мы увидим в этой
главе, возвращают виды данных с собственными исполнениями `Future`. Мы вернемся к
определению сущности в конце главы и более подробно рассмотрим, как она работает, но этого достаточно, чтобы двигаться вперед.

Все это может показаться немного абстрактным, поэтому давайте напишем нашу первую несогласованную программу: небольшой
веб-скребок. Мы передадим два URL-адреса из приказной строки, вытащим оба
одновременно и вернем итог того, который из них завершится первым. В этом
примере будет довольно много новых правил написания, но не волнуйтесь — мы объясним
все, что вам нужно знать, по ходу дела.

## Наша первая несогласованная приложение

Чтобы сосредоточить внимание в этой главе на изучении несогласованности, а не на жонглировании частями экосистемы, мы создали дополнение `trpl` (`trpl` — это сокращение от «The Ржавчина
Programming Language»). Он реэкспортирует все виды данных, сущности и способы (функции), которые вам понадобятся, в первую очередь из дополнений 
[`futures`][futures-crate] <!-- ignore --> и [`tokio`][tokio]<!-- ignore -->. 
Контейнер `futures` — это официальное место для опытов с Ржавчиной для несогласованной рукописи, и именно там изначально был разработан
терий `Future`. Tokio — самая широко используемая несогласованная среда выполнения в Ржавчине на сегодняшний день, особенно для веб-приложений. Существуют и другие замечательные среды выполнения, и они могут больше подойти для ваших целей. Мы используем дополнение `tokio`
под капотом для `trpl`, потому что он хорошо проверен и широко используется.

В некоторых случаях `trpl` также переименовывает или оборачивает исходные API, чтобы вы
сосредоточились на подробностях, относящихся к этой главе. Если вы хотите понять, что делает дополнение, мы советуем вам ознакомиться с его [исходной рукописью][crate-source]<!-- ignore -->. Вы сможете увидеть, из какого дополнения приходит каждый реэкспорт, и мы оставили подробные примечания, объясняющие, что делает дополнение.

Создайте новый исполняемый проект с именем `здравствуй-async` и добавьте дополнение `trpl` в качестве зависимости:

```console
$ cargo new hello-async
$ cd hello-async
$ cargo add trpl
```

Теперь мы можем использовать различные части, предоставляемые `trpl`, чтобы написать нашу первую несогласованную
программу. Мы создадим небольшое средство приказной строки, которое извлекает две веб-страницы,
извлекает элемент `<title>` из каждой и выводит заголовок любой
страницы, которая первой завершает весь этот этап.

### Определение способы (функции) page_title

Давайте начнем с написания способы (функции), которая принимает URL-адрес одной страницы в качестве свойства, делает запрос к нему и возвращает текст элемента заголовка (см. приложение 17-1).

<Listing number="17-1" file-name="src/main.rs" caption="Определение несогласованной способы (функции) для получения элемента заголовка со страницы HTML">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-01/src/main.rs:all}}
```

</Listing>

Сначала мы определяем способ (функцию) с именем `page_title` и помечаем ее
ключевым словом `async`. Затем мы используем способ (функцию) `trpl::get` для извлечения любого переданного URL-адреса
и добавляем ключевое слово `await` для ожидания ответа. Чтобы получить текст
ответа, мы вызываем его способ `text` и снова ожидаем его с
ключевым словом `await`. Оба эти шага являются несогласованными. Для способы (функции) `get` мы должны
ждать, пока сервер отправит первую часть своего ответа, которая будет включать HTTP-заголовки, файлы cookie и т. д. и может быть доставлена ​​отдельно от
тела ответа. Особенно если тело очень большое, может потребоваться некоторое время,
чтобы все это пришло. Поскольку нам нужно ждать, пока придет _весь_ ответ, способ `text` также является несогласованным.

Мы должны явно ожидать оба этих фьючерса, потому что фьючерсы в Ржавчине
_ленивы_: они ничего не делают, пока вы не попросите их об этом с помощью ключевого слова `await`.

(На самом деле, Ржавчина покажет предупреждение сборщика, если вы не используете фьючерс.) Это
может напомнить вам обсуждение повторителей в Главе 13 в разделе
[Обработка последовательности элементов с помощью повторителей][iterators-lazy]<!-- ignore -->.
Итераторы ничего не делают, пока вы не вызовете их способ `next` — будь то напрямую или с помощью круговоротов `for` или способов, таких как `map`, которые используют `next` под капотом.
Точно так же фьючерсы ничего не делают, пока вы явно не попросите их об этом. Эта ленивость
позволяет Ржавчина избегать запуска несогласованной рукописи, пока он действительно не понадобится.

> Примечание: это отличается от поведения, которое мы видели в предыдущей главе при
> использовании `thread::spawn` в [Создание нового потока с
> spawn][thread-spawn]<!--ignore-->, где замыкание, которое мы передали другому
> потоку, начинало выполняться немедленно. Это также отличается от того, как многие другие
> языки подходят к несогласованности. Но для Ржавчина важно иметь возможность предоставить
> свои заверения производительности, как и с повторителями.

Получив `response_text`, мы можем преобразовать его в образец вида `Html`
используя `Html::parse`. Вместо необработанной строки у нас теперь есть вид данных, который
можно использовать для работы с HTML как с более богатым устройством видов данных. В частности, мы можем
использовать способ `select_first`, чтобы найти первый образец данного собирателя CSS.
Передав строку `"title"`, мы получим первый элемент `<title>`
в документе, если он есть. Поскольку может не быть ни одного соответствующего элемента,
`select_first` возвращает `Option<ElementRef>`. Наконец, мы используем способ `Option::map`, который позволяет нам работать с элементом в `Option`, если он
есть, и ничего не делать, если его нет. (Мы также могли бы использовать выражение `match`
здесь, но `map` более идиоматично.) В теле способы (функции), которую мы предоставляем
`map`, мы вызываем `inner_html` для `title_element`, чтобы получить его содержимое, которое
является `String`. Когда все сказано и сделано, у нас есть `Option<String>`.

Обратите внимание, что ключевое слово `await` Ржавчина идет _после_ выражения, которое вы ожидаете,
а не перед ним. То есть это _постфиксное_ ключевое слово. Это может отличаться от того, к чему вы привыкли, если вы использовали `async` в других языках, но в Ржавчине это делает
цепочки способов намного более удобными для работы. В итоге мы можем изменить тело `page_title`, чтобы связать вызовы функций `trpl::get` и `text` вместе,
с `await` между ними, как показано в приложении 17-2.

<Listing number="17-2" file-name="src/main.rs" caption="Цепочка с ключевым словом `await`">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-02/src/main.rs:chaining}}
```

</Listing>

Итак, мы успешно написали нашу первую несогласованную способ (функцию)! Прежде чем добавить
некоторая рукопись в `main` для ее вызова, давайте немного поговорим о том, что мы
написали и что это значит.

Когда Ржавчина видит блок, помеченный ключевым словом `async`, он собирает его в
неповторимый безымянный вид данных, который использует сущность `Future`. Когда Ржавчина видит способ (функцию), помеченную `async`, он собирает ее в ненесогласованную способ (функцию),
телом которой является несогласованный блок. Тип возвращаемого значения несогласованной способы (функции) — это разновидность
безымянного вида данных, который сборщик создает для этого несогласованного блока.

Таким образом, написание `async fn` равноценно написанию способы (функции), которая возвращает
_future_ возвращаемого вида. Для сборщика определение способы (функции), такое как
`async fn page_title` в приложении 17-1, равноценно ненесогласованной способы (функции),
определенной следующим образом:

```rust
# extern crate trpl; // required for mdbook test
use std::future::Future;
use trpl::Html;

fn page_title(url: &str) -> impl Future<Output = Option<String>> {
    async move {
        let text = trpl::get(url).await.text().await;
        Html::parse(&text)
            .select_first("title")
            .map(|title| title.inner_html())
    }
}
```

Давайте рассмотрим каждую часть преобразованного исполнения:

- Он использует правила написания `impl Trait`, который мы обсуждали в Главе 10 в разделе
[“Traits as Parameters”][impl-trait]<!-- ignore -->.
- Возвращаемый вид - это `Future` с ассоциированным видом `Output`. Обратите внимание,
что вид `Output` - это `Option<String>`, что совпадает с исходным
видом возвращаемого значения из исполнения `async fn` `page_title`.
- Вся рукопись, вызываемая в теле исходной способы (функции), заключена в
раздел `async move`. Помните, что блоки - это выражения. Весь этот раздел - это
выражение, возвращаемое функцией.
- Этот несогласованный раздел создает значение с видом `Option<String>`, как только что
описано. Это значение соответствует виду `Output` в возвращаемом виде. Это
точно так же, как и другие блоки, которые вы видели.
- Новое тело способы (функции) - это раздел `async move` из-за того, как оно использует
свойство `url`. (Мы поговорим гораздо больше об `async` и `async move` позже в этой главе.)

Теперь мы можем вызвать `page_title` в `main`.

## Определение заголовка отдельной страницы

Для начала мы просто получим заголовок для одной страницы. В приложении 17-3 мы следуем
тому же образцу, который мы использовали в Главе 12 для получения аргументов приказной строки в разделе
[Прием аргументов приказной строки][cli-args]<!-- ignore -->. Затем мы
передаем первый URL `page_title` и ждем итог. Поскольку значение,
созданное future, является `Option<String>`, мы используем выражение `match` для
вывода различных сообщений для учета того, была ли на странице `<title>`.

<Listing number="17-3" file-name="src/main.rs" caption="Вызов способа (функции) `page_title` из `main` с аргументом, предоставленным пользователем">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch17-async-await/listing-17-03/src/main.rs:main}}
```

</Listing>

К сожалению, эта рукопись не собирается. Единственное место, где мы можем использовать ключевое слово `await`, — это несогласованные способы (функции) или блоки, а Ржавчина не позволит нам обозначить
специальную способ (функцию) `main` как `async`.

<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-03
cargo build
copy just the compiler error
-->

```text
ошибка[E0752]: `main` function is not allowed to be `async`
 --> src/main.rs:6:1
  |
6 | async fn main() {
  | ^^^^^^^^^^^^^^^ `main` function is not allowed to be `async`
```

Причина, по которой `main` не может быть помечен как `async`, заключается в том, что несогласованному коду нужна _runtime_:
дополнение Ржавчина, который управляет деталями выполнения несогласованной рукописи.
Способ (функция) `main` приложения может _инициализировать_ runtime, но она не является runtime
_самой_. (Мы увидим больше о том, почему это так, немного позже.) Каждая приложение Ржавчина, которая выполняет несогласованный код, имеет по крайней мере одно место, где она устанавливает runtime и выполняет futures.

Большинство языков, поддерживающих async, объединяют runtime, но Ржавчина этого не делает. Вместо этого
доступно множество различных несогласованных runtime, каждая из которых делает различные
компромиссы, подходящие для целевого варианта использования. Например, высокопроизводительный
веб-сервер с большим количеством ядер ГЛАВНЫЙ ВЫЧИСЛИТЕЛЬ и большим объемом ОЗУ имеет совсем другие
потребности, чем микроконтроллер с одним ядром, небольшим объемом ОЗУ и без
возможности выделения кучи. Ящики, которые предоставляют эти среды выполнения, также часто
поставляют несогласованные исполнения общих функций, таких как файловый или сетевой ввод-вывод.

Здесь и далее в этой главе мы будем использовать способ (функцию) `run` из дополнения `trpl`, которая принимает future в качестве аргумента и запускает его до завершения.
За кулисами вызов `run` устанавливает среду выполнения, которая используется для запуска переданного future. После завершения future `run` возвращает любое значение,
созданное future.

Мы могли бы передать future, возвращенный `page_title`, непосредственно `run`, и после его завершения мы могли бы сопоставить его с полученным `Option<String>`, как мы пытались сделать в приложении 17-3. Однако для большинства примеров в главе
(и большей части несогласованной рукописи в реальном мире) мы будем делать больше, чем просто один
вызов несогласованной способы (функции), поэтому вместо этого мы передадим раздел `async` и явно
ожидаем итог вызова `page_title`, как в приложении 17-4.

<Listing number="17-4" caption="Ожидание несогласованного раздела с `trpl::run`" file-name="src/main.rs">

<!-- should_panic,noplayground because mdbook test does not pass args -->

```rust,should_panic,noplayground
{{#rustdoc_include ../listings/ch17-async-await/listing-17-04/src/main.rs:run}}
```

</Listing>

При запуске этой рукописи мы получаем то поведение, которое изначально ожидали:

<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-04
cargo build # skip all the build noise
cargo run https://www.rust-lang.org
# copy the output here
-->

```console
$ cargo run -- https://www.rust-lang.org
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.05s
     Running `target/debug/async_await 'https://www.rust-lang.org'`
The title for https://www.rust-lang.org was
            Ржавчина Programming Language
```

Уф, наконец-то у нас есть работающий несогласованная рукопись! Но прежде чем мы добавим код для гонки двух сайтов друг с другом, давайте ненадолго вернемся к тому, как работают фьючерсы.

Каждая _точка ожидания_ — то есть каждое место, где код использует ключевое слово `await` — представляет собой место, где управление передается обратно среде выполнения. Чтобы это работало, Ржавчина должен отслеживать состояние, вовлеченное в несогласованный
блок, чтобы среда выполнения могла запустить какую-то другую работу, а затем вернуться, когда она будет готова снова попытаться выполнить первую. Это невидимый конечный автомат,
как если бы вы написали перечисление, подобное этому, для сохранения текущего состояния в каждой точке ожидания:

```rust
{{#rustdoc_include ../listings/ch17-async-await/no-listing-state-machine/src/lib.rs:enum}}
```

Однако написание окда для перехода между каждым состоянием вручную было бы утомительным и
подверженным ошибкам, особенно когда вам позже нужно будет добавить больше функциональности и
больше состояний в рукопись. К счастью, сборщик Ржавчина автоматически создает и
управляет видами данных конечного автомата для несогласованной рукописи.
Обычные правила заимствования и владения вокруг структур данных все еще применяются, и
к счастью, сборщик также обрабатывает их проверку для нас и предоставляет полезные
сообщения об ошибках. Мы рассмотрим некоторые из них позже в этой главе.

В конечном счете, что-то должно выполнить этот конечный автомат, и это что-то
является средой выполнения. (Вот почему вы можете столкнуться со ссылками на _исполнители_
при изучении сред выполнения: исполнитель является частью среды выполнения,
ответственной за выполнение несогласованной рукописи.)

Теперь вы можете понять, почему сборщик не позволил нам сделать `main` несогласованной
функцией в приложении 17-3. Если бы `main` была несогласованной функцией, то что-то еще должно было бы управлять конечным автоматом для любого будущего, возвращаемого `main`, но `main` — это отправная точка для приложения! Вместо этого мы вызвали способ (функцию) `trpl::run`
в `main`, чтобы настроить среду выполнения и запустить будущее, возвращаемое блоком `async`, пока оно не будет выполнено.

> Примечание: некоторые среды выполнения предоставляют макросы, так что вы _можете_ написать несогласованную `main`
> способ (функцию). Эти макросы переписывают `async fn main() { ... }` в обычную `fn
> main`, которая делает то же самое, что мы делали вручную в приложении 17-4: вызывает
> способ (функцию), которая запускает future до завершения так, как это делает `trpl::run`.

Теперь давайте соединим все эти части вместе и посмотрим, как можно написать одновременную рукопись.

### Соревнуемся между нашими двумя URL-адресами

В приложении 17-5 мы вызываем `page_title` с двумя разными URL-адресами, переданными из приказной строки, и устраиваем между ними гонку.

<Listing number="17-5" caption="" file-name="src/main.rs">

<!-- should_panic,noplayground because mdbook does not pass args -->

```rust,should_panic,noplayground
{{#rustdoc_include ../listings/ch17-async-await/listing-17-05/src/main.rs:all}}
```

</Listing>

Мы начинаем с вызова `page_title` для каждого из предоставленных пользователем URL. Мы сохраняем
результирующие фьючерсы как `title_fut_1` и `title_fut_2`. Помните, они пока ничего не делают, потому что фьючерсы ленивые, и мы их еще не ждали. Затем мы
передаем фьючерсы в `trpl::race`, который возвращает значение, указывающее, какой из переданных ему фьючерсов завершится первым.

> Примечание: Под капотом `race` построен на более общей способы (функции) `select`,
> которую вы чаще будете встречать в существующей рукописи Ржавчины. Способ (функция) `select`
> может делать много вещей, которые не может способ (функция) `trpl::race`, но она
> также имеет некоторую дополнительную сложность, которую мы можем пока пропустить.

Любое будущее может законно «выиграть», поэтому нет смысла возвращать
`Result`. Вместо этого `race` возвращает вид, который мы раньше не видели,
`trpl::Either`. Тип `Either` несколько похож на `Result`, поскольку у него
есть два случая. Однако, в отличие от `Result`, в `Either` нет понятия успеха или
неудачи. Вместо этого он использует `Left` и `Right` для обозначения
«один или другой»:

```rust
enum Either<A, B> {
    Left(A),
    Right(B),
}
```

Способ (функция) `race` возвращает `Left` с выводом с первого будущего
аргумента, если он завершается первым, и `Right` с выводом второго будущего аргумента, если он
завершается первым. Это соответствует порядку, в котором аргументы появляются при вызове
способы (функции): первый аргумент находится слева от второго аргумента.

Мы также обновляем `page_title`, чтобы вернуть тот же переданный URL. Таким образом, если
страница, которая возвращается первой, не имеет `<title>`, который мы можем разрешить, мы все равно можем вывести осмысленное сообщение. Имея эту сведения, мы завершаем,
обновив наш вывод `println!`, чтобы указать и то, какой URL завершился первым, и то,
что, если есть, `<title>` для веб-страницы по этому URL.

Теперь вы создали небольшой работающий веб-скрейпер! Выберите пару URL и запустите
средство приказной строки. Вы можете обнаружить, что некоторые сайты постоянно быстрее, чем
другие, в то время как в других случаях более быстрый сайт меняется от запуска к запуску. Что еще
важнее, вы изучили основы работы с будущими событиями, так что теперь мы можем
углубиться в то, что мы можем делать с несогласованностью.

[impl-trait]: ch10-02-traits.html#traits-as-parameters
[iterators-lazy]: ch13-02-iterators.html
[thread-spawn]: ch16-01-threads.html#creating-a-new-thread-with-spawn
[cli-args]: ch12-01-accepting-command-line-arguments.html

<!-- TODO: map source link version to version of Ржавчина? -->

[crate-source]: https://github.com/rust-lang/book/tree/main/packages/trpl
[futures-crate]: https://crates.io/crates/futures
[tokio]: https://tokio.rs
