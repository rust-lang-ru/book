## Создание проверок

Как упоминалось в начале Главы, проверка является сложным пунктом и разные люди используют разную совокупность понятий и устройств. Сообщество Ржавчина думает о проверках с точки зрения двух основных разрядов: *состоящие из разделов проверки* и *встроенные проверки*. Состоящие из разделов проверки это небольшие и более сосредоточенные на проверке одного раздела в отдельности или могут проверяться закрытые внешние оболочки. Встраиваемые проверки являются полностью внешними по отношению к вашей библиотеке и используют рукопись библиотеки так же, как любой другой внешней рукописи, используя только общедоступные внешние оболочки и возможно выполняя проверку сразу нескольких разделов в одной проверке.

Написание обоих видов проверок важно для обеспечения того, чтобы кусочки вашей библиотеки по отдельности и вместе делали то, что вы ожидаете.

### Состоящие из разделов проверки

Целью состоящих из разделов проверок является проверка каждого раздела рукописи, изолированное от остального возможностей, чтобы можно было быстро понять, что работает неправильно или не так как ожидается. Мы разместим состоящие из разделов проверки в папке *src*, в каждый проверяемый файл. Но в Ржавчине принято создавать проверяемый раздел `tests` и рукопись проверки сохранять в файлы с таким же именем, как составляющие, которые предстоит проверять. Также необходимо добавить изложение `cfg(test)` к этому разделу.

#### Раздел проверок и изложение `#[cfg(test)]`

Изложение `#[cfg(test)]` у раздела с проверками указывает Ржавчине собирать и запускать только рукопись проверок, когда выполняется приказ `cargo test`, а не когда запускается `cargo build`. Это уменьшает время сборки, если вы только хотите собрать библиотеку и уменьшить место для итоговых собранных артефактов, потому что проверки не будут включены. Вы увидите что, по причине того, что встроенные проверки помещаются в другую папку им не нужно изложение `#[cfg(test)]`. Тем не менее, так как состоящие из разделов проверки идут в тех же файлах что и основная рукопись, вы будете использовать `#[cfg(test)]` чтобы указать, что они не должны быть включены в собранный итог.

Напомним, что когда мы порождали новое дело `adder` в первом разделе этой Главы, то Cargo создал для нас рукопись ниже:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-01/src/lib.rs}}
```

Эта рукопись является самостоятельно созданным проверочным разделом. Свойство `cfg` предназначен для *настройки* и говорит Ржавчине, что следующий элемент должен быть включён только учитывая определённую возможность настройки. В этом случае возможностью настройки является `test`, который предоставлен в Ржавчине для сборки и запуска текущих проверок. Используя свойство `cfg`, Cargo собирает только проверочную рукопись при постоянном запуске проверок приказом `cargo test`. Это включает в себя любые вспомогательные функции, которые могут быть в этом разделе в дополнение к функциям помеченным `#[test]`.

#### Проверка закрытых функций (private)

Сообщество программистов не имеет однозначного мнения по поводу проверять или нет закрытые функции. В некоторых языках весьма сложно или даже невозможно проверять такие функции. Независимо от того, какой технологии проверки вы придерживаетесь, в Ржавчине закрытые функции можно проверять. Рассмотрим приложение 11-12 с закрытой функцией `internal_adder`.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-12/src/lib.rs}}
```

<span class="caption">Приложение 11-12: Проверка закрытых функций</span>

Обратите внимание, что функция `internal_adder` не помечена как `pub`. Проверки — это просто Ржавчина рукопись, а раздел `tests` — это ещё один раздел. Как мы обсуждали в разделе [“Пути для ссылки на переменную в дереве разделов“]<!--  -->, переменные в дочерних разделах могут использовать переменные из своих родительских разделов. В этом проверке мы помещаем все переменные родительского раздела `test` в область видимости с помощью `use super::*` и затем проверка может вызывать `internal_adder`. Если вы считаете, что закрытые функции не нужно проверять, то Ржавчина не заставит вас это сделать.

### Встраиваемые проверки

В Ржавчине встроенные проверки являются полностью внешними по отношению к вашей библиотеке. Они используют вашу библиотеку так же, как любая другая рукопись, что означает, что они могут вызывать только функции, которые являются частью открытого API библиотеки. Их целью является проверка, много ли частей вашей библиотеки работают вместе правильно. У разделов рукописи правильно работающих самостоятельно, могут возникнуть сбои при встраивани, поэтому проверочное покрытие встроенной рукописи также важно. Для создания встроенных проверок сначала нужна папка *tests* .

#### Папка *tests*

Мы создаём папку *tests* в корневой папке вашего дела, рядом с папкой *src*. Cargo знает, что искать файлы с встроенными проверками нужно в этой папки. После этого мы можем создать столько проверочных файлов, сколько захотим, и Cargo собирает каждый из файлов в отдельный ящик.

Давайте создадим встроенный проверку. Рядом с рукописью из приложения 11-12, который всё ещё в файле *src/lib.rs*, создайте папку *tests*, создайте новый файл с именем *tests/integration_test.rs*. Устройство папок должно выглядеть так:

```text
adder
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    └── integration_test.rs
```

Введите рукопись из приложения 11-13 в файл *tests/integration_test.rs* file:

<span class="filename">Файл: tests/integration_test.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-13/tests/integration_test.rs}}
```

<span class="caption">Приложение 11-13: Встраиваемая проверка функция из ящика <code>adder</code></span>

Каждый файл в папке `tests` представляет собой отдельный ящик, поэтому нам нужно подключить нашу библиотеку в область видимости каждого проверочного ящика. По этой причине мы добавляем `use adder` в верхней части рукописи, что не нужно нам делать в состоящих из разделов проверках.

Нам не нужно вносить примечания в рукопись в *tests/integration_test.rs* с помощью `#[cfg(test)]`. Cargo особым образом обрабатывает папку `tests` и собирает файлы в этом папке только тогда, когда мы запускаем приказ `cargo test`. Запустите `cargo test` сейчас:

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-13/output.txt}}
```

Выходные данные представлены тремя разделами: состоящие из разделов проверки, встроенные проверки и проверки пособия. Обратите внимание, что если какой-нибудь проверка в одной из разделов не пройдёт, последующие разделы выполняться не будут. Например, если состоящий из разделов проверка провалился, не будет выведено итогов встроенных и документационных проверок, потому что эти проверки будут выполняться только в том случае, если все состоящие из разделов проверки завершатся успешно.

Первый раздел для состоящих из разделов проверок такой же, как мы видели: одна строка для каждого состоящего из разделов проверки (один с именем `internal`, который мы добавили в приложении 11-12), а затем сводная строка для состоящих из разделов проверок.

Раздел встроенных проверок начинается со строки `Running tests/integration_test.rs`. Далее идёт строка для каждой проверочной функции в этой встроенной проверке и итоговая строка для итогов встроенной проверки непосредственно перед началом раздела `Doc-tests adder`.

Каждый файл встроенной проверки имеет свой собственный раздел, поэтому, если мы добавим больше файлов в папку *tests*, то здесь будет больше разделов встроенной проверки.

Мы всё ещё можем запустить определённую функцию во встроенных проверках, указав имя проверка функции в качестве переменной в `cargo test`. Чтобы запустить все проверки в определенном файле встроенных проверок, используйте переменная `--test` сопровождаемый именем файла у приказы `cargo test`:

```console
{{#include ../listings/ch11-writing-automated-tests/output-only-05-single-integration/output.txt}}
```

Этот приказ запускает только проверки в файле *tests/integration_test.rs*.

#### Подразделы во встроенных проверках

По мере добавления большего количества встроенных проверок, можно создать более одного файла в папке  *tests*, чтобы легче создавать их; например, вы можете объединять функции проверки по возможности, которую они проверяют. Как упоминалось ранее, каждый файл в папке *tests* собран как отдельный ящик, что полезно для создания отдельных областей видимости, чтобы более точно создавать видимость то, как конечные пользователи будут использовать ваш ящик. Однако это означает, что файлы в папке *tests* ведут себя не так, как файлы в *src*, как вы узнали в Главе 7 относительно того как разделить рукопись на разделы и файлы.

Различное поведение файлов в папке *tests* наиболее заметно, когда у вас есть набор вспомогательных функций, которые будут полезны в нескольких встроенных проверочных файлах. Представим, что вы пытаетесь выполнить действия, описанные в разделе [«Разделение разделов в разные файлы»](ch07-05-separating-modules-into-different-files.html)<!--  --> Главы 7, чтобы извлечь их в общее раздел. Например, вы создали файл *tests/common.rs* и поместили в него функцию `setup`, содержащую некоторую рукопись, которая вы будете вызывать из разных проверочных функций в нескольких проверочных файлах

<span class="filename">Файл: tests/common.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-12-shared-test-code-problem/tests/common.rs}}
```

Когда мы снова запустим проверки, мы увидим новый раздел в итогах проверок для файла *common.rs*, хотя этот файл не содержит никаких проверочных функций, более того, мы даже не вызывали функцию `setup` откуда либо:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-12-shared-test-code-problem/output.txt}}
```

Упоминание файла `common` и появление в итогах выполнения проверок сообщения вида данных `running 0 tests` - это не то, чего мы хотели. Мы только хотели выделить некоторую общую рукопись, которая будет использоваться другими файлами встроенных проверок.

Чтобы раздел `common` больше не появлялся в итогах выполнения проверок, вместо файла *tests/common.rs* мы создадим файл *tests/common/mod.rs*. Содержимое дела теперь выглядит следующим образом:

```text
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    ├── common
    │   └── mod.rs
    └── integration_test.rs
```

Здесь используется более раннее соглашение об именовании файлов, которое Ржавчина также понимает. Мы говорили об этом в разделе [“Иные пути к файлам”] Главы 7. Именование файла таким образом говорит, что Ржавчина не должна рассматривать раздел `common` как файл встроенных проверок. Когда мы перемещаем рукопись функции <code>setup</code> в файл *tests/common/mod.rs* и удаляем файл *tests/common.rs*, дополнительный раздел больше не будет отображаться в итогах проверок. Файлы в подпапках папки <em>tests</em> не собираются как отдельные ящики или не появляются в итогах выполнения проверок.

После того, как мы создали файл *tests/common/mod.rs*, мы можем использовать его в любых файлах встроенных проверок как обычный раздел. Вот пример вызова функции `setup` из проверки `it_adds_two` в файле *tests/integration_test.rs*:

<span class="filename">Файл: tests/integration_test.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-13-fix-shared-test-code-problem/tests/integration_test.rs}}
```

Обратите внимание, что  объявление `mod common;` совпадает с объявлением раздела, которое отображено в приложении 7-21. Затем в проверочной функции мы можем вызвать функцию `common::setup()`.

#### Встраиваемые проверки для двоичных ящиков

Если наше дело  является двоичным ящиком, который содержит только *src/main.rs* и не содержит *src/lib.rs*, мы не сможем создать встроенные проверки в папке *tests* и подключить функции определённые в файле *src/main.rs* в область видимости с помощью указания `use`. Только библиотечные ящики могут предоставлять функции, которые можно использовать в других ящиках; двоичные ящики предназначены только для самостоятельного запуска.

Это одна из причин, почему дела на Ржавчине, которые порождают исполняемые разделы, обычно имеют простой файл *src/main.rs*, который в свою очередь вызывает ход мыслей, который находится в файле *src/lib.rs*. Используя такое устройство, встроенные проверки *могут* проверить библиотечный ящик, используя приказчик `use` для подключения важного возможностей. Если этот важный возможности работает, то и небольшое количество рукописи в файле *src/main.rs* также будет работать, а значит этот небольшой размер рукописи не нуждается в проверке.

## Итоги

Средства проверки языка Ржавчина предоставляют способ задать ожидаемое поведение рукописи, чтобы убедиться, что она всё ещё соответствует вашим ожиданиям даже после внесения изменений. Состоящие из разделов проверки проверяют различные части библиотеки по отдельности и могут проверять закрытые подробности выполнения. Встраиваемые проверки проверяют, что части библиотеки работают правильно сообща. Их используют для проверки рукописи открытой API библиотеки, таким же образом, как его будет использовать внешняя рукопись. Хотя перечень видов данных Ржавчины и правила владения помогают предотвратить некоторые виды ошибок, проверки по-прежнему важны для уменьшения количества разумных ошибок, связанных с поведением вашей рукописи.

Давайте объединим  знания, полученные в этой и предыдущей главах, чтобы поработать над делом!


[“Пути для ссылки на переменную в дереве разделов“]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html
[“Иные пути к файлам”]: ch07-05-separating-modules-into-different-files.html#alternate-file-paths