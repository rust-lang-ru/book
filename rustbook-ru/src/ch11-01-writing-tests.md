## Как писать проверки

Проверки - это функции Ржавчина, которые проверяют, что не проверочная рукопись работает ожидаемым образом. Содержимое проверочных функций обычно выполняет три следующих действия:

1. Установка любых необходимых данных или состояния.
2. Запуск рукописи, которую вы хотите проверить.
3. Утверждение, что итоги являются теми, которые вы ожидаете.

Давайте рассмотрим функции предоставляемые в Ржавчине целенаправленно для написания проверок, которые выполнят все эти действия, включая свойство `test`, несколько макросов и свойство `should_panic`.

### Устройство проверяющей функции<a id="the-anatomy-of-a-test-function"></a>

В простейшем случае в Ржавчине проверка - это функция, определенная свойством `test`. Свойства представляют собой метаданные о отрывках рукописи Ржавчины; один из примеров средство `derive`, который мы использовали со стопками в главе 5. Чтобы превратить функцию в проверяющую функцию добавьте `#[test]`  в строку перед `fn`.  Когда вы запускаете проверки приказом `cargo test`, Ржавчина создаёт двоичное раздел выполняющее функции определенные свойством test и сообщающий о том, успешно или нет прошла каждая проверяющая функция.

Когда мы создаём новое дело библиотеки с помощью Cargo, то в нём самостоятельно порождается проверочный раздел с проверку-функцией для нас. Это раздел даст вам образец данных для написания ваших проверок, так что вам не нужно искать точный вид данных и правила написания проверочных функций каждый раз, когда вы начинаете новое дело. Вы можете добавить столько дополнительных проверочных функций и столько проверочных разделов, сколько захотите!

Мы исследуем некоторые особенности работы проверок, проводя опыты с образцовой проверкой созданным для нас, без существующего проверки любой рукописи. Затем мы напишем некоторые существующие проверки, которые вызывают некоторую написанную рукопись и убедимся в ее правильном поведении. Мы рассмотрим некоторые особенности работы проверок, проведем опыты с образцовой проверкой, прежде чем приступать к действительной проверке любой рукописи. Затем мы напишем несколько существующих проверок, которые вызывают некоторую написанную нами рукопись и проверяют, что ее поведение правильное.

Давайте создадим новый библиотечный дело под названием `adder`, который складывает два числа:

```console
$ cargo new adder --lib
     Created library `adder` project
$ cd adder
```

Содержимое файла *src/lib.rs* вашей библиотеки `adder` должно выглядеть как в приложении 11-1.

<span class="filename">Файл: src/lib.rs</span>

<!-- manual-regeneration
cd listings/ch11-writing-automated-tests
rm -rf listing-11-01
cargo new listing-11-01 --lib --name adder
cd listing-11-01
cargo test
git co output.txt
cd ../../..
-->

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-01/src/lib.rs}}
```

<span class="caption">Приложение 11-1: Проверочный раздел и функция, созданные самостоятельно с помощью <code>cargo new</code></span>

Сейчас давайте пренебрегаем первые две строчки рукописи и сосредоточимся на функции. Обратите внимание на правила написания изложении `#[test]`: это свойство указывает, что это проверочная функция, поэтому запускающая проверка знает, что эту функцию следует рассматривать как проверочную. У нас также могут быть не проверяемые функции в разделе `tests`, которые помогут настроить общие задумки или выполнить общие действия, поэтому нам всегда нужно указывать, какие функции являются проверками.

В теле функции проверки используется макрос `assert_eq!`, чтобы утверждать, что `result`, который содержит итог сложения 2 и 2, равен 4. Это утверждение служит примером вида для обычной проверки. Давайте запустим его, чтобы убедиться, что эта проверка пройдена.

Приказ `cargo test` выполнит все проверки в выбранном деле и сообщит о итогах как в приложении 11-2:

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-01/output.txt}}
```

<span class="caption">Приложение 11-2: Вывод сведений о работе самостоятельно созданных проверок</span>

Cargo собрал и выполнил проверку. Мы видим строку `running 1 test`. Следующая строка показывает имя созданной проверочной функции, называемой  `it_works`, и итог запуска этого проверки равный `ok`. писание `test result: ok.` означает, что все проверки пройдены успешно и часть вывода `1 passed; 0 failed` сообщает общее количество проверок, которые прошли или были ошибочными.

Можно пометить проверка как пренебрегаемый, чтобы он не выполнялся в определенном случае; мы рассмотрим это в разделе [“Пренебрежение некоторых проверок, если их целенаправленно не запрашивать”]<!-- ignore --> позже в этой главе. Поскольку в данный мгновение мы этого не сделали, в сводке показано, что `0 ignored`. Мы также можем передать переменная приказу `cargo test` для запуска только тех проверок, имя которых соответствует строке; это называется *выборкой*, и мы рассмотрим это в разделе [“Запуск подмножества проверок по имени”]<!-- ignore -->. Мы также не фильтровали выполняемые проверки, поэтому в конце сводки показано, что `0 filtered out`.

Исчисление `0 measured` предназначена для проверок производительности. На мгновение написания этой статьи такие проверки доступны только в ночной сборке Ржавчина. Посмотрите [пособие о проверках производительности](https://doc.rust-lang.org/unstable-book/library-features/test.html), чтобы узнать больше.

Следующая часть вывода проверок начинается с `Doc-tests adder` - это сведения о проверках в пособии. У нас пока нет проверок пособия, но Ржавчина может собирать любые примеры рукописи, которые находятся в API пособия. Такая возможность помогает поддерживать пособие и рукопись в согласованном состоянии. Мы поговорим о написании проверок пособия в разделах ["Примечания пособия как проверки"]<!-- ignore --> Главы 14. Пока просто пренебрегаем частью `Doc-tests` вывода.

Давайте начнём настраивать проверка в соответствии с нашими собственными потребностями. Сначала поменяем название нашего проверки `it_works` на `exploration`, вот так:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-01-changing-test-name/src/lib.rs}}
```

Снова выполним приказ `cargo test`. Вывод показывает наименование нашей проверку-функции - `exploration` вместо `it_works`:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-01-changing-test-name/output.txt}}
```

Добавим ещё один проверка, но в этот раз целенаправленно сделаем так, чтобы эта новая проверка не отработала! Проверка терпит неудачу, когда что-то вызывает сбой в проверяемой функции. Каждая проверка запускается в новом потоке и когда главный поток видит, что проверочный поток упал, то помечает проверка как завершившийся со сбоем. Мы говорили о простейшем способе вызвать сбой в главе 9, используя для этого известный макрос `panic!`. Введём рукопись проверку-функции `another`, как в файле *src/lib.rs* из приложения 11-3.

<span class="filename">Файл: src/lib.rs</span>

```rust,panics,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-03/src/lib.rs:here}}
```

<span class="caption">Приложение 11-3: Добавление второго проверки, который завершится ошибкой, потому что мы вызываем <code>panic!</code> макрос</span>

Запустим приказ `cargo test`. Вывод итогов показан в приложении 11-4, который сообщает, что проверка `exploration` пройден, а `another` нет:

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-03/output.txt}}
```

<span class="caption">Приложение 11-4. Итоги проверки, когда один проверка пройдена, а другой нет</span>

Вместо `ok`, строка `test tests::another` сообщает `FAILED`. Два новых раздела появились между отдельными итогами и сводкой: в первом отображается подробная причина каждого сбоя проверки. В данном случае проверка `another` не сработала, потому что `panicked at 'Make this test fail'`, произошло в строке 10 файла *src/lib.rs*. В следующем разделе перечисляют имена всех не пройденных проверок, что удобно, когда есть много проверок и много подробных итогов неудачных проверок. Мы можем использовать имя не пройденной проверки для его дальнейшей отладки; мы больше поговорим о способах запуска проверок в разделе ["Управление хода выполнения проверок"](ch11-02-running-tests.html#controlling-how-tests-are-run)<!-- ignore -->.

Итоговая строка отображается в конце: общий итог нашего проверки `FAILED`. У нас один проверка пройдена и один проверка завершена со сбоем.

Теперь, когда вы увидели, как выглядят итоги проверки при разных задумках, давайте рассмотрим другие макросы полезные в проверках, кроме `panic!`.

### Проверка итогов с помощью макроса `assert!`

Макрос `assert!` доступен из встроенной библиотеки и является удобным, когда вы хотите проверить что некоторое условие в проверке вычисляется в значение `true`. Мы передаём в макрос `assert!` переменная, который вычисляется в разумное значение. Если оно `true`, то ничего не происходит и проверка считается пройденным. Если же значение вычисляется в `false`, то макрос `assert!` вызывает макрос `panic!`, чтобы вызвать сбой проверки. Использование макроса `assert!` помогает проверить, что рукопись исполняется как ожидалось.

В главе 5, приложении 5-15, мы использовали вид данных стопка `Rectangle`(прямоугольник) и способ `can_hold`, который повторён в приложении 11-5. Давайте поместим эту рукопись в файл *src/lib.rs* и напишем несколько проверок для него используя макрос `assert!`.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-05/src/lib.rs:here}}
```

<span class="caption">Приложение 11-5: Использование стопки <code>Rectangle</code> и её способа can_hold из Главы 5</span>

Способ `can_hold` возвращает разумное значение, что означает, что он является наилучшим исходом использования в макросе `assert!`. В приложении 11-6 мы пишем проверка, которая использует способ `can_hold` путём создания образца данных `Rectangle` шириной 8 и высотой 7 и убеждаемся, что он может содержать другой образец данных `Rectangle` имеющий ширину 5 и высоту 1.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-06/src/lib.rs:here}}
```

<span class="caption">Приложение 11-6: Проверка для способа <code>can_hold</code>, который проверяет что больший прямоугольник действительно может содержать меньший</span>

Также, в разделе `tests` обратите внимание на новую добавленную строку `use super::*;`. Раздел `tests` является обычным и подчиняется тем же правилам видимости, которые мы обсуждали в главе 7 ["Пути для ссылки на переменнуюы внутри дерева раздела"]<!--  -->. Так как это раздел `tests` является внутренним, нужно подключить проверяемый рукопись из внешнего раздела в область видимости внутреннего раздела с проверками. Для этого используется вездесущеее подключение, так что все что определено во внешнем разделе становится доступным внутри `tests` раздела.

Мы назвали нашу проверку `larger_can_hold_smaller` и создали два нужных образца данных `Rectangle`. Затем вызвали макрос `assert!` и передали итог вызова `larger.can_hold(&smaller)` в него. Это выражение должно возвращать `true`, поэтому наша проверка должна пройти. Давайте выясним!

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-06/output.txt}}
```

Проверка проходит. Теперь добавим другой проверка, в этот раз мы попытаемся убедиться, что меньший прямоугольник не может содержать больший прямоугольник:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-02-adding-another-rectangle-test/src/lib.rs:here}}
```

Поскольку правильный итог функции `can_hold` в этом случае `false`, то мы должны инвертировать этот итог, прежде чем передадим его в `assert!` макро. Как итог, наша проверка пройдёт, если `can_hold` вернёт `false`:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-02-adding-another-rectangle-test/output.txt}}
```

Два проверки работают. Теперь проверим, как отреагируют проверки, если мы добавим ошибку в рукопись. Давайте изменим использование способа `can_hold` заменив одно из разумных выражений знак сравнения с "больше чем" на противоположный "меньше чем" при сравнении ширины:

```rust,not_desired_behavior,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-03-introducing-a-bug/src/lib.rs:here}}
```

Запуск проверок теперь производит следующее:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-03-introducing-a-bug/output.txt}}
```

Наши проверки нашли ошибку! Так как в проверке `larger.width` равно 8 и `smaller.width` равно 5 сравнение ширины в способе `can_hold` возвращает итог `false`, поскольку число 8 не меньше чем 5.

### Проверка на равенство с помощью макросов `assert_eq!` и `assert_ne!`

Общим способом проверки возможности является использование сравнения итога проверяемого рукописью и ожидаемого значения, чтобы убедиться в их равенстве. Для этого можно использовать макрос `assert!`, передавая ему выражение с использованием приказчика `==`. Важно также знать, что кроме этого обычная библиотека предлагает пару макросов `assert_eq!` и `assert_ne!`, чтобы сделать проверка более удобной. Эти макросы сравнивают две переменной на равенство или неравенство соответственно. Макросы также выводят два значения входных свойств, если проверка завершилась ошибкой, что позволяет легче увидеть *почему* проверка ошибочна. Противоположно этому, макрос `assert!` может только отобразить, что он вычислил значение `false` для выражения `==`, но не значения, которые привели к итогу `false`.

В приложении 11-7, мы напишем функцию `add_two`, которая прибавляет к входному свойству `2` и возвращает значение. Затем, проверим эту функцию с помощью макроса `assert_eq!`:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-07/src/lib.rs}}
```

<span class="caption">Приложение 11-7: Проверка функции <code>add_two</code> с помощью макроса <code>assert_eq!</code></span>

Проверим, что проверки проходят!

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-07/output.txt}}
```

Первая переменная, которую мы передаём в макрос `assert_eq!` число `4` чей итог вызова равен `add_two(2)` . Строка для этой проверки - `test tests::it_adds_two ... ok` , а писание `ok` означает, что наша проверка пройдена!

Давайте введём ошибку в рукопись, чтобы увидеть, как она выглядит, когда проверка, которая использует `assert_eq!` завершается ошибкой. Измените выполнение функции `add_two`, чтобы добавлять `3`:

```rust,not_desired_behavior,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-04-bug-in-add-two/src/lib.rs:here}}
```

Попробуем выполнить данную проверка ещё раз:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-04-bug-in-add-two/output.txt}}
```

Наша проверка нашла ошибку! Проверка `it_adds_two` не выполнился, отображается сообщение `assertion failed: `(left == right)`` и показывает, что `left` было `4`, а `right` было `5`. Это сообщение полезно и помогает начать отладку: это означает `left` переменная `assert_eq!` имел значение `4`, но <code>right</code> переменная для вызова <code>add_two(2)</code> был со значением <code>5</code>.

Обратите внимание, что в некоторых языках (таких как Java) в библиотеках рукописи для проверки принято именовать входные свойства проверочных функций как "ожидаемое" (`expected`) и "действительное" (`actual`). В Ржавчине приняты следующие обозначения `left` и `right` соответственно, а порядок в котором определяются ожидаемое значение и производимое проверяемым рукописью значение не имеют значения. Мы могли бы написать выражение в проверке как `assert_eq!(add_two(2), 4)`, что приведёт к отображаемому сообщению об ошибке `assertion failed: `(left == right)``, слева `left` было бы <code>5</code>, а справа <code>right</code> было бы <code>4</code>.

Макрос `assert_ne!` сработает успешно, если входные свойства не равны друг другу и завершится с ошибкой, если значения равны. Этот макрос наиболее полезен в тех случаях, когда мы не знаем заранее, каким значение *будет*, но знаем точно, каким оно *не может* быть. К примеру, если проверяется функция, которая обязательно изменяет входные данные определённым образом, но способ изменения входного свойства зависит от дня недели, в котором запускаются проверки, что лучший способ проверить правильность работы такой функции - это сравнить и убедиться, что выходное значение функции не должно быть равным входному значению.

В своей работе макросы `assert_eq!` и `assert_ne!` неявным образом используют приказчики `==` и `!=` соответственно. Когда проверка не срабатывает, макросы выводят значения переменных с помощью отладочной разметки и это означает, что значения сравниваемых переменных должны использовать сущности `PartialEq` и `Debug`. Все простые и большая часть видов данных встроенной библиотеки Ржавчина используют эти сущности. Для стопок и перечислений, которые вы используете сами будет необходимо использовать сущность `PartialEq` для сравнения значений на равенство или неравенство. Для вывода отладочных сведений в виде сообщений в строку вывода окне вывода необходимо использовать сущность `Debug`. Так как обе сущности являются выводимыми сущностями, как упоминалось в приложении 5-12 Главы 5, то эти сущности можно использовать добавив изложение `#[derive(PartialEq, Debug)]` к определению стопки или перечисления. Смотрите больше подробностей в Appendix C ["Выводимые сущности"]<!-- ignore --> про эти и другие выводимые сущности.

### Создание сообщений об ошибках

Также можно добавить пользовательское сообщение как дополнительный переменная макросов для выводе в сообщении об ошибке проверки `assert!`, `assert_eq!`, и `assert_ne!`. Любые переменные, указанные после обязательных переменных, далее передаются в макрос `format!` (он обсуждается в разделе ["Сцепление с помощью приказчика `+` или макроса format!"](ch08-02-strings.html#concatenation-with-the--operator-or-the-format-macro)<!-- ignore -->), так что вы можете передать размеченную строку, которая содержит  `{}` для исполнителей и значения, заменяющие эти исполнители. Пользовательские сообщения полезны для пояснения того, что означает утверждение (assertion); когда проверка завершается неудачей, у вас будет лучшее представление о том, в чем неполадка с рукописью.

Например, есть функция, которая приветствует человека по имени и мы хотим проверять эту функцию. Мы хотим чтобы передаваемое ей имя выводилось в окно вывода:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-05-greeter/src/lib.rs}}
```

Требования к этой программе ещё не были согласованы и мы вполне уверены, что писание `Hello` в начале приветствия ещё изменится. Мы решили, что не хотим обновлять проверка при изменении требований, поэтому вместо проверки на точное равенство со значением возвращённым из `greeting`, мы просто будем проверять, что вывод содержит писание из входного свойства.

Давайте внесём ошибку в эту рукопись, изменив `greeting` так, чтобы оно не включало `name` и увидим, как выглядит сбой этого проверки:

```rust,not_desired_behavior,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-06-greeter-with-bug/src/lib.rs:here}}
```

Запуск этого проверки выводит следующее:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-06-greeter-with-bug/output.txt}}
```

Сообщение содержит лишь сведения о том что сравнение не было успешным и в какой строке это произошло. В данном случае, более полезный писание сообщения был бы, если бы также выводилось значение из функции `greeting`. Изменим проверяющую функцию так, чтобы выводились пользовательское сообщение, размеченной строкой с заменителем и действительными данными из рукописи `greeting`:

```rust,ignore
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-07-custom-failure-message/src/lib.rs:here}}
```

После того, как выполним проверка ещё раз мы получим подробное сообщение об ошибке:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-07-custom-failure-message/output.txt}}
```

Мы можем увидеть значение, которое мы на самом деле получили в проверочном выводе, что поможет нам отлаживать произошедшее, а не то, что мы ожидали.

### Проверка с помощью макроса `should_panic`

В дополнение к проверке того, что наша рукопись возвращает правильные, ожидаемые значения, важным также является проверить, что наша рукопись обрабатывает ошибки, которые мы ожидаем. Например, рассмотрим вид данных `Guess` который мы создали в главе 9, приложения 9-10. Другая рукопись, которая использует `Guess` зависит от заверения того, что `Guess` образцы будут содержать значения только от 1 до 100. Мы можем написать проверку, которая заверяет, что попытка создать образец данных `Guess` со значением вне этого ряда вызывает сбой.

Выполняем это с помощью другого свойства проверку-функции `#[should_panic]`. Это свойство сообщает устройству проверки, что проверка проходит, когда способ порождает ошибку. Если ошибка не порождается - проверка считается не пройденным.

Приложение 11-8 показывает проверка, которая проверяет, что условия ошибки `Guess::new` произойдут, когда мы их ожидаем их.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-08/src/lib.rs}}
```

<span class="caption">Приложение 11-8: Проверка того, что условие вызовет макрос <code>panic!</code></span>

Свойство `#[should_panic]` следует после `#[test]` и до объявления проверочной функции. Посмотрим на вывод итога, когда проверка проходит:

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-08/output.txt}}
```

Выглядит хорошо! Теперь давайте внесём ошибку в нашу рукопись, убрав условие о том, что функция `new` будет вызвать сбой если значение больше 100:

```rust,not_desired_behavior,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-08-guess-with-bug/src/lib.rs:here}}
```

Когда мы запустим проверка в приложении 11-8, он потерпит неудачу:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-08-guess-with-bug/output.txt}}
```

Мы получаем мало полезных сведений в этом случае, но когда мы смотрим на проверяющую функцию, мы видим, что она обозначена
как  `#[should_panic]`. Ошибка, которую мы получили во время выполнения означает, что рукопись в проверяющей функции не вызвала сбоя и завершения программы.

Проверки, которые используют `should_panic` могут быть неточными, потому что они только указывают, что рукопись вызвал сбой. Проверка со свойством `should_panic` пройдёт, даже если проверка вызывает сбой по причине, отличной от той, которую мы ожидали. Чтобы сделать проверки с `should_panic` более точными, мы можем добавить необязательный свойство `expected`  для свойства `should_panic`. Такое подробное проведение проверки позволит удостовериться, что сообщение об ошибке содержит предоставленный писание. Например, рассмотрим измененный рукопись для `Guess` в приложении 11-9, где `new` функция вызывает сбой с различными сообщениями в зависимости от того, является ли значение слишком маленьким или слишком большим.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-09/src/lib.rs:here}}
```

<span class="caption">Приложение 11-9: Проверка <code>panic!</code> на наличие в его сообщении указанной подстроки</span>

Эта проверка пройдёт, потому что значение, которое мы поместили для `should_panic` в свойство свойства `expected` является подстрокой сообщения, с которым функция `Guess::new` вызывает сбой. Мы могли бы указать полное, ожидаемое сообщение для сбоя, в этом случае это будет `Guess value must be less than or equal to 100, got 200`. То что вы выберите для указания как ожидаемого свойства у `should_panic` зависит от того, какая часть сообщения о сбое неповторима или динамична, насколько вы хотите, чтобы ваш проверка был точным. В этом случае достаточно подстроки из сообщения сбоя, чтобы обеспечить выполнение рукописи в проверочной функции `else if value > 100` .

Чтобы увидеть, что происходит, когда проверка `should_panic` неуспешно завершается с сообщением `expected`, давайте снова внесём ошибку в нашу рукопись, поменяв местами `if value < 1` и `else if value > 100` разделы:

```rust,ignore,not_desired_behavior
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-09-guess-with-panic-msg-bug/src/lib.rs:here}}
```

На этот раз, когда мы выполним `should_panic` проверка, он потерпит неудачу:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-09-guess-with-panic-msg-bug/output.txt}}
```

Сообщение об ошибке указывает, что эта проверка действительно вызвала сбой, как мы и ожидали, но сообщение о сбое не включено ожидаемую строку `'Guess value must be less than or equal to 100'`. Сообщение о сбое, которое мы получили в этом случае, было `Guess value must be greater than or equal to 1, got 200.` Теперь мы можем начать выяснение, где ошибка!

### Использование `Result<T, E>` в проверках

Пока что мы написали проверки, которые вызывают сбой, когда терпят неудачу. Мы также можем написать проверки которые используют `Result<T, E>`! Вот проверка из приложения 11-1, переписанный с использованием `Result<T, E>` и возвращающий `Err` вместо сбоя:

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-10-result-in-tests/src/lib.rs}}
```

Функция `it_works` теперь имеет возвращаемый вид данных `Result<(), String>`. В теле функции, вместо вызова макроса `assert_eq!`, мы возвращаем `Ok(())` когда проверка успешно выполнен и `Err` со `String` внутри, когда проверка не проходит.

Написание проверок так, чтобы они возвращали `Result<T, E>` позволяет использовать приказчик "вопросительный знак"  в теле проверок, который может быть удобным способом писать проверки, которые должны выполниться не успешно, если какая-либо действие внутри них возвращает исход ошибки `Err`.

Вы не можете использовать изложение `#[should_panic]` в проверках, использующих `Result<T, E>`. Чтобы утверждать, что действие возвращает исход `Err`, *не* используйте приказчик вопросительного знака для значения `Result<T, E>`. Вместо этого используйте `assert!(value.is_err())`.

Теперь, когда вы знаете несколько способов написания проверок, давайте взглянем на то, что происходит при запуске проверок и исследуем разные возможности используемые с приказом `cargo test`.


[“Пренебрежение некоторых проверок, если их целенаправленно не запрашивать”]: ch11-02-running-tests.html#ignoring-some-tests-unless-specifically-requested
[“Запуск подмножества проверок по имени”]: ch11-02-running-tests.html#running-a-subset-of-tests-by-name
["Выводимые сущности"]: appendix-03-derivable-traits.html
["Примечания пособия как проверки"]: ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests
["Пути для ссылки на переменнуюы внутри дерева раздела"]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html