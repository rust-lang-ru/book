## Развитие возможности библиотеки разработкой на основе проверок

Теперь, когда мы извлекли ход мыслей в *src/lib.rs* и оставили разбор переменных приказной строки и обработку ошибок в *src/main.rs*, стало гораздо проще писать проверки для основной возможности нашей рукописи. Мы можем вызывать функции напрямую с различными переменными и проверить возвращаемые значения без необходимости вызова нашего двоичного файла из приказной строки.

В этом разделе в программу `minigrep` мы добавим ход мыслей поиска с использованием этапа разработки через проверку (TDD), которая следует этим шагам:

1. Напишите проверку, которая завершается неудачей, и запустите его, чтобы убедиться, что он не сработал именно по той причине, которую вы ожидаете.
2. Пишите или изменяйте ровно столько рукописи, чтобы успешно выполнился новый проверку.
3. Выполните переработку рукописи, которую вы только что добавили или изменили, и убедитесь, что проверки продолжают проходить.
4. Повторите с шага 1!

Хотя это всего лишь один из многих способов написания программного обеспечения, TDD может помочь в разработке рукописи. Написание проверки перед написанием рукописи, обеспечивающего прохождение проверки, помогает поддерживать высокое покрытие проверками на протяжении всего этапа разработки.

Мы проверим выполнение возможности, которая делает поиск строки запроса в содержимом файла и создание списка строк, соответствующих запросу. Мы добавим эту возможность в функцию под названием `search`.

### Написание проверки с ошибкой

Поскольку они нам больше не нужны, давайте удалим указания с `println!`, которые мы использовали для проверки поведения программы в *src/lib.rs* и *src/main.rs*. Затем в *src/lib.rs* мы добавим раздел `tests` с проверочной функцией, как делали это в [главе 11]<!-- ignore -->. Проверочная функция определяет поведение, которое мы хотим проверить в функции `search`: она должна принимать запрос и писание для поиска, а возвращать только те строки из писания, которые содержат запрос. В приложении 12-15 показана эта проверка, которая пока не собирается.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-15/src/lib.rs:here}}
```

<span class="caption">Приложение 12-15: Создание безуспешного проверки для функции <code>search</code>, которую мы хотим создать</span>

Эта проверка ищет строку `"duct"`. Писание,  в котором мы ищем, состоит из трёх строк, только одна из которых содержит `"duct"` (обратите внимание, что обратная косая черта после открывающей двойной кавычки говорит Ржавчине не помещать знак новой строки в начало содержимого этого строковой записи). Мы проверяем, что значение, возвращаемое функцией `search`, содержит только ожидаемую нами строку.

Мы не можем запустить эту проверка и увидеть сбой, потому что проверка даже не собирается: функции `search` ещё не существует! В соответствии с принципами TDD мы добавим ровно столько рукописи, чтобы проверка собиралась и запускалась, добавив определение функции `search`, которая всегда возвращает пустой вектор, как показано в приложении 12-16. Потом проверка должна собраться и потерпеть неудачу при запуске, потому что пустой вектор не равен вектору, содержащему строку `"safe, fast, productive."`

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-16/src/lib.rs:here}}
```

<span class="caption">Приложение 12-16: Определение функции <code>search</code>, достаточное, чтобы проверка собрался</span>

Заметьте, что в ярлыке `search` нужно явно указать время жизни `'a` для переменной `contents` и возвращаемого значения. Напомним из [Главы 10]<!-- ignore -->, что свойства времени жизни указывают с временем жизни какого переменной связано время жизни возвращаемого значения. В данном случае мы говорим, что возвращаемый вектор должен содержать срезы строк, ссылающиеся на содержимое переменной `contents` (а не переменной `query`).

Другими словами, мы говорим Ржавчине что данные, возвращаемые функцией `search`, будут жить до тех пор, пока живут данные, переданные в функцию `search` через переменную `contents`. Это важно! Чтобы ссылки были действительными, данные, на которые ссылаются *с помощью* срезов тоже должны быть действительными; если сборщик предполагает, что мы делаем строковые срезы переменной `query`, а не переменной `contents`, он неправильно выполнит проверку безопасности.

Если мы забудем изложении времени жизни и попробуем собрать эту функцию, то получим следующую ошибку:

```console
{{#include ../listings/ch12-an-io-project/output-only-02-missing-lifetimes/output.txt}}
```

Ржавчина не может понять, какая из двух переменных нам нужна, поэтому нужно сказать ему об этом. Так как `contents` является той переменной, которая содержит все наше писание,  и мы хотим вернуть части этого писания, которые совпали при поиске, мы понимаем, что `contents` является переменной, которая должна быть связана с возвращаемым значением временем жизни.

Другие языки программирования не требуют от вас связывания в ярлыке переменных с возвращаемыми значениями, но после определённой опытов вам станет проще. Можете сравнить этот пример с разделом [«Проверка ссылок с временами жизни»](ch10-03-lifetime-syntax.html#validating-references-with-lifetimes)<!-- ignore --> Главы 10.

Запустим проверку:

```console
{{#include ../listings/ch12-an-io-project/listing-12-16/output.txt}}
```

Отлично. Наша проверка не сработала, как мы и ожидали. Давайте сделаем так, чтобы она срабатывал!

### Написание рукописи для прохождения проверки

Сейчас наша проверка не проходит, потому что мы всегда возвращаем пустой вектор. Чтобы исправить это и использовать `search`, наша программа должна выполнить следующие шаги:

- Повторение по каждой строке содержимого.
- Проверить, содержит ли данная строка искомую.
- Если это так, добавить её в список значений, которые мы возвращаем.
- Если это не так, ничего не делать.
- Вернуть список итогов.

Давайте проработаем каждый шаг, начиная с перебора строк.

#### Перебор строк с помощью способа `lines`

В Ржавчине есть полезный способ для построчной повторения строк, удобно названный `lines`, как показано в приложении 12-17. Обратите внимание, рукопись пока не собирается.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-17/src/lib.rs:here}}
```

<span class="caption">Приложение 12-17: Повторение по каждой строке из <code>contents</code></span>

Способ `lines` возвращает повторитель . Мы подробно поговорим об повторителях в [Главе 13]<!-- ignore -->, но вспомните, что вы видели этот способ использования повторителя в [Приложении 3-5]<!-- ignore -->, где мы использовали круговорот `for` с повторителем, чтобы выполнить некоторую рукопись для каждой переменной в собрании.

#### Поиск в каждой строке писания запроса

Далее мы проверяем, содержит ли текущая строка нашу искомую строку. К счастью, у строк есть полезный способ `contains`, который именно это и делает! Добавьте вызов способа `contains` в функции `search`, как показано в приложении 12-18. Обратите внимание, что это все ещё не собирается.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-18/src/lib.rs:here}}
```

<span class="caption">Приложение 12-18: Добавление проверки, содержится ли <code>query</code> в строке</span>

На данное мгновение мы наращиваем возможность. Чтобы заставить это собираться, нам нужно вернуть значение из тела функции, как мы указали в ярлыке функции.

#### Сохранение совпавшей строки

Чтобы завершить эту функцию, нам нужен способ сохранить совпадающие строки, которые мы хотим вернуть. Для этого мы можем создать изменяемый вектор перед круговоротом `for` и вызывать способ `push` для сохранения `line` в векторе. После круговорота `for` мы возвращаем вектор, как показано в приложении 12-19.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-19/src/lib.rs:here}}
```

<span class="caption">Приложение 12-19: Сохраняем совпавшие строки, чтобы впоследствии их можно было вернуть</span>

Теперь функция `search` должна возвратить только строки, содержащие `query`, и проверка должна пройти. Запустим её:

```console
{{#include ../listings/ch12-an-io-project/listing-12-19/output.txt}}
```

Наша проверка пройдена, значит она работает!

На этом этапе мы могли бы рассмотреть возможности изменения выполнения функции поиска, сохраняя прохождение проверок и поддерживая имеющуюся возможность. Рукопись в функции поиска не так уж плох, но он не использует некоторые полезные функции повторителей. Вернёмся к этому примеру в [главе 13](ch13-02-iterators.html)<!-- ignore -->, где будем исследовать повторители подробно, и посмотрим как его улучшить.

#### Использование функции `search` в функции `run`

Теперь, когда функция `search` работает и проверена, нужно вызвать `search` из нашей функции `run`. Нам нужно передать значение `config.query` и `contents`, которые `run` считывает из файла, в функцию `search`. Тогда `run` выведет каждую строку, возвращаемую из `search`:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/no-listing-02-using-search-in-run/src/lib.rs:here}}
```

Мы по-прежнему используем круговорот `for` для возврата каждой строки из функции `search` и её выводе.

Теперь вся программа должна работать! Давайте попробуем сначала запустить её со словом «frog», которое должно вернуть только одну строчку из стихотворения Эмили Дикинсон:

```console
{{#include ../listings/ch12-an-io-project/no-listing-02-using-search-in-run/output.txt}}
```

Здорово! Теперь давайте попробуем слово, которое будет соответствовать нескольким строкам, например «body»:

```console
{{#include ../listings/ch12-an-io-project/output-only-03-multiple-matches/output.txt}}
```

И наконец, давайте удостоверимся, что мы не получаем никаких строк, когда ищем слово, отсутствующее в стихотворении, например «monomorphization»:

```console
{{#include ../listings/ch12-an-io-project/output-only-04-no-matches/output.txt}}
```

Отлично! Мы создали собственную простое-исполнение обычного средства и научились тому, как внутренне выстроить приложения. Мы также немного узнали о файловом вводе и выводе, временах жизни, проверке и разборе переменных приказной строки.

Чтобы завершить это дело, мы кратко выполним пару вещей: как работать с переменными окружения и как выводить в обычный поток ошибок, обе из которых полезны при написании программ с окнами ввода/вывода.


[главе 11]: ch11-01-writing-tests.html#the-anatomy-of-a-test-function
[Главы 10]: ch10-03-lifetime-syntax.html
[Приложении 3-5]: ch03-05-control-flow.html#looping-through-a-collection-with-for
[Главе 13]: ch13-02-iterators.html