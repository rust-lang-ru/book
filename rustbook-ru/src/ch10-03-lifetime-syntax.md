## Проверка действительности ссылок при помощи времён жизни<a name="validating-references-with-lifetimes"></a>

Сроки (времена) жизни - ещё один вид обобщений, с которыми мы уже встречались. Если раньше мы использовали обобщения, чтобы убедиться, что вид данных обладает нужным нам поведением, теперь мы будем использовать сроки жизни для того, чтобы быть уверенными, что ссылки действительны как самое меньшее столько времени в этапе исполнения программы, сколько нам требуется.

В разделе ["Ссылки и заимствование"](ch04-02-references-and-borrowing.html#references-and-borrowing) Главы 4, мы кое о чём умолчали: у каждой ссылки в Ржавчине есть своё <em>время жизни</em> — область рукописи, на протяжении которого данная ссылка действительна (valid). В большинстве случаев сроки жизни выводятся неявно — так же, как у видов данных (нам требуется явно объявлять виды данных лишь в тех случаях, когда при самостоятельном выведении вида данных возможны исходы). Точно так же мы должны явно объявлять сроки жизни тех ссылок, для которых времена жизни могут быть определены сборщиком по-разному. Ржавчина требует от нас объявлять взаимосвязи посредством обобщённых свойств сроков жизни, чтобы убедиться в том, что во время исполнения все действующие ссылки будут правильными.

Определение времени жизни — это подход, отсутствующая в большинстве других языков программирования, так что она может показаться незнакомой. Хотя в этой главе мы не будем рассматривать времена жизни во всех подробностях, тем не менее, мы обсудим основные случаи, в которых вы можете столкнуться с правилами написания времени жизни, что позволит вам получше ознакомиться с этой подходом.

### Времена жизни предотвращают появление "повисших" ссылок

Основное предназначение сроков жизни — предотвращать появление так называемых *"повисших ссылок"* (<em>dangling references</em>), из-за которых программа обращается не к тем данным, к которым она собиралась обратиться. Рассмотрим программу из приложения 10-16, имеющую внешнюю и внутреннюю области видимости.

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-16/src/main.rs}}
```

<span class="caption">Приложение 10-16: Попытка использования ссылки, значение которой вышло из области видимости</span>

> Примечание: примеры в приложениях 10-16, 10-17 и 10-23 объявляют переменные без указания их начального значения, поэтому имя переменной существует во внешней области видимости. На первый взгляд может показаться, что это противоречит отсутствию в Ржавчине пустых (null) значений. Однако, если мы попытаемся использовать переменную, прежде чем присвоить ей значение, мы получим ошибку сборки, которая показывает, что Ржавчина действительно не разрешает пустые (null) значения.

Внешняя область видимости объявляет переменную с именем `r` без начального значения, а внутренняя область объявляет переменную с именем `x` с начальным значением `5`. Во внутренней области мы пытаемся установить значение `r` как ссылку на `x`. Затем внутренняя область видимости заканчивается и мы пытаемся вывести значение из `r`. Эта рукопись не будет собрана, потому что значение на которое ссылается <code>r</code> исчезает из области видимости, прежде чем мы попробуем использовать его. Вот сообщение об ошибке:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-16/output.txt}}
```

Переменная `x` «не живёт достаточно долго». Причина в том, что `x` выйдет из области видимости, когда эта внутренняя область закончится в строке 7. Но `r` все ещё является действительной во внешней области видимости; поскольку её охват больше, мы говорим, что она «живёт дольше». Если бы Ржавчина позволил такому рукописи работать, то переменная `r` смогла бы ссылаться на память, которая уже была освобождена (в тот мгновение, когда `x` вышла из внутренней области видимости), и всё что мы попытались бы сделать с `r` работало бы неправильно. Как же Ржавчина определяет, что эта рукопись неправильно? Он использует для этого оценщик заимствований (<em>borrow checker</em>).

### Оценщик заимствований

Сборщик Ржавчины имеет в своём составе *оценщик заимствований*, который сравнивает области видимости для определения, являются ли все заимствования действительными. В приложении 10-17 показан тот же рукопись, что и в приложении 10-16, но с изложениями, показывающими времена жизни переменных.

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-17/src/main.rs}}
```

<span class="caption">Пример 10-17: Изложение времён жизни переменных <code>r</code> и <code>x</code>, с помощью определителей времени жизни <code>'a</code> и <code>'b</code>, соответственно</span>

Здесь мы описали время жизни для `r` с помощью `'a` и время жизни `x` с помощью `'b` . Как видите, время жизни `'b` внутреннего раздела гораздо меньше, чем время жизни `'a` внешнего раздела. Во время сборки Ржавчина сравнивает продолжительность двух времён жизни и видит, что `r` имеет время жизни `'a`, но ссылается на память со временем жизни `'b`. Программа отклоняется, потому что `'b` короче, чем `'a`: предмет ссылки не живёт так же долго, как сама ссылка.

Приложение 10-18 исправляет рукопись, чтобы в ней не было повисшей ссылки, и собирается без ошибок.

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-18/src/main.rs}}
```

<span class="caption">Приложение 10-18: Ссылка правильна, так как данные имеют более продолжительное время жизни, чем ссылка на эти данные</span>

Здесь переменная `x` имеет время жизни `'b`, которое больше, чем время жизни `'a`. Это означает, что переменная `r` может ссылаться на переменную `x` потому что Ржавчина знает, что ссылка в переменной `r` будет всегда действительной до тех пор, пока переменная `x` является существующей.

После того, как мы на примерах рассмотрели времена жизни ссылок и обсудили как Ржавчина их рассматривает, давайте поговорим об обобщённых временах жизни входных свойств и возвращаемых значений функций.

### Обобщённые времена жизни в функциях

Напишем функцию, которая возвращает более длинный из двух срезов строки. Эта функция принимает два среза строки и возвращает один срез строки. После того как мы выполнили функцию `longest`, рукопись в приложении 10-19 должен вывести `The longest string is abcd`.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-19/src/main.rs}}
```

<span class="caption">Приложение 10-19: Функция <code>main</code> вызывает функцию <code>longest</code> для поиска наибольшего из двух срезов строки</span>

Обратите внимание, что мы хотим чтобы функция принимала строковые срезы, которые являются ссылками, а не строки, потому что мы не хотим, чтобы функция `longest` забирала во владение свои свойства. Обратитесь к разделу ["Строковые срезы как свойства"](ch04-03-slices.html#string-slices-as-parameters)<!--  --> Главы 4 для более подробного обсуждения того, почему свойства используемые в приложении 10-19 выбраны именно таким образом.

Если мы попробуем использовать функцию `longest` так, как это показано в приложении 10-20, программа не собирается:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-20/src/main.rs:here}}
```

<span class="caption">Приложение 10-20: Выполнение функции <code>longest</code>, которая возвращает наибольший срез строки, но пока не собирается</span>

Вместо этого мы получим следующую ошибку, говорящую о временах жизни:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-20/output.txt}}
```

Текст ошибки показывает, что возвращаемому виду нужно Обобщённое  свойство времени жизни, потому что Ржавчина не может определить, относится ли возвращаемая ссылка к `x` или к `y`. На самом деле, мы тоже не знаем, потому что раздел`if` в теле функции возвращает ссылку на `x`, а раздел`else` возвращает ссылку на `y`!

Когда мы определяем эту функцию, мы не знаем определенных значений, которые будут в неё передаваться. Поэтому мы не знаем какая из ветвей приказчика `if` или `else` будет выполнена. Мы также не знаем определенных времён жизни ссылок, которые будут переданы в функцию, поэтому мы не можем посмотреть на их области видимости, как мы делали в примерах 10-17 и 10-18, чтобы определить, будет ли возвращаемая нами ссылка правильной во всех случаях. Оценщик заимствований также не может этого определить, потому что он не знает как времена жизни переменных `x` и `y` соотносятся с временем жизни возвращаемого значения. Чтобы исправить эту ошибку, мы добавим Обобщённое свойство времени жизни, который определит отношения между ссылками таким образом, чтобы оценщик заимствований мог провести свой оценку.

### Правила написания изложении времени жизни

Изложения времени жизни не меняют срок, как долго живёт та или иная ссылка. Они скорее описывают, как соотносятся между собой времена жизни нескольких ссылок, не влияя на само время жизни. Точно так же, как функции могут принимать любой вид данных, когда в ярлыке указан свойство обобщённого вида данных, функции могут принимать ссылки с любым временем жизни, указанным с помощью свойства обобщённого времени жизни.

Изложения времени жизни имеют немного необычный правила написания: имена свойств времени жизни должны начинаться с апострофа (`'`), пишутся маленькими буквами, и обычно очень короткие, как и имена обобщённых видов данных. Большинство людей использует имя `'a` в качестве первой изложении времени жизни. Изложения свойств времени жизни следуют после знака `&` и отделяются пробелом от названия ссылочного вида данных.

Приведём несколько примеров: у нас есть ссылка на `i32` без указания времени жизни, ссылка на `i32`, с временем жизни имеющим имя `'a` и изменяемая ссылка на `i32`, которая также имеет время жизни `'a`.

```rust,ignore
&i32        // a reference
&'a i32     // a reference with an explicit lifetime
&'a mut i32 // a mutable reference with an explicit lifetime
```

Одна изложение времени жизни сама по себе не имеет большого значения, поскольку изложении предназначены для того, чтобы уведомить Ржавчина о том, как времена жизни нескольких ссылок соотносятся между собой. Давайте рассмотрим, как изложении времени жизни связаны друг с другом в среде функции `longest`.

### Изложения времени жизни в описании самих функций

Чтобы использовать изложении времени жизни в описании самих функций, нам нужно объявить свойства обобщённого *времени жизни* внутри угловых скобок между именем функции и списком свойств, как мы это делали с свойствами обобщённого *вида данных* .

Мы хотим, чтобы ярлык отражала следующее ограничение: возвращаемая ссылка будет действительна до тех пор, пока действительны оба свойства. Это связь между временами жизни свойств и возвращаемого значения. Мы назовём это время жизни `'a`, а затем добавим его к каждой ссылке, как показано в приложении 10-21.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-21/src/main.rs:here}}
```

<span class="caption">Приложение 10-21: В определении функции <code>longest</code> указано, что все ссылки должны иметь одинаковое время жизни, обозначенное как <code>'a</code></span>

Эта рукопись должна собираться и давать желаемый итог, когда мы вызовем ее в функции `main` приложения 10-19.

Ярлык функции теперь сообщает Ржавчина, что для некоторого времени жизни `'a` функция принимает два свойства, оба из которых являются срезами строк, которые живут не меньше, чем время жизни `'a`. Ярлык функции также сообщает Ржавчина что срез строки, возвращаемый функцией, будет жить как самое меньшее столько, сколько длится время жизни `'a`. В действительности это означает, что время жизни ссылки, возвращаемой функцией `longest`, равно меньшему времени жизни передаваемых в неё ссылок. Мы хотим, чтобы Ржавчина использовал именно такие отношения при оценке этой рукописи.

Помните, когда мы указываем свойства времени жизни в этой ярлыке функции, мы не меняем время жизни каких-либо переданных или возвращённых значений. Скорее, мы указываем, что оценщик заимствований должен отклонять любые значения, которые не соответствуют этим ограничениям. Обратите внимание, что самой функции `longest` не нужно точно знать, как долго будут жить `x` и `y`, достаточно  того, что некоторая область может быть заменена на `'a`, которая будет удовлетворять этой ярлыке.

При определении времён жизни функций, изложении помещаются в ярлык функции, а не в тело функции. Изложения времени жизни становятся частью договора функции, как и виды данных в ярлыке. Наличие ярлыков функций, содержащих договор времени жизни, означает, что оценка которую использует сборщик Ржавчины, может быть проще. Если есть неполадка с тем, как функция определяется или как она вызывается, ошибки сборщика могут указать на часть нашей рукописи и ограничения более точно. Если бы вместо этого сборщик Ржавчины сделал больше предположений о том, какие отношения времён жизни мы хотели получить, сборщик смог бы указать только на использование нашей рукописи за много шагов от источника сбоев.

Когда мы передаём определенные ссылки в функцию `longest`, определенным временем жизни, которое будет заменено на `'a`, является часть области видимости `x`, которая пересекается с областью видимости `y`. Другими словами, обобщённое время жизни `'a` получит определенное время жизни, равное меньшему из времён жизни `x` и `y`. Так как мы определяли возвращаемую ссылку тем же свойством времени жизни `'a`, то возвращённая ссылка также будет действительна на протяжении меньшего из времён жизни `x` и `y`.

Давайте посмотрим, как изложении времени жизни ограничивают функцию `longest` путём передачи в неё ссылок, которые имеют разные определенные времена жизни. Приложение 10-22 является очевидным примером.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-22/src/main.rs:here}}
```

<span class="caption">Приложение 10-22: Использование функции <code>longest</code> со ссылками на значения вида данных <code>String</code>, имеющими разное время жизни</span>

В этом примере переменная `string1` действительна до конца внешней области, `string2` действует до конца внутренней области видимости и `result` ссылается на что-то, что является действительным до конца внутренней области видимости. Запустите эту рукопись, и вы увидите что оценщик заимствований разрешает такую рукопись; он собирает и выведет `The longest string is long string is long`.

Теперь, давайте попробуем пример, который показывает, что время жизни ссылки `result` должно быть меньшим временем жизни одного из двух переменных. Мы переместим объявление переменной `result` за пределы внутренней области видимости, но оставим присвоение значения переменной `result` в области видимости `string2`. Затем мы переместим `println!`, который использует `result` за пределы внутренней области видимости, после того как внутренняя область видимости закончилась. Рукопись в приложении 10-23 не собирается.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-23/src/main.rs:here}}
```

<span class="caption">Приложение 10-23: Попытка использования <code>result</code>, после того как <code>string2</code> вышла из области видимости</span>

При попытке собрать эту рукопись, мы получим такую ошибку:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-23/output.txt}}
```

Эта ошибка говорит о том, что если мы хотим использовать `result` в указании `println!`, переменная `string2` должна бы быть действительной до конца внешней области видимости. Ржавчина знает об этом, потому что мы определяли свойства функции и её возвращаемое значение одинаковым временем жизни `'a`.

Будучи людьми, мы можем посмотреть на эту рукопись и увидеть, что `string1` длиннее, чем `string2` и, следовательно, `result` будет содержать ссылку на `string1`. Поскольку `string1` ещё не вышла из области видимости, ссылка на `string1` будет все ещё действительной в указании `println!`. Однако сборщик не видит, что ссылка в этом случае действительна. Мы сказали Ржавчина, что время жизни ссылки, возвращаемой из функции `longest`, равняется меньшему из времён жизни переданных в неё ссылок. Таким образом, оценщик заимствований запрещает рукопись в приложении 10-23, как возможно имеющую недействительную ссылку.

Попробуйте провести больше опытов с различными значениями и временами жизни ссылок, передаваемых в функцию `longest`, а также с тем, как используется возвращаемое значение  Перед сборкой делайте предположения о том, пройдёт ли Ваша рукопись оценку заимствований, а затем проверяйте, насколько вы были правы.

### Мышление в понятиях времён жизни

В зависимости от того, что делает ваша функция, следует использовать разные способы указания свойств времени жизни. Например, если мы изменим выполнение функции `longest` таким образом, чтобы она всегда возвращала свою первую переменная вместо самого длинного среза строки, то время жизни для свойства `y` можно совсем не указывать. Эта рукопись собирается:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-08-only-one-reference-with-lifetime/src/main.rs:here}}
```

Мы указали свойство времени жизни `'a` для свойства `x` и возвращаемого значения, но не для свойства `y`, поскольку время жизни свойства `y` никак не соотносится с временем жизни свойства `x` или возвращаемого значения.

При возврате ссылки из функции, свойство времени жизни для возвращаемого вида данных должен соответствовать свойству времени жизни одного из переменных. Если возвращаемая ссылка *не* ссылается на одно из свойств, она должна ссылаться на значение, созданное внутри функции. Однако, это приведёт к недействительной ссылке, поскольку значение, на которое она ссылается, выйдет из области видимости в конце функции. Посмотрите на попытку выполнения функции `longest`, которая не собирается:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-09-unrelated-lifetime/src/main.rs:here}}
```

Здесь, несмотря на то, что мы указали свойство времени жизни `'a` для возвращаемого вида данных, выполнение не будет собрана, потому что время жизни возвращаемого значения никак не связано с временем жизни свойств. Получаем сообщение об ошибке:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-09-unrelated-lifetime/output.txt}}
```

Неполадка заключается в том, что `result` выходит за область видимости и очищается в конце функции `longest`. Мы также пытаемся вернуть ссылку на `result` из функции. Мы не можем указать свойства времени жизни, которые могли бы изменить недействительную ссылку, а Ржавчина не позволит нам создать недействительную ссылку. В этом случае лучшим решением будет вернуть владеющий вид данных, а не ссылку: в этом случае вызывающая функция будет нести ответственность за очистку полученного ею значения.

В конечном итоге, правила написания времён жизни выполняют связывание времён жизни различных переменных и возвращаемых значений функций. Описывая времена жизни, мы даём Ржавчина достаточно сведений, чтобы разрешить безопасные действия с памятью и запретить действия, которые могли бы создать недействительные ссылки или иным способом нарушить безопасное управлению памятью.

### Определение времён жизни при объявлении видов данных

До сих пор мы объявляли стопки, которые всегда содержали владеющие виды данных. Стопки могут содержать и ссылки, но при этом необходимо добавить изложение времени жизни для каждой ссылки в определении стопки. Приложение 10-24 описывает вид данных `ImportantExcerpt`, содержащее срез строки:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-24/src/main.rs}}
```

<span class="caption">Приложение 10-25. Стопки, содержащая ссылку, требует изложении времени жизни</span>

У стопки имеется одно поле `part`, хранящее срез строки, который сам по себе является ссылкой. Как и в случае с обобщёнными видами данных, мы объявляем имя обобщённого свойства времени жизни внутри угловых скобок после имени стопки, чтобы иметь возможность использовать его внутри определения стопки. Данное изложение означает, что образец данных `ImportantExcerpt` не может пережить ссылку, которую он содержит в своём поле `part`.

Функция `main` здесь создаёт образец данных стопки `ImportantExcerpt`, который содержит ссылку на первое предложение вида данных `String` принадлежащее переменной `novel`. Данные в `novel` существуют до  создания образца данных `ImportantExcerpt`. Кроме того, `novel` не выходит из области видимости до тех пор, пока `ImportantExcerpt` не выйдет за область видимости, поэтому ссылка в внутри образца данных `ImportantExcerpt`  является действительной.

### Правила неявного выведения времени жизни

Вы изучили, что у каждой ссылки есть время жизни и что нужно указывать свойства времени жизни для функций или стопок, которые используют ссылки. Однако в Главе 4 у нас была функция в приложении 4-9, которая затем снова показана в приложении 10-25, в которой рукопись собралась без наставлений времени жизни.

<span class="filename">Файл: src/lib.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-25/src/main.rs:here}}
```

<span class="caption">Приложение 10-25: Функция, которую мы определили в приложении 4-9  собирается без наставлений времени жизни, несмотря на то, что входной и возвращаемый вид данных свойств являются ссылками</span>

Причина, по которой эта рукопись собирается — летописная. В ранних (до-1.0) исполнениях Ржавчины эта рукопись не собралась бы, поскольку каждой ссылке нужно было явно указывать время жизни. В те времена, ярлык функции был бы написан примерно так:

```rust,ignore
fn first_word<'a>(s: &'a str) -> &'a str {
```

После написания большого количества рукописей на Ржавчине разработчики языка обнаружили, что в определённых случаях программисты описывают одни и те же изложении времён жизни снова и снова. Эти случаи были предсказуемы и следовали нескольким определенным образцовым моделям. Объединение Ржавчины решило запрограммировать эти образцы в рукопись сборщика Ржавчины чтобы оценщик заимствований мог вывести времена жизни в таких случаях без необходимости явного указания наставлений программистами.

Мы упоминаем этот отрывок истории Ржавчина, потому что возможно, что в будущем появится больше образцов для самостоятельного выведения времён жизни, которые будут добавлены в сборщик. Таким образом, в будущем может понадобится ещё меньшее количество наставлений.

Образцы, запрограммированные в оценщике ссылок языка Ржавчина называются *правилами неявного выведения времени жизни*. Это не правила, которым должны следовать программисты; а набор частных случаев, которые рассмотрит сборщик, и, если Ваша рукопись попадает в эти случаи, вам не нужно будет указывать время жизни явно.

Правила выведения не предоставляют полного заключения. Если Ржавчина определенно применяет правила, но некоторая неясность относительно времён жизни ссылок все ещё остаётся, сборщик не будет догадываться, какими должны быть времена жизни оставшихся ссылок. В этом случае, вместо угадывания сборщик выдаст ошибку, которую вы можете устранить, добавив изложении времени жизни.

Времена жизни свойств функции или способа называются *временем жизни ввода*, а времена жизни возвращаемых значений называются *временем жизни вывода*.

Сборщик использует три правила, чтобы выяснить времена жизни ссылок при отсутствии явных наставлений. Первое правило относится ко времени жизни ввода, второе и третье правила применяются ко временам жизни вывода. Если сборщик доходит до конца проверки трёх правил и всё ещё есть ссылки, для которых он не может выяснить время жизни, сборщик остановится с ошибкой. Эти правила применяются к объявлениям `fn`, а также к разделам `impl`.

Первое правило заключается в том, что каждый свойство являющийся ссылкой, получает свой собственный свойство времени жизни. Другими словами, функция с одним свойством получит одно свойство времени жизни: `fn foo<'a>(x: &'a i32)`; функция с двумя переменными получит два отдельных свойства времени жизни: `fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`, и так далее.

Второе правило говорит, что если есть ровно одно входное свойство время жизни, то его время жизни назначается всем выходным свойствам: `fn foo<'a>(x: &'a i32) -> &'a i32`.

Третье правило о том, что если есть множество входных свойств времени жизни, но один из них является ссылкой `&self` или `&mut self`, так как эта функция является способом, то время жизни `self` назначается временем жизни всем выходным свойствам. Это третье правило делает способы намного приятнее для чтения и записи, потому что требуется меньше знаков.

Представим, что мы сборщик и применим эти правила, чтобы вывести времена жизни ссылок в ярлыке функции `first_word` приложения 10-25. Ярлык этой функции начинается без объявления времён жизни ссылок:

```rust,ignore
fn first_word(s: &str) -> &str {
```

Теперь мы (в качестве сборщика) применим первое правило, утверждающее, что каждый свойство функции получает своё собственное время жизни. Как обычно, назовём его `'a` и теперь ярлык выглядит так:

```rust,ignore
fn first_word<'a>(s: &'a str) -> &str {
```

Далее применяем второе правило, поскольку в функции указан только один входное свойство времени жизни. Второе правило гласит, что время жизни единственного входного свойства назначается выходным свойствам, поэтому ярлык теперь преобразуется таким образом:

```rust,ignore
fn first_word<'a>(s: &'a str) -> &'a str {
```

Теперь все ссылки в этой функции имеют свойства времени жизни и сборщик может продолжить свой оценка без необходимости просить у программиста указать изложении времён жизни в ярлыке этой функции.

Давайте рассмотрим ещё один пример: на этот раз функцию `longest`, в которой не было свойств времени жизни, когда мы начали с ней работать в приложении 10-20:

```rust,ignore
fn longest(x: &str, y: &str) -> &str {
```

Применим первое правило: каждому свойству назначается собственное время жизни. На этот раз у функции есть два свойства, поэтому есть два времени жизни:

```rust,ignore
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
```

Можно заметить, что второе правило здесь не применимо, так как в ярлыке указано больше одного входного свойства времени жизни. Третье правило также не применимо, так как `longest` — функция, а не способ, следовательно, в ней нет свойства `self`.  Итак, мы прошли все три правила, но так и не смогли вычислить время жизни выходного свойства. Поэтому мы и получили ошибку при попытке собрать рукопись приложения 10-20: сборщик работал по правилам неявного выведения времён жизни, но не мог выяснить все времена жизни ссылок в ярлыке.

Так как третье правило применяется только к способам, далее мы рассмотрим времена жизни в этой среде, чтобы понять, почему нам часто не требуется определять времена жизни в ярлыках способов.

### Изложение времён жизни в определении способов

Когда мы выполняем способы для стопок с временами жизни, мы используем тот же правила написания, который применялся для наставлений обобщённых видов данных на приложении 10-11. Место, где мы объявляем и используем времена жизни, зависит от того, с чем они связаны — с полями стопки, либо с переменными способов и возвращаемыми значениями.

Имена свойств времени жизни для полей стопок всегда описываются после ключевого слова `impl` и затем используются после имени стопки, поскольку эти времена жизни являются частью вида данных стопки.

В ярлыках способов внутри раздела `impl` ссылки могут быть привязаны ко времени жизни ссылок в полях стопки, либо могут быть независимыми. Вдобавок, правила неявного выведения времён жизни часто делают так, что изложении переменных времён жизни являются необязательными в ярлыках способов. Рассмотрим несколько примеров, использующих устройство с названием `ImportantExcerpt`, которую мы определили в приложении 10-24.

Сначала, воспользуемся способом `level`, чьё  единственное свойство является ссылкой на `self`, а возвращаемое значение `i32`, не является ссылкой ни на что:

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-10-lifetimes-on-methods/src/main.rs:1st}}
```

Объявление свойства времени жизни после `impl` и его использование после имени вида данных является обязательным, но нам не нужно определять время жизни ссылки на `self`, благодаря первому правилу неявного выведения времён жизни.

Вот пример, где применяется третье правило неявного выведения времён жизни:

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-10-lifetimes-on-methods/src/main.rs:3rd}}
```

В этом способе имеется два входных свойства, поэтому Ржавчина применит первое правило и назначит обоим свойствам `&self` и `announcement` собственные времена жизни. Далее, поскольку одно из свойств является `&self`, то возвращаемое значение получает время жизни переменой `&self` и все времена жизни теперь выведены.

### Постоянное время жизни

Одно особенное время жизни, которое мы должны обсудить, называется `'static`. Оно означает, что данная ссылка  *может* жить всю продолжительность работы программы. Все строковые записи по умолчанию имеют время жизни `'static`, но мы можем указать его явным образом:

```rust
let s: &'static str = "I have a static lifetime.";
```

Содержание этой строки сохраняется внутри двоичного файл программы и всегда доступно для использования. Следовательно, время жизни всех строковых записей равно `'static`.

Сообщения сборщика об ошибках в качестве решения сбоев могут предлагать вам использовать время жизни `'static`. Но прежде чем указывать `'static` как время жизни для ссылки, подумайте, на самом ли деле данная ссылка будет доступна во всё время работы программы. В большинстве случаев, сообщения об ошибках, предлагающие использовать время жизни `'static` появляются при попытках создания недействительных ссылок или несовпадения имеющихся времён жизни. В таких случаях, решение заключается в исправлении таких неполадок. а не в указании постоянного времени жизни `'static`.

## Обобщённые виды свойств, ограничения сущностей и времена жизни вместе

Давайте кратко рассмотрим правила написания задания свойств обобщённых видов данных, ограничений сущности и времён жизни совместно в одной функции:

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-11-generics-traits-and-lifetimes/src/main.rs:here}}
```

Это функция `longest`  из приложения 10-21, которая возвращает наибольший из двух срезов строки. Но теперь у неё есть дополнительное свойство с именем `ann` обобщённого вида данных `T`, которое может быть представлено любым видом данных, выполняющим сущность `Display`, как указано в предложении `where`. Это дополнительное свойство будет выведено с использованием `{}` , поэтому ограничение сущности `Display` необходимо. Поскольку время жизни является обобщённым видом данных, то объявления свойства времени жизни `'a` и свойства обобщённого вида данных `T` помещаются в один список внутри угловых скобок после имени функции.

## Итоги

В этой главе мы рассмотрели много всего! Теперь вы знакомы с свойствами обобщённого вида данных, сущностями и ограничениями сущности, обобщёнными свойствами времени жизни, вы готовы писать рукопись без повторений, которая будет работать во множестве различных случаев. Свойства обобщённого вида данных позволяют использовать рукопись для различных видов данных. Сущности и ограничения сущности помогают убедиться, что, хотя виды данных и обобщённые, они будут вести себя, как этого требует Ваша рукопись. Вы изучили, как использовать изложении времени жизни чтобы убедиться, что эта гибкая рукопись не будет порождать никаких повисших ссылок. И вся эта оценкапроисходит во время сборки и не влияет на производительность программы во время работы!

Верите или нет, но в рамках этой сути всё есть ещё чему поучиться: в Главе 17 обсуждаются сущности-предметы, которые являются ещё одним способом использования сущностей. Существуют также более сложные задумки с изложениями времени жизни, которые вам понадобятся только в очень сложных случаях; для этого вам следует прочитать [Ржавчина Reference]. Далее вы узнаете, как писать проверки на Ржавчине чтобы убедиться, что Ваша рукопись работает так, как задумано.


[Ржавчина Reference]: ../reference/index.html