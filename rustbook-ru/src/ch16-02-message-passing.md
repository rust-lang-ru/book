## Передача данных с помощью сообщений между потоками

Всё большую распространенность для обеспечения безопасной многопоточности набирает способ, называемый *передача сообщений*. В этом случае потоки или акторы взаимодействуют друг с другом путём отправки сообщений с данными. Мысль этого подхода выражена в слогане из [пособия языка Go](https://golang.org/doc/effective_go.html#concurrency) таким образом: «Не стоит передавать сведения с помощью разделяемой памяти; лучше делитесь памятью, передавая сведения».

Для обеспечения отправки многопоточных сообщений во встроенной библиотеке языка Ржавчины используются *протоки*. Проток в программировании - это общепринятый рычаг, с помощью которого данные из одного потока отправляются другому потоку.

Вы можете представить проток в программировании как направленное движение воды, например как ручей или реку. Если вы поместите какую-нибудь вещь на воду, например резиновую уточку, она будет плыть вниз по течению до тех пор, пока это течение не кончится.

Проток состоит из двух половин: передатчика и приёмника. Передатчик — это место вверх по течению, где вы опускаете резиновых уточек в реку, а приёмник — это место, где резиновые уточки оказываются в конце пути. Одна часть вашей рукописи вызывает способы передатчика с данными, которые вы хотите отправить, а другая часть проверяет принимающую сторону на наличие поступающих сообщений. Проток считается *закрытым* , если либо передающая, либо принимающая его половина уничтожена.

Давайте создадим программу, в которой один поток будет порождать значения и отправлять их в проток, а другой проток будет получать значения и выводить их. Мы будем отправлять между потоками простые значения, используя проток, чтобы изобразить этот способ. После того, как вы ознакомитесь с этим способом, вы сможете использовать протоки с любыми потоками, которым необходимо взаимодействовать друг с другом. Это может быть например система обмена сообщений или система, в которой несколько вычислительных потоков выполняют свою часть расчёта, а затем отправляют эту часть в отдельный поток, который уже собирает полученные итоги.

Сначала в приложении 16-6 мы создадим проток, но не будем ничего с ним делать. Обратите внимание, что эта рукопись ещё не собирается, потому что Ржавчина не может сказать, какой вид данных значений мы хотим отправить через проток.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-06/src/main.rs}}
```

<span class="caption">Приложение 16-6: Создание протока и присваивание двух значений переменным <code>tx</code> и <code>rx</code></span>

Мы создаём новый поток, используя функцию `mpsc::channel`; `mpsc` означает *несколько производителей, один потребитель* (multiple producer, single consumer). Коротко, способ, которым встроенная библиотека Ржавчины использует протоки, означает, что проток может иметь несколько *отправляющих* источников порождающих значения, но только одну *принимающую* сторону, которая использует эти значения. Представьте, что несколько ручьёв втекают в одну большую реку: всё, что плывёт вниз по любому из ручьёв, в конце концов окажется в одной реке. Сейчас мы пока начнём с одного производителя, а когда пример заработает,  добавим ещё несколько.

Функция `mpsc::channel` возвращает составной ряд, первая переменная которого является отправляющей стороной (передатчиком), а второй переменной является принимающая сторона (получатель). Аббревиатуры `tx` и `rx` привычно используются во многих полях для *передатчика* и *приёмника* соответственно, поэтому мы называем соответствующие переменные именно так. Мы используем указанию `let` с образцом данных, который разъединяет составные ряды; мы обсудим использование образцов в указаниях `let` и разъединение в главе 18. А пока знайте, что описанное использование указания `let` является удобным способом извлечения частей составного ряда, возвращаемых `mpsc::channel` .

Давайте переместим передающую часть в порождённый поток так, чтобы он отправлял одну строку и чтобы таким образом, порождённый поток связывался с основным потоком, как показано в приложении 16-7. Это похоже на то, как если бы вы поместили резиновую утку в реку вверх по течению или отправили сообщение окна сообщенийиз одного потока в другой.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-07/src/main.rs}}
```

<span class="caption">Приложение 16-7: Перемещение <code>tx</code> в созданный поток и отправка сообщения «привет»</span>

Опять же, мы используем `thread::spawn` для создания нового потока, а затем используем `move` для перемещения `tx` в замыкание, чтобы порождённый проток владел `tx` . Порождённый поток должен владеть передатчиком, чтобы иметь возможность отправлять сообщения через поток. Передатчик имеет способ `send` , который принимает значение, которое мы хотим отправить. Способ `send` возвращает вид данных `Result<T, E>` , поэтому, если получатель уже удалён и отправить значение некуда, действие отправки вернёт ошибку. В этом примере мы вызываем `unwrap` для сбоя в случае ошибки. В существующем приложении мы обработали бы эту случай более правильно: вернитесь к главе 9, если хотите ещё раз разобрать стратегии правильной обработки ошибок.

В приложении 16-8 мы получим значение от приёмника в основном потоке. Это похоже на извлечение резиновой уточки из воды в конце реки или получение сообщения в чате.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-08/src/main.rs}}
```

<span class="caption">Приложение 16-8: В основном потоке получаем сообщение "hi" и выводим его</span>

Получатель имеет два важных способа: `recv` и `try_recv`. Мы используем `recv`, что является сокращением от *receive*, который запрещает выполнение основного потока и ждёт, пока данные не будут переданы по протоку. Как только значение будет получено, `recv` вернёт его в виде данных `Result<T, E>`. Когда поток закроется, `recv` вернёт ошибку, чтобы дать понять, что больше никаких сообщений не поступит.

В свою очередь, способ try_recv не запрещает, а сразу возвращает итог `Result<T, E>`: значение Ok, содержащее сообщение, если оно доступно или значение Err, если никаких сообщений не поступило. Использование try_recv полезно, если у этого потока есть и другая работа в то время, пока происходит ожидание сообщений: так, мы можем написать круговорот, который вызывает try_recv время от времени, обрабатывает сообщение, если оно доступно, а в промежутке выполняет другую работу до того времени, как вновь будет произведена проверка.

Мы использовали `recv` в этом примере для простоты; у нас нет никакой другой работы для основного потока, кроме как ждать сообщений, поэтому запрет основного потока уместна.

При запуске рукописи приложения 16-8, мы увидим значение, выведенное из основного потока:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
Got: hi
```

Отлично!

### Протоки и передача владения

Правила владения играют жизненно важную значение в отправке сообщений, потому что они помогают писать безопасный многопоточный рукопись. Предотвращение ошибок в многопоточном программировании является преимуществом для размышлений о владении во всех ваших Ржавчина приложениех. Давайте проведём опыт, чтобы показать как протоки и владение действуют совместно для предотвращения неполадок. мы попытаемся использовать значение `val` в порождённом потоке *после* того как отправим его в проток. Попробуйте собрать рукопись в приложении 16-9, чтобы понять, почему эта рукопись не разрешена:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-09/src/main.rs}}
```

<span class="caption">Приложение 16-9: Попытка использовать <code>val</code> после того, как мы отправили его по протоку</span>

Здесь мы пытаемся вывести значение `val` после того, как отправили его в проток, вызвав `tx.send`. Разрешить это было бы плохой мыслью: после того, как значение было отправлено в другой поток, текущий поток мог бы изменить или удалить значение, прежде чем мы попытались бы использовать значение снова. Вероятно изменения в другом потоке могут привести к ошибкам или не ожидаемым итогам из-за противоречивых или несуществующих данных. Однако Ржавчина выдаёт нам ошибку, если мы пытаемся собрать рукопись в приложении 16-9:

```console
{{#include ../listings/ch16-fearless-concurrency/listing-16-09/output.txt}}
```

Наша ошибка для многопоточности привела к ошибке сборки. Функция `send` вступает во владение своим свойством и когда значение передаётся, получатель становится владельцем этого свойства. Это останавливает нас от случайного использования значения снова после его отправки; оценщик заимствования проверяет, что все в порядке.

### Отправка нескольких значений и ожидание получателем

Рукопись в приложении 16-8 собирается и выполняется, но в нем неясно показано то, что два отдельных потока общаются друг с другом через проток. В приложении 16-10 мы внесли некоторые изменения, которые докажут, что рукопись в приложении 16-8 работает одновременно: порождённый поток теперь будет отправлять несколько сообщений и делать паузу на секунду между каждым сообщением.

<span class="filename">Файл: src/main.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-10/src/main.rs}}
```

<span class="caption">Приложение 16-10: Отправка нескольких сообщений и пауза между ними</span>

На этот раз порождённый поток имеет вектор строк, которые мы хотим отправить основному потоку. Мы перебираем их, отправляя каждую строку по отдельности и делаем паузу между ними, вызывая функцию `thread::sleep` со значением `Duration` равным 1 секунде.

В основном потоке мы больше не вызываем функцию `recv` явно: вместо этого мы используем `rx` как повторитель . Для каждого полученного значения мы выводим его. Когда проток будет закрыт, повторение закончится.

При выполнении рукописи в приложении 16-10 вы должны увидеть следующий вывод с паузой в 1 секунду между каждой строкой:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
Got: hi
Got: from
Got: the
Got: thread
```

Поскольку у нас нет рукописи, которая приостанавливает или задерживает круговорот `for` в основном потоке, мы можем сказать, что основной поток ожидает получения значений из порождённого потока.

### Создание нескольких отправителей путём удваивания передатчика

Ранее мы упоминали, что `mpsc` — это сокращение от *множество поставщиков, один потребитель* . Давайте используем `mpsc` в полной мере и расширим рукопись в приложении 16.10, создав несколько потоков, которые отправляют значения одному и тому же получателю. Мы можем сделать это, удвоив передатчик, как показано в приложении 16.11:

<span class="filename">Файл: src/main.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-11/src/main.rs:here}}
```

<span class="caption">Приложение 16-11: Отправка нескольких сообщений от нескольких производителей</span>

На этот раз, прежде чем мы создадим первый порождённый поток, мы вызовем функцию `clone` на передатчике. В итоге мы получим новый передатчик, который мы сможем передать первому порождённому потоку. Исходный передатчик мы передадим второму порождённому потоку. Это даст нам два потока, каждый из которых отправляет разные сообщения одному получателю.

Когда вы запустите рукопись, вывод должен выглядеть примерно так:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
```

Вы можете увидеть значения в другом порядке, в зависимости от вашей системы. Именно такое поведение делает одновременность как важным, так и  сложным. Если вы проведите опыты с `thread::sleep` , задавая различные значения переменной в разных потоках, каждый запуск будет более неопределенным и каждый раз будут выводиться разные данные.

Теперь, когда мы посмотрели, как работают протоки, давайте рассмотрим другой способ многопоточности.
