## Передача данных с помощью сообщений между потоками

Всё большую распространенность для обеспечения безопасной многопоточности набирает способ, называемый *передача сообщений*. В этом случае потоки или акторы взаимодействуют друг с другом путём отправки сообщений с данными. Мысль этого подхода выражена в слогане из [пособия языка Go](https://golang.org/doc/effective_go.html#concurrency) таким образом: «Не стоит передавать сведения с помощью разделяемой памяти; лучше делитесь памятью, передавая сведения».

Для обеспечения отправки многопоточных сообщений во встроенной библиотеке языка Ржавчина выполнены *потоки*. Поток в программировании - это общепринятый рычаг, с помощью которого данные из одного потока отправляются другому потоку.

Вы можете представить поток в программировании как направленное движение воды, например как ручей или реку. Если вы поместите какую-нибудь вещь на воду, например резиновую уточку, она будет плыть вниз по течению до тех пор, пока это течение не кончится.

Поток состоит из двух половин: передатчика и приёмника. Передатчик — это место вверх по течению, где вы опускаете резиновых уточек в реку, а приёмник — это место, где резиновые уточки оказываются в конце пути. Одна часть вашей рукописи вызывает способы передатчика с данными, которые вы хотите отправить, а другая часть проверяет принимающую сторону на наличие поступающих сообщений. Поток считается *закрытым* , если либо передающая, либо принимающая его половина уничтожена.

Давайте создадим программу, в которой один поток будет порождать значения и отправлять их в поток, а другой поток будет получать значения и выводить их. Мы будем отправлять между потоками простые значения, используя поток, чтобы изобразить эту функцию. После того, как вы ознакомитесь с этим способом, вы сможете использовать потоки с любыми потоками, которым необходимо взаимодействовать друг с другом. Это может быть например система обмена сообщений или система, в которой несколько вычислительных потоков выполняют свою часть расчёта, а затем отправляют эту часть в отдельный поток, который уже собирает полученные итоги.

Сначала в приложении 16-6 мы создадим поток, но не будем ничего с ним делать. Обратите внимание, что эта рукопись ещё не собирается, потому что Ржавчина не может сказать, какой вид данных значений мы хотим отправить через поток.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-06/src/main.rs}}
```

<span class="caption">Приложение 16-6: Создание потока и присваивание двух значений переменным <code>tx</code> и <code>rx</code></span>

Мы создаём новый поток, используя функцию `mpsc::channel`; `mpsc` означает *несколько производителей, один потребитель* (multiple producer, single consumer). Коротко, способ, которым обычная библиотека Ржавчины использует потоки, означает, что поток может иметь несколько *отправляющих* источников порождающих значения, но только одну *принимающую* сторону, которая потребляет эти значения. Представьте, что несколько ручьёв втекают в одну большую реку: всё, что плывёт вниз по любому из ручьёв, в конце концов окажется в одной реке. Сейчас мы пока начнём с одного производителя, а когда пример заработает,  добавим ещё несколько.

Функция `mpsc::channel` возвращает упорядоченный ряд, первая переменная которого является отправляющей стороной (передатчиком), а второй переменной является принимающая сторона (получатель). Аббревиатуры `tx` и `rx` привычно используются во многих полях для *передатчика* и *приёмника* соответственно, поэтому мы называем соответствующие переменные именно так. Мы используем указанию `let` с образцом данных, который разъединяет упорядоченные ряды; мы обсудим использование образцов в указаниях `let` и разъединение в главе 18. А пока знайте, что описанное использование указания `let` является удобным способом извлечения частей упорядоченного ряда, возвращаемых `mpsc::channel` .

Давайте переместим передающую часть в порождённый поток так, чтобы он отправлял одну строку и чтобы таким образом, порождённый поток связывался с основным потоком, как показано в приложении 16-7. Это похоже на то, как если бы вы поместили резиновую утку в реку вверх по течению или отправили сообщение окна сообщенийиз одного потока в другой.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-07/src/main.rs}}
```

<span class="caption">Приложение 16-7: Перемещение <code>tx</code> в созданный поток и отправка сообщения «привет»</span>

Опять же, мы используем `thread::spawn` для создания нового потока, а затем используем `move` для перемещения `tx` в замыкание, чтобы порождённый поток владел `tx` . Порождённый поток должен владеть передатчиком, чтобы иметь возможность отправлять сообщения через поток. Передатчик имеет способ `send` , который принимает значение, которое мы хотим отправить. Способ `send` возвращает вид данных `Result<T, E>` , поэтому, если получатель уже удалён и отправить значение некуда, действие отправки вернёт ошибку. В этом примере мы вызываем `unwrap` для сбоя в случае ошибки. В существующем приложении мы обработали бы эту случай более правильно: вернитесь к главе 9, если хотите ещё раз разобрать стратегии правильной обработки ошибок.

В приложении 16-8 мы получим значение от приёмника в основном потоке. Это похоже на извлечение резиновой уточки из воды в конце реки или получение сообщения в чате.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-08/src/main.rs}}
```

<span class="caption">Приложение 16-8: В основном потоке получаем сообщение "hi" и выводим его</span>

Получатель имеет два важных способа: `recv` и `try_recv`. Мы используем `recv`, что является сокращением от *receive*, который запрещает выполнение основного потока и ждёт, пока данные не будут переданы по потоку. Как только значение будет получено, `recv` вернёт его в виде данных `Result<T, E>`. Когда поток закроется, `recv` вернёт ошибку, чтобы дать понять, что больше никаких сообщений не поступит.

В свою очередь, способ try_recv не запрещает, а сразу возвращает итог `Result<T, E>`: значение Ok, содержащее сообщение, если оно доступно или значение Err, если никаких сообщений не поступило. Использование try_recv полезно, если у этого потока есть и другая работа в то время, пока происходит ожидание сообщений: так, мы можем написать круговорот, который вызывает try_recv время от времени, обрабатывает сообщение, если оно доступно, а в промежутке выполняет другую работу до того времени, как вновь будет произведена проверка.

Мы использовали `recv` в этом примере для простоты; у нас нет никакой другой работы для основного потока, кроме как ждать сообщений, поэтому запрет основного потока уместна.

При запуске рукописи приложения 16-8, мы увидим значение, выведенное из основного потока:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
Got: hi
```

Отлично!

### потоки и передача владения

Правила владения играют жизненно важную значение в отправке сообщений, потому что они помогают писать безопасный многопоточный рукопись. Предотвращение ошибок в многопоточном программировании является преимуществом для размышлений о владении во всех ваших Ржавчина программах. Давайте проведём опыт, чтобы показать как потоки и владение действуют совместно для предотвращения неполадок. мы попытаемся использовать значение `val` в порождённом потоке *после* того как отправим его в поток. Попробуйте собрать рукопись в приложении 16-9, чтобы понять, почему эта рукопись не разрешена:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-09/src/main.rs}}
```

<span class="caption">Приложение 16-9: Попытка использовать <code>val</code> после того, как мы отправили его по потоку</span>

Здесь мы пытаемся вывести значение `val` после того, как отправили его в поток вызвав `tx.send`. Разрешить это было бы плохой мыслью: после того, как значение было отправлено в другой поток, текущий поток мог бы изменить или удалить значение, прежде чем мы попытались бы использовать значение снова. Вероятно изменения в другом потоке могут привести к ошибкам или не ожидаемым итогам из-за противоречивых или несуществующих данных. Однако Ржавчина выдаёт нам ошибку, если мы пытаемся собрать рукопись в приложении 16-9:

```console
{{#include ../listings/ch16-fearless-concurrency/listing-16-09/output.txt}}
```

Наша ошибка для многопоточности привела к ошибке сборки. Функция `send` вступает во владение своим свойством и когда значение перемещается, получатель становится владельцем этого свойства. Это останавливает нас от случайного использования значения снова после его отправки; оценщик заимствования проверяет, что все в порядке.

### Отправка нескольких значений и ожидание получателем

Рукопись в приложении 16-8 собирается и выполняется, но в нем неясно показано то, что два отдельных потока общаются друг с другом через поток. В приложении 16-10 мы внесли некоторые изменения, которые докажут, что рукопись в приложении 16-8 работает одновременно: порождённый поток теперь будет отправлять несколько сообщений и делать паузу на секунду между каждым сообщением.

<span class="filename">Файл: src/main.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-10/src/main.rs}}
```

<span class="caption">Приложение 16-10: Отправка нескольких сообщений и пауза между ними</span>

На этот раз порождённый поток имеет вектор строк, которые мы хотим отправить основному потоку. Мы перебираем их, отправляя каждую строку по отдельности и делаем паузу между ними, вызывая функцию `thread::sleep` со значением `Duration` равным 1 секунде.

В основном потоке мы больше не вызываем функцию `recv` явно: вместо этого мы используем `rx` как повторитель . Для каждого полученного значения мы выводим его. Когда поток будет закрыт, повторение закончится.

При выполнении рукописи в приложении 16-10 вы должны увидеть следующий вывод с паузой в 1 секунду между каждой строкой:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
Got: hi
Got: from
Got: the
Got: thread
```

Поскольку у нас нет рукописи, которая приостанавливает или задерживает круговорот `for` в основном потоке, мы можем сказать, что основной поток ожидает получения значений из порождённого потока.

### Создание нескольких отправителей путём удваивания передатчика

Ранее мы упоминали, что `mpsc` — это сокращение от *множество поставщиков, один потребитель* . Давайте используем `mpsc` в полной мере и расширим рукопись в приложении 16.10, создав несколько потоков, которые отправляют значения одному и тому же получателю. Мы можем сделать это, удвоив передатчик, как показано в приложении 16.11:

<span class="filename">Файл: src/main.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-11/src/main.rs:here}}
```

<span class="caption">Приложение 16-11: Отправка нескольких сообщений от нескольких производителей</span>

На этот раз, прежде чем мы создадим первый порождённый поток, мы вызовем функцию `clone` на передатчике. В итоге мы получим новый передатчик, который мы сможем передать первому порождённому потоку. Исходный передатчик мы передадим второму порождённому потоку. Это даст нам два потока, каждый из которых отправляет разные сообщения одному получателю.

Когда вы запустите рукопись, вывод должен выглядеть примерно так:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
```

Вы можете увидеть значения в другом порядке, в зависимости от вашей системы. Именно такое поведение делает одновременность как важным, так и  сложным. Если вы проведите опыты с `thread::sleep` , задавая различные значения переменной в разных потоках, каждый запуск будет более неопределенным и каждый раз будут выводиться разные данные.

Теперь, когда мы посмотрели, как работают потоки, давайте рассмотрим другой способ многопоточности.
