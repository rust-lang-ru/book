## Обращение с умными указателями как с обычными ссылками с помощью сущности `Deref` 

Используя сущность `Deref`, вы можете изменить поведение *приказчика разыменования* `*` (не путать с приказчиками умножения или вездесущего подключения). Используя `Deref` умный указатель может обрабатываться как обычная ссылка, вы можете писать рукопись, используя как ссылки, так и умные указатели .

Давайте сначала посмотрим, как работает приказчик разыменования с обычными ссылками. Затем мы попытаемся определить пользовательский вид данных, который ведёт себя как `Box<T>` и посмотрим, почему приказчик разыменования не работает как ссылка для нового объявленного вида данных. Мы рассмотрим, как использование сущности `Deref` делает возможным работу умных указателей подобно ссылкам. Затем посмотрим на *разыменованное приведение* (deref coercion) в Ржавчине и как оно позволяет работать с любыми ссылками или умными указателями.

> Примечание: есть одна большая разница между видом данных `МойКороб<T>`, который мы собираемся создать и существующим `Box<T>`: наше исполнение не будет хранить свои данные в куче. В примере мы сосредоточимся на сущности `Deref`, поэтому менее важно то, где данные хранятся, чем поведение подобное указателю.

<!-- Old link, do not remove -->

<a id="following-the-pointer-to-the-value-with-the-dereference-operator"></a>

### Следуя за указателем на значение

Обычная ссылка - это разновидность указателя, а указатель можно рассматривать как своеобразную стрелочку указывающее на значение, хранящемуся в другом месте. В приложении 15-6 мы создаём ссылку на значение `i32`, а затем используем приказчик разыменования для перехода от ссылки к значению:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-06/src/main.rs}}
```

<span class="caption">Приложение 15-6: Использование приказчика разыменования для следования по ссылке к значению <code>i32</code></span>

Переменной `x` присвоено значение`5` вида данных `i32`. Мы установили в качестве значения `y` ссылку на `x`. Мы можем утверждать, что значение `x` равно `5`. Однако, если мы хотим совершить какие-либо действия со значением, хранящимся в переменной `y`, мы должны использовать способ разыменовывания `*` к переменной  - `*y`, чтобы перейти по ссылке к значению, на которое она указывает (таким образом, происходит *разыменование*), для того чтобы сборщик при сравнении мог использовать действительное значение. Как только мы разыменуем `y`, мы получим доступ к целочисленному значению, на которое указывает `y`, которое и будем сравнивать с числом `5`.

Если попытаться вызвать сравнение `assert_eq!(5, y);`, то получили  ошибку сборки:

```console
{{#include ../listings/ch15-smart-pointers/output-only-01-comparing-to-reference/output.txt}}
```

Сравнение числа и ссылки на число не допускается, потому что это различные видов данных. Мы должны использовать приказчик разыменования, чтобы перейти по ссылке на значение, на которое она указывает.

### Использование `Box<T>` как ссылки

Мы можем переписать рукопись в приложении 15-6, чтобы использовать `Box<T>` вместо ссылки; приказчик разыменования, используемый для `Box<T>` в приложении 15-7, работает так же, как приказчик разыменования, используемый для ссылки в приложении 15-6:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-07/src/main.rs}}
```

<span class="caption">Приложение 15-7: Использование приказчика разыменования с видом данных <code>Box&lt;i32&gt;</code></span>

Основное различие между приложением 15-7 и приложением 15-6 заключается в том, что здесь мы устанавливаем переменную `y` как образец данных `Box<T>`, указывающий на воспроизведенное значение `x`, а не как ссылку, указывающую на значение `x`. В последнем сравнении мы можем использовать приказчик разыменования, чтобы проследовать за указателем `Box<T>` так же, как мы это делали, когда переменная `y` была ссылкой. Далее мы рассмотрим, что особенного в `Box<T>`, что позволяет нам использовать приказчик разыменования, определяя наш собственный вид данных.

### Определение собственного умного указателя

Давайте создадим умный указатель, похожий на вид данных `Box<T>` предоставляемый встроенной библиотекой, чтобы понять как поведение умных указателей отличается от поведения обычной ссылки. Затем мы рассмотрим вопрос, как добавить возможность использовать приказчик разыменования.

Вид данных `Box<T>` в конечном итоге определяется как стопка, включённая в составной ряд с одной переменной, поэтому в приложении 15-8 подобным образом определяется `МойКороб<T>`. Мы также определим способ (функцию) `new`, чтобы она соответствовала способу (функции) `new`, определённой в `Box<T>`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-08/src/main.rs:here}}
```

<span class="caption">Приложение 15-8: Определение стопки <code>МойКороб&lt;T&gt;</code></span>

Мы определяем стопку с именем `МойКороб` и объявляем обобщённое свойство `T`, потому что мы хотим, чтобы наша стопка могла хранить значения любого вида данных. Стопка `МойКороб` является видом данных составного ряда с одной переменной обобщенного вида данных `T`. Способ (функция) `МойКороб::new` принимает одно свойство вида данных `T` и возвращает образец данных `МойКороб`, который содержит переданное значение.

Давайте попробуем добавить способ (функцию) `main` из приложения 15-7 в приложение 15-8 и изменим её на использование вида данных `МойКороб<T>`, который мы определили вместо `Box<T>`. Рукопись в приложении 15-9 нельзя собрать, потому что Ржавчина не знает, как разыменовывать `МойКороб`.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-09/src/main.rs:here}}
```

<span class="caption">Приложение 15-9: Попытка использовать <code>МойКороб&lt;T&gt;</code> таким же образом, как мы использовали ссылки и <code>Box&lt;T&gt;</code></span>

Вот итог ошибки сборки:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-09/output.txt}}
```

Наш вид данных `МойКороб<T>` не может быть разыменован, потому что мы не использовали эту возможность. Чтобы включить разыменование с помощью приказчика `*`, мы используем сущность `Deref`.

### Использование сущности `Deref`

Как обсуждалось в разделе [“Использование сущности для вида данных”]<!--  --> Главы 10, для использования сущности нужно предоставить или объявить требуемые способы сущности. Сущность `Deref`, предоставленная встроенной библиотекой требует от нас использования одного способа с именем `deref`, который заимствует `self` и возвращает ссылку на внутренние данные. Приложение 15-10 содержит использование сущности `Deref`, добавленной к определению `МойКороб`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-10/src/main.rs:here}}
```

<span class="caption">Приложение 15-10: Использование <code>Deref</code> для стопки <code>МойКороб&lt;T&gt;</code></span>

Согласно правил написания, `type Target = T;` определяет связанный (обобщенный) вид данных `T` для использования у сущности `Deref`. Связанные виды данных - это немного другой способ объявления обобщённого свойства, но пока вам не нужно о них беспокоиться; мы рассмотрим их более подробно в главе 19.

Мы укажем в теле способа `deref` приказчик `&self.0 `, чтобы `deref` вернул ссылку на значение, к которому мы хотим получить доступ с помощью приказчика `*`; вспомним из раздела ["Стопки в виде составного ряда: стопки без объявления полей для создания разных видов данных"]<!-- ignore --> Главы 5, что указатель составного ряда `.0` получает доступ к первой переменной в стопке в составном ряду. Способ (функция) `main` в приложении 15-9, которая вызывает `*` для значения `МойКороб<T>`, теперь собирается, и проверки проходят!

Без сущности `Deref` сборщик может только разыменовывать `&` ссылки. Способ `deref` даёт сборщику возможность принимать значение любого  данных, использующего `Deref` и применять способ `deref` чтобы получить ссылку `&`, которую он знает, как разыменовывать.

Когда мы ввели `*y` в приложении 15-9, Ржавчина в действительности исполнила следующее:

```rust,ignore
*(y.deref())
```

Ржавчина заменяет приказчик `*` путём вызова способа `deref` и затем простое разыменование, поэтому нам не требуется думать о том, нужно ли нам вызывать способ `deref`. Этот способ (функция) Ржавчины позволяет писать рукопись, которая исполняется одинаково, независимо от того, есть ли у нас обычная ссылка или вид данных, использующие сущность `Deref`.

Причина, по которой способ `deref` возвращает ссылку на значение, и что простое разыменование вне круглых скобок в `*(y.deref())` все ещё необходимо,так как связано с устройством владения видами данных. Если бы способ `deref` возвращал значение напрямую, а не ссылку на него, значение переместилось бы из `self`. Мы не хотим передавать владение внутренним значением внутри `МойКороб<T>` в этом случае и в большинстве случаев, когда мы используем приказчик разыменования.

Обратите внимание, что приказчик `*` заменён путём вызова способа `deref`, а затем вызовом приказчика `*` только один раз, так устроен способ разыменовывания `*`. Поскольку использование разыменовывания `*` не запускает бесконечный круговорот его применений, мы получаем вид данных `i32`, которые соответствуют числу `5` в `assert_eq!` приложения 15-9.

### Неявное использование сущности `Deref` с способами (функциями) и способами<a id="implicit-deref-coercions-with-functions-and-methods"></a>

Использование неявного *разыменованного приведения* преобразует ссылку на вид данных, которую использует сущность `Deref`, в ссылку на другой вид. Например, deref coercion может преобразовать `&String` в `&str`, потому что `String` использует сущность `Deref`, которая возвращает `&str`. Deref coercion - это удобное средство, которое Ржавчина использует для переменных способов (функций) и способов, и работает только для видов данных, использующих сущность `Deref`. Это происходит самостоятельно , когда мы передаём в качестве переменной способа (функции) или способа ссылку на значение определённого вида данных, которое не соответствует виду данных, указанных в свойстве при определении способа (функции) или способа. В итоге последовательности вызовов способа `deref` вид данных, который мы передали, преобразуется в иной вид данных, необходимый для использования функцией или способом.

Разыменованное приведение было добавлено в Ржавчину для того, чтобы при вызове способов (функций) и способов, не нужно было добавлять множество явных ссылок и разыменований с помощью использования `&` и `*`. Неявное разыменованное приведение также позволяет сократить рукопись, которая может работать как с ссылками, так и с умными указателями.

Чтобы увидеть разыменованное приведение в действии, давайте воспользуемся видом данных `МойКороб<T>` , определённым в приложении 15-8, а также использование `Deref` добавленную в приложении 15-10. В приложении 15-11 изложено определение способа (функции) `здравствуй` , у которой есть свойство `name`, представленное в виде `&str` ссылки на срез строки:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-11/src/main.rs:here}}
```

<span class="caption">Приложение 15-11: Способ (функция) <code>здравствуй</code>, имеющая свойство  <code>имя</code> вида данных <code>&amp;str</code></span>

Можно вызвать способ (функцию) `здравствуй` со срезом строки в качестве переменной, например `здравствуй("Ржавчина");`. Неявное разыменованное приведение делает возможным вызов `здравствуй` со ссылкой на значение вида данных `МойКороб<String>`, как показано в приложении 15-12.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-12/src/main.rs:here}}
```

<span class="caption">Приложение 15-12: Вызов <code>здравствуй</code> со ссылкой на переменную <code>МойКороб&lt;String&gt;</code>, которое выполняется за счёт использования неявного разыменованного приведения</span>

Здесь мы вызываем способ (функцию) `здравствуй` с переменной `&m`, которая является ссылкой на переменную `МойКороб<String>`. Поскольку мы используем сущность `Deref` для `МойКороб<T>` в приложении 15-10, то Ржавчина вызывая способ `deref` , может преобразовать ссылку `&МойКороб<String>` в `&String` как явно, так и в `&str` неявно. Встроенная библиотека предоставляет использование сущности `Deref` для вида данных `String`, которая возвращает ссылку на строку `&String`, это описано в пособии API сущности `Deref`. Ржавчина далее вызывает способ `deref`, чтобы превратить `&String` в `&str`, что соответствует требованиям способа (функции) `здравствуй`.

Если бы Ржавчина не использовала разыменованное приведение (в том числе не явное), необходимо бы было явно указывать разыменование `*` и расчленение `[..]` на срез строки.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-13/src/main.rs:here}}
```

<span class="caption">Приложение 15-13: Рукопись, которую требуется написать в отстутствие предоставленных возможностей и способов разыменованного приведения ссылок в Ржавчине</span>

Действие `(*m)` разыменовывает `МойКороб<String>` в `String`. Затем `&` и `[..]` принимают строковый срез `String`, равный всей строке, чтобы соответствовать требованию к свойству способа (функции) `здравствуй`. Рукопись без разыменованного приведения сложнее читать, писать и понимать со всеми этими знаками. Разыменованное приведение позволяет Ржавчине самостоятельно выполнять все преобразования за нас .

Когда сущность `Deref` определена при изложении вида данных, Ржавчина, обрабатывая виды данных, будет использовать `Deref::deref` столько раз, сколько необходимо, чтобы получить ссылку, соответствующую  требуемую виду данных свойства способа (функции). Количество раз, которое нужно использовать`Deref::deref` определяется во время сборки, поэтому использование разыменованного приведения не имеет накладных расходов во время выполнения!

### Как разыменованное приведение взаимодействует с изменяемостью

Подобно тому, как вы используете сущность `Deref` для переопределения приказчика `*` у неизменяемых ссылок, вы можете использовать сущность `DerefMut` для переопределения приказчика `*` у изменяемых ссылок.

Ржавчина использует разыменованное приведение, для видов данных и использования сущностей в трёх случаях:

- Из вида данных `&T` в вид данных `&U` когда верно `T: Deref<Target=U>`
- Из вида данных `&mut T` в вид данных `&mut U` когда верно `T: DerefMut<Target=U>`
- Из вида данных `&mut T` в вид данных `&U` когда верно `T: Deref<Target=U>`

Первые два случая равноценны друг другу, за исключением того, что второй использует изменяемость. В первом случае говорится, что если у вас есть `&T`, а `T` использует `Deref` для некоторого вида данных `U`, вы сможете прозрачно получить `&U`. Во втором случае говорится, что такое же разыменованное приведение происходит и для изменяемых ссылок.

Третий случай хитрее: Ржавчина также приводит изменяемую ссылку к неизменяемой. Но обратное *не* представляется возможным: неизменяемые ссылки никогда не приводятся к изменяемым ссылкам. Из-за правил заимствования, если у вас есть изменяемая ссылка, эта изменяемая ссылка должна быть единственной ссылкой на данные (в противном случае приложение не будет собираться). Преобразование одной изменяемой ссылки в неизменяемую ссылку никогда не нарушит правила заимствования. Преобразование неизменяемой ссылки в изменяемую ссылку потребует наличия только одной неизменяемой ссылки на эти данные, и правила заимствования не могут обеспечить этого. Следовательно, Ржавчина не позволяет преобразование неизменяемой ссылки в изменяемую.


[“Использование сущности для вида данных”]: ch10-02-traits.html#implementing-a-trait-on-a-type
["Стопки в виде составного ряда: стопки без объявления полей для создания разных видов данных"]: ch05-01-defining-structs.html#Стопки-в-виде-составного-ряда-стопки-без-объявления-полей-для-создания-разных-видов-данных