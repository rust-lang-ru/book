## Обращение с умными указателями как с обычными ссылками с помощью `Deref` сущности

Используя сущность `Deref`, вы можете изменить поведение *приказчика разыменования* `*` (не путать с приказчиками умножения или вездесущего подключения). Выполнив `Deref` таким образом, что умный указатель может рассматриваться как обычная ссылка, вы можете писать рукопись, оперирующую ссылками, а также использовать эту рукопись с умными указателями.

Давайте сначала посмотрим, как работает приказчик разыменования с обычными ссылками. Затем мы попытаемся определить пользовательский вид данных, который ведёт себя как `Box<T>` и посмотрим, почему приказчик разыменования не работает как ссылка для нового объявленного вида данных. Мы рассмотрим, как использование сущности `Deref` делает возможным работу умных указателей подобно ссылкам. Затем посмотрим на *разыменованное приведение* (deref coercion) в Ржавчине и как оно позволяет работать с любыми ссылками или умными указателями.

> Примечание: есть одна большая разница между видом данных `MyBox<T>`, который мы собираемся создать и существующим `Box<T>`: наша исполнение не будет хранить свои данные в куче. В примере мы сосредоточимся на сущности `Deref`, поэтому менее важно то, где данные хранятся, чем поведение подобное указателю.

<!-- Old link, do not remove -->

<a id="following-the-pointer-to-the-value-with-the-dereference-operator"></a>

### Следуя за указателем на значение

Обычная ссылка - это разновидность указателя, а указатель можно рассматривать как своеобразную стрелочку направляющую к значению, хранящемуся в другом месте. В приложении 15-6 мы создаём ссылку на значение `i32`, а затем используем приказчик разыменования для перехода от ссылки к значению:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-06/src/main.rs}}
```

<span class="caption">Приложение 15-6: Использование приказчика разыменования для следования по ссылке к значению <code>i32</code></span>

Переменной `x` присвоено значение`5` вида данных `i32`. Мы установили в качестве значения `y` ссылку на `x`. Мы можем утверждать, что значение `x` равно `5`. Однако, если мы хотим сделать утверждение о значении в `y`, мы должны использовать `*y`, чтобы перейти по ссылке к значению, на которое она указывает (таким образом, происходит *разыменование*), для того чтобы сборщик при сравнении мог использовать действительное значение. Как только мы разыменуем `y`, мы получим доступ к целочисленному значению, на которое указывает `y`, которое и будем сравнивать с `5`.

Если бы мы попытались написать `assert_eq!(5, y);`, то получили ошибку сборки:

```console
{{#include ../listings/ch15-smart-pointers/output-only-01-comparing-to-reference/output.txt}}
```

Сравнение числа и ссылки на число не допускается, потому что они различных видов данных. Мы должны использовать приказчик разыменования, чтобы перейти по ссылке на значение, на которое она указывает.

### Использование `Box<T>` как ссылку

Мы можем переписать рукопись в приложении 15-6, чтобы использовать `Box<T>` вместо ссылки; приказчик разыменования, используемый для `Box<T>` в приложении 15-7, работает так же, как приказчик разыменования, используемый для ссылки в приложении 15-6:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-07/src/main.rs}}
```

<span class="caption">Приложение 15-7: Использование приказчика разыменования с видом данных <code>Box&lt;i32&gt;</code></span>

Основное различие между приложением 15-7 и приложением 15-6 заключается в том, что здесь мы устанавливаем `y` как образец данных `Box<T>`, указывающий на воспроизведенное значение `x`, а не как ссылку, указывающую на значение `x`. В последнем утверждении мы можем использовать приказчик разыменования, чтобы проследовать за указателем `Box<T>` так же, как мы это делали, когда `y` был ссылкой. Далее мы рассмотрим, что особенного в `Box<T>`, что позволяет нам использовать приказчик разыменования, определяя наш собственный вид данных.

### Определение собственного умного указателя

Давайте создадим умный указатель, похожий на вид данных `Box<T>` предоставляемый встроенной библиотекой, чтобы понять как поведение умных указателей отличается от поведения обычной ссылки. Затем мы рассмотрим вопрос, как добавить возможность использовать приказчик разыменования.

Вид данных `Box<T>` в конечном итоге определяется как стопки упорядоченного ряда с одной переменной, поэтому в приложении 15-8 подобным образом определяется `MyBox<T>`. Мы также определим функцию `new`, чтобы она соответствовала функции `new`, определённой в `Box<T>`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-08/src/main.rs:here}}
```

<span class="caption">Приложение 15-8: Определение вида данных <code>MyBox&lt;T&gt;</code></span>

Мы определяем стопку с именем `MyBox` и объявляем Обобщённое свойство `T`, потому что мы хотим, чтобы наш вид данных хранил значения любого вида данных. Стопка `MyBox` является видом данных упорядоченного ряда с одной переменной вида данных `T`. Функция `MyBox::new` принимает одно свойство вида данных `T` и возвращает образец данных `MyBox`, который содержит переданное значение.

Давайте попробуем добавить функцию `main` из приложения 15-7 в приложение 15-8 и изменим её на использование вида данных `MyBox<T>`, который мы определили вместо `Box<T>`. Рукопись в приложении 15-9 не будет собираться, потому что Ржавчина не знает, как разыменовывать `MyBox`.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-09/src/main.rs:here}}
```

<span class="caption">Приложение 15-9: Попытка использовать <code>MyBox&lt;T&gt;</code> таким же образом, как мы использовали ссылки и <code>Box&lt;T&gt;</code></span>

Вот итог ошибки сборки:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-09/output.txt}}
```

Наш вид данных `MyBox<T>` не может быть разыменован, потому что мы не выполнили эту возможность. Чтобы включить разыменование с помощью приказчика `*`, мы выполняем сущность `Deref`.

### Трактование вида данных как ссылки выполняя сущность `Deref`

Как обсуждалось в разделе [“Использование сущности для вида данных”]<!--  --> Главы 10, для выполнения сущности нужно предоставить выполнения требуемых способов сущности. Сущность `Deref`, предоставляемый встроенной библиотекой требует от нас выполнения одного способа с именем `deref`, который заимствует `self` и возвращает ссылку на внутренние данные. Приложение 15-10 содержит использование `Deref` добавленную к определению `MyBox`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-10/src/main.rs:here}}
```

<span class="caption">Приложение 15-10: Выполнение <code>Deref</code> для вида данных <code>MyBox&lt;T&gt;</code></span>

Согласно правил написания `type Target = T;` определяет связанный вид данных для использования у сущности `Deref`. Связанные виды данных - это немного другой способ объявления обобщённого свойства, но пока вам не нужно о них беспокоиться; мы рассмотрим их более подробно в главе 19.

Мы исполним тело способа `deref` приказчиком `&self.0 `, чтобы `deref` вернул ссылку на значение, к которому мы хотим получить доступ с помощью приказчика `*`; вспомним из раздела ["Using Tuple Structs without Named Fields to Create Different Types"]<!-- ignore --> Главы 5, что `.0` получает доступ к первому значению в упорядоченной в ряд стопке. Функция `main` в приложении 15-9, которая вызывает `*` для значения `MyBox<T>`, теперь собирается, и проверки проходят!

Без сущности `Deref` сборщик может только разыменовывать `&` ссылки. Способ `deref` даёт сборщику возможность принимать значение любого  данных, выполняющего `Deref` и вызывать способ `deref` чтобы получить ссылку `&`, которую он знает, как разыменовывать.

Когда мы ввели `*y` в приложении 15-9, Ржавчина в действительности выполнила за кулисами такую рукопись:

```rust,ignore
*(y.deref())
```

Ржавчина заменяет приказчик `*` вызовом способа `deref` и затем простое разыменование, поэтому нам не нужно думать о том, нужно ли нам вызывать способ `deref`. Эта функция Ржавчины позволяет писать рукопись, которая исполняется одинаково, независимо от того, есть ли у нас обычная ссылка или вид данных, выполняющий сущность `Deref`.

Причина, по которой способ `deref` возвращает ссылку на значение, и что простое разыменование вне круглых скобок в `*(y.deref())` все ещё необходимо, связана с системой владения. Если бы способ `deref` возвращал значение напрямую, а не ссылку на него, значение переместилось бы из `self`. Мы не хотим передавать владение внутренним значением внутри `MyBox<T>` в этом случае и в большинстве случаев, когда мы используем приказчик разыменования.

Обратите внимание, что приказчик `*` заменён вызовом способа `deref`, а затем вызовом приказчика `*` только один раз, каждый раз, когда мы используем `*` в рукописи. Поскольку замена приказчика `*` не повторяется бесконечно, мы получаем данные вида данных `i32`, которые соответствуют `5` в `assert_eq!` приложения 15-9.

### Неявные разыменованные приведения с функциями и способами<a id="implicit-deref-coercions-with-functions-and-methods"></a>

*Разыменованное приведение* преобразует ссылку на вид данных, который использует признак `Deref`, в ссылку на другой вид. Например, deref coercion может преобразовать `&String` в `&str`, потому что `String` использует признак `Deref`, который возвращает `&str`. Deref coercion - это удобный рычаг, который Ржавчина использует для переменных функций и способов, и работает только для видов данных, выполняющих признак `Deref`. Это происходит самостоятельно , когда мы передаём в качестве переменной функции или способа ссылку на значение определённого вида данных, которое не соответствует виду свойства в определении функции или способа. В итоге последовательности вызовов способа `deref` вид данных, который мы передали, преобразуется в вид, необходимый для свойства.

Разыменованное приведение было добавлено в Ржавчине так, что программистам, пишущим вызовы функций и способов, не нужно добавлять множество явных ссылок и разыменований с помощью использования `&` и `*`. Возможность разыменованного приведения также позволяет писать больше рукописи, которая может работать как с ссылками, так и с умными указателями.

Чтобы увидеть разыменованное приведение в действии, давайте воспользуемся видом данных `MyBox<T>` определённым в приложении 15-8, а также использование `Deref` добавленную в приложении 15-10. Приложение 15-11 показывает определение функции, у которой есть свойство вида данных срез строки:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-11/src/main.rs:here}}
```

<span class="caption">Приложение 15-11: Функция <code>hello</code> имеющая свойство  <code>name</code> вида данных <code>&amp;str</code></span>

Можно вызвать функцию `hello` со срезом строки в качестве переменной, например `hello("Ржавчина");`. Разыменованное приведение делает возможным вызов `hello` со ссылкой на значение вида данных `MyBox<String>`, как показано в приложении 15-12.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-12/src/main.rs:here}}
```

<span class="caption">Приложение 15-12: Вызов <code>hello</code> со ссылкой на значение <code>MyBox&lt;String&gt;</code>, которое работает из-за разыменованного приведения</span>

Здесь мы вызываем функцию `hello` с переменной `&m`, которая является ссылкой на значение `MyBox<String>`. Поскольку мы выполнили сущность `Deref` для `MyBox<T>` в приложении 15-10, то Ржавчина может преобразовать `&MyBox<String>` в `&String` вызывая `deref`. Обычная библиотека предоставляет использование сущности `Deref` для вида данных `String`, которая возвращает срез строки, это описано в пособии API сущности `Deref`. Ржавчина снова вызывает `deref`, чтобы превратить `&String` в `&str`, что соответствует определению функции `hello`.

Если бы Ржавчина не выполнила разыменованное приведение, мы должны были бы написать рукопись в приложении 15-13 вместо рукописи в приложении 15-12 для вызова способа `hello` со значением вида данных `&MyBox<String>`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-13/src/main.rs:here}}
```

<span class="caption">Приложение 15-13: Рукопись, которую нам пришлось бы написать, если бы в Ржавчине не было разыменованного приведения ссылок</span>

Рукопись `(*m)` разыменовывает `MyBox<String>` в `String`. Затем `&` и `[..]` принимают строковый срез `String`, равный всей строке, чтобы соответствовать ярлыке `hello`. Рукопись без разыменованного приведения сложнее читать, писать и понимать со всеми этими знаками. Разыменованное приведение позволяет Ржавчине обрабатывать эти преобразования для нас самостоятельно .

Когда сущность `Deref` определена для задействованных видов, Ржавчина прорассматривает виды данных и будет использовать `Deref::deref` столько раз, сколько необходимо, чтобы получить ссылку, соответствующую виду данных свойства. Количество раз, которое нужно вставить `Deref::deref` определяется во время сборки, поэтому использование разыменованного приведения не имеет накладных расходов во время выполнения!

### Как разыменованное приведение взаимодействует с изменяемостью

Подобно тому, как вы используете сущность `Deref` для переопределения приказчика `*` у неизменяемых ссылок, вы можете использовать сущность `DerefMut` для переопределения приказчика `*` у изменяемых ссылок.

Ржавчина использует разыменованное приведение, когда находит виды данных и выполнения сущностей в трёх случаях:

- Из вида данных `&T` в вид данных `&U` когда верно `T: Deref<Target=U>`
- Из вида данных `&mut T` в вид данных `&mut U` когда верно `T: DerefMut<Target=U>`
- Из вида данных `&mut T` в вид данных `&U` когда верно `T: Deref<Target=U>`

Первые два случая равноценны друг другу, за исключением того, что второй использует изменяемость. В первом случае говорится, что если у вас есть `&T`, а `T` использует `Deref` для некоторого вида данных `U`, вы сможете прозрачно получить `&U`. Во втором случае говорится, что такое же разыменованное приведение происходит и для изменяемых ссылок.

Третий случай хитрее: Ржавчина также приводит изменяемую ссылку к неизменяемой. Но обратное *не* представляется возможным: неизменяемые ссылки никогда не приводятся к изменяемым ссылкам. Из-за правил заимствования, если у вас есть изменяемая ссылка, эта изменяемая ссылка должна быть единственной ссылкой на данные (в противном случае программа не будет собираться). Преобразование одной изменяемой ссылки в неизменяемую ссылку никогда не нарушит правила заимствования. Преобразование неизменяемой ссылки в изменяемую ссылку потребует наличия только одной неизменяемой ссылки на эти данные, и правила заимствования не заверяют этого. Следовательно, Ржавчина не может сделать предположение, что преобразование неизменяемой ссылки в изменяемую ссылку возможно.


[“Использование сущности для вида данных”]: ch10-02-traits.html#implementing-a-trait-on-a-type
["Using Tuple Structs without Named Fields to Create Different Types"]: ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types