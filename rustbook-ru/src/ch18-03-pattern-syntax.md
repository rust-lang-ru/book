## Правила написания образцов

В этом разделе мы рассмотрим все виды данных допустимых правил написания в образцах и расскажем, когда и для чего вам может понадобиться каждый из них.

### Сопоставление с записью

Как мы уже видели в главе 6, можно сопоставлять образцы с записями напрямую. В следующем рукописи есть несколько примеров:

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-01-literals/src/main.rs:here}}
```

Эта рукопись выводит `one`, потому что значение в `x` равно 1. Данные правила написания полезны, когда вы хотите, чтобы Ваша рукопись предприняла действие, если она получает определенное значение.

### Сопоставление именованных переменных

Именованные переменные - это неопровержимые (irrefutable) образцы, которые соответствуют любому значению и мы использовали их много раз в книге. Однако при использовании именованных переменных в выражениях `match` возникает сложность. Поскольку `match` начинает новую область видимости, то переменные, объявленные как часть образца данных внутри выражения `match`, будут затенять переменные с тем же именем вне устройства `match` как и в случае со всеми переменными. В приложении 18-11 мы объявляем переменную с именем `x` со значением `Some(5)` и переменную `y` со значением `10`. Затем мы создаём выражение `match` для значения `x`. Посмотрите на образцы в ветках, `println!` в конце и попытайтесь выяснить, какая рукопись будет выведена прежде чем запускать её или читать дальше.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-11/src/main.rs:here}}
```

<span class="caption">Приложение 18-11: Выражение <code>match</code> с веткой, которая добавляет затенённую переменную <code>y</code></span>

Давайте рассмотрим, что происходит, когда используется выражение `match`. Образец данных в первой ветке не соответствует определённому значению `x`, поэтому выполнение продолжается.

Образец данных во второй ветке вводит новую переменную с именем `y`, которая будет соответствовать любому значению в `Some`. Поскольку мы находимся в новой области видимости внутри выражения `match`, это новая переменная `y`, а не `y` которую мы объявили в начале со значением 10. Эта новая привязка `y` будет соответствовать любому значению из `Some`, которое находится в `x`. Следовательно, эта новая `y` связывается с внутренним значением `Some` из переменной `x`. Этим значением является `5`, поэтому выражение для этой ветки выполняется и выводит `Matched, y = 5`.

Если бы `x` было значением `None` вместо `Some(5)`, то образцы в первых двух ветках не совпали бы, поэтому значение соответствовало бы подчёркиванию. Мы не ввели переменную `x` в образце ветки со знаком подчёркивания, поэтому `x` в выражении все ещё является внешней переменной `x`, которая не была затенена. В этом гипотетическом случае совпадение `match` выведет `Default case, x = None`.

Когда выражение `match` завершается, заканчивается его область видимости как и область действия внутренней переменной `y`. Последний `println!` выводит `at the end: x = Some(5), y = 10`.

Чтобы создать выражение `match`, которое сравнивает значения внешних `x` и `y`, вместо введения затенённой переменной нужно использовать условие в сопоставлении образца. Мы поговорим про условие в сопоставлении образца позже в разделе [“Дополнительные условия в сопоставлении образца”](#extra-conditionals-with-match-guards)<!--  -->.

### объединение образцов

В выражениях `match` можно сравнивать сразу с несколькими образцами данных, используя правила написания `|`, который является приказчиком образца *or*. Например, в следующем примере мы сопоставляем значение `x` с ветвями match, первая из которых содержит приказчик *or*, так что если значение `x` совпадёт с любым из значений в этой ветви, то будет выполнен её рукопись:

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-02-multiple-patterns/src/main.rs:here}}
```

Будет выведено `one or two`.

### Сопоставление рядов с помощью `..=`

Правила написания `..=` позволяют нам выполнять сравнение с рядом значений. В следующем рукописи, когда в образце найдётся совпадение с любым из значений заданного ряда, будет выполнена эта ветка:

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-03-ranges/src/main.rs:here}}
```

Если `x` равен 1, 2, 3, 4 или 5, то совпадение будет достигнуто в первой ветке. Эти правил написания более удобно при указании нескольких значений для сравнения, чем использование приказчика `|` для определения этой же мысли; если бы мы решили использовать `|`, нам пришлось бы написать `1 | 2 | 3 | 4 | 5`. Указание ряда намного короче, особенно если мы хотим подобрать, скажем, любое число от 1 до 1 000!

Сборщик проверяет, что ряд не является пустым во время сборки, и поскольку единственными видами данных, для которых Ржавчина может определить, пуст ряд или нет, являются `char` и числовые значения, ряды допускаются только с числовыми или `char` значениями.

Вот пример использования рядов значений `char`:

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-04-ranges-of-char/src/main.rs:here}}
```

Ржавчина может сообщить, что `'c'` находится в ряде первого образца данных и вывести `early ASCII letter`.

### Разъединение для получения значений

Мы также можем использовать образцы для разъединения стопок, перечислений и упорядоченных рядов, чтобы использовать разные части этих значений. Давайте пройдёмся по каждому исходу.

#### Разъединение стопки

В приложении 18-12 показана стопка `Point` с двумя полями `x` и `y`, которые мы можем разделить, используя образец с указанием `let`.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-12/src/main.rs}}
```

<span class="caption">Приложение 18-12: Разбиение полей стопки в отдельные переменные</span>

Эта рукопись создаёт переменные `a` и `b` , которые сопоставляются значениям полей `x` и `y` стопки `p` . Этот пример показывает, что имена переменных в образце не обязательно должны совпадать с именами полей стопки. Однако обычно имена переменных сопоставляются с именами полей, чтобы было легче запомнить, какие переменные взяты из каких полей. Из-за этого, а также из-за того, что строчка `let Point { x: x, y: y } = p;` содержит много повторения, в Ржавчине ввели особое сокращение для образцов, соответствующих полям стопки: вам нужно только указать имя поля стопки, и тогда переменные, созданные из образца, будут иметь те же имена. Рукопись в приложении 18-13 подобен рукописи в Приложении 18-12, но в образце `let` создаются переменные `x` и `y`, вместо `a` и `b` .

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-13/src/main.rs}}
```

<span class="caption">Приложение 18-13: Разъединение полей стопки с использованием сокращённой записи</span>

Эта рукопись создаёт переменные `x` и `y`, которые соответствуют полям `x` и `y` из переменной `p`. В итоге переменные `x` и `y` содержат значения из стопки `p`.

А ещё, используя записанные значения в образце, мы можем разъединять, не создавая переменные для всех полей. Это даёт возможность, проверяя одни поля на соответствие определенным значениям, создавать переменные для разъединения других.

В приложении 18-14 показано выражение `match`, которое разделяет значения `Point` на три случая: точки, которые лежат непосредственно на оси `x` (что верно, когда `y = 0`), на оси `y` (`x = 0`) или ни то, ни другое.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-14/src/main.rs:here}}
```

<span class="caption">Приложение 18-14: Разъединение и сопоставление с записями в одном образце</span>

Первая ветвь будет соответствовать любой точке, лежащей на оси `x`, если значение поля `y` будет соответствовать записи `0`. Образец данных по-прежнему создаёт переменную `x`, которую мы сможем использовать в рукописи этой ветви.

Подобно, вторая ветвь совпадёт с любой точкой на оси `y`, в случае, если значение поля `x` будет равно `0`, а для значения поля `y` будет создана переменная `y`. Третья ветвь не содержит никаких записей, поэтому она соответствует любому другому `Point` и создаёт переменные как для поля `x`, так и для поля `y`.

В этом примере значение `p` совпадает по второй ветке, так как `x` содержит значение 0, поэтому эта рукопись будет выводить `On the y axis at 7`.

Помните, что выражение `match` перестаёт проверять следующие ветви, как только оно находит первый совпадающий образец данных, поэтому, даже если `Point { x: 0, y: 0}` находится на оси `x` и оси `y`, эта рукопись будет выводить только `On the x axis at 0` .

#### Разъединение перечислений

Мы уже разъединили перечисления в книге (см., например, приложение 6-5 Главы 6), но<br>не обсуждали явно, что образец данных для разъединения перечисления должен соответствовать способу объявления данных, хранящихся в перечислении. Например, в приложении 18-15 мы используем перечисление `Message` из приложения 6-2 и пишем <code>match</code> с образцами данных, которые будут разъединять каждое внутреннее значение.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-15/src/main.rs}}
```

<span class="caption">Приложение 18-15: Разъединение исходов перечисления, содержащих разные виды данных значений</span>

Эта рукопись выведет `Change the color to red 0, green 160, and blue 255`. Попробуйте изменить значение переменной `msg`, чтобы увидеть выполнение рукописи в других ветках.

Для исходов перечисления без каких-либо данных, вроде `Message::Quit`, мы не можем разъединять значение, которого нет. Мы можем сопоставить только буквальное значение `Message::Quit` в этом образце, но без переменных.

Для исходов перечисления похожих на стопки, таких как `Message::Move`, можно использовать образец данных, подобный образцу данных, который мы указываем для сопоставления стопок. После имени исхода мы помещаем узорчатые скобки и затем перечисляем поля именами переменных. Таким образом мы разделяем отрывки, которые будут использоваться в рукописи этой ветки. Здесь мы используем сокращённую разновидность, как в приложении 18-13.

Для исходов перечисления, подобных упорядоченному ряду, вроде `Message::Write`, который содержит упорядоченный ряд с одной переменной и `Message::ChangeColor`, содержащему упорядоченный ряд с тремя переменными, образец данных подобен тому, который мы указываем для сопоставления упорядоченных рядов. Количество переменных в образце должно соответствовать количеству переменных в исходе, который мы сопоставляем.

#### Разъединение вложенных стопок и перечислений

До сих пор все наши примеры сопоставляли стопки или перечисления на один уровень глубины, но сопоставление может работать и с вложенными переменными! Например, мы можем повторно согласовать рукопись в приложении 18-15 для поддержки цветов RGB и HSV в сообщении `ChangeColor` , как показано в приложении 18-16.

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-16/src/main.rs}}
```

<span class="caption">Приложение 18-16: Сопоставление со вложенными перечислениями</span>

Образец данных первой ветки в выражении `match` соответствует исходу перечисления `Message::ChangeColor`, который содержит исход `Color::Rgb`; затем образец данных привязывается к трём внутренними значениями `i32`. Образец данных второй ветки также соответствует исходу перечисления `Message::ChangeColor`, но внутреннее перечисление соответствует исходу `Color::Hsv`. Мы можем указать эти сложные условия в одном выражении `match`, даже если задействованы два перечисления.

#### Разъединение стопок и упорядоченных рядов

Можно смешивать, сопоставлять и вкладывать образцы разъединения ещё более сложными способами. В следующем примере показана сложная разъединение, где мы вкладываем стопки и упорядоченные ряды внутрь упорядоченного ряда и разъединим из него все простые значения:

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-05-destructuring-structs-and-tuples/src/main.rs:here}}
```

Эта рукопись позволяет нам разбивать сложные виды данных на составные части, чтобы мы могли использовать нужным нас значения по отдельности.

Разъединение с помощью образцов - это удобный способ использования отрывков значений, таких как как значение из каждого поля в стопке, по отдельности друг от друга.

### Пренебрежение значений в образце

Вы видели, что иногда полезно пренебрегать значения в образце, например в последней ветке `match`, чтобы получить ветку, обрабатывающую любые значения, которая на самом деле ничего не делает, но учитывает все оставшиеся возможные значения. Есть несколько способов пренебрегать целые значения или части значений в образце: используя образец данных `_` (который вы видели), используя образец данных `_` внутри другого образца, используя имя, начинающееся с подчёркивания, либо используя `..`, чтобы пренебрегать оставшиеся части значения. Давайте рассмотрим, как и зачем использовать каждый из этих образцов.

#### Пренебрежение всего значения с помощью образца `_`

Мы использовали подчёркивание (`_`) в качестве образца данных подстановочного знака (wildcard), который будет сопоставляться с любом значением, но не будет привязываться к этому значению. Это особенно удобно в последней ветке выражения <code>match</code>, но мы также можем использовать его в любом образце, в том числе в свойствах функции, как показано в приложении 18-17.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-17/src/main.rs}}
```

<span class="caption">Приложение 18-15: Использование <code>_</code> в ярлыке функции</span>

Эта рукопись полностью пренебрегает значением `3`, переданным в качестве первой переменной, и отправит на вывод `This code only uses the y parameter: 4`.

В большинстве случаев, когда вам больше не нужен какое-то из свойств функции, вы можете изменить её ярлык, убрав неиспользуемый свойство. Пренебрежение свойства функции может быть особенно полезно в случаях когда, например, вы используете сущность с определённой ярлыком, но тело функции в вашем выполнении не нуждается в одном из свойств. В таком случае сборщик не будет выдавать предупреждения о неиспользуемых свойствах функции, как это было бы, если бы вы указали имя свойства.

#### Пренебрежение частей значения с помощью вложенного `_`

Также, `_` можно использовать внутри образцов, чтобы пренебречь какой-либо частью значения, например, когда мы хотим проверить только определённую подробность, а остальные свойства нам не понадобятся в рукописи, которую нужно выполнить. В приложении 18-18 показана рукопись, ответственная за управление значениями настроек. Согласно бизнес-требованиям, пользователь не может изменить установленное значение свойства, но может удалить его и задать ему новое значение, если на данное мгновение оно отсутствует.

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-18/src/main.rs:here}}
```

<span class="caption">Приложение 18-18: Использование подчёркивания в образцах, соответствующих исходам <code>Some</code>, когда нам не нужно использовать значение внутри <code>Some</code></span>

Эта рукопись будет выводить `Can't overwrite an existing customized value`, а затем `setting is Some(5)`. В первой ветке нам не нужно сопоставлять или использовать значения внутри исхода `Some`, но нам нужно проверить случай, когда `setting_value` и `new_setting_value` являются исходом `Some`. В этом случае мы выводим причину, почему мы не меняем значение `setting_value` и оно не меняется.

Во всех других случаях (если либо `setting_value`, либо `new_setting_value` являются исходом `None`), выраженных образцом `_` во второй ветке, мы хотим, чтобы `new_setting_value` стало равно `setting_value`.

Мы также можем использовать подчёркивание в нескольких местах в одном образце, чтобы пренебрегать определенные значения. Приложение 18-19 показывает пример пренебрежения второго и четвёртого значения в упорядоченном ряде из пяти переменных.

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-19/src/main.rs:here}}
```

<span class="caption">Приложение 18-19: Пренебрежение нескольких частей упорядоченного ряда</span>

Эта рукопись выведет `Some numbers: 2, 8, 32`, а значения 4 и 16 будут пренебрежены.

#### Пренебрежение неиспользуемой переменной, начинающейся с знака `_` в имени

Если вы создаёте переменную, но нигде её не используете, Ржавчина обычно выдаёт предупреждение, потому что неиспользуемая переменная может быть ошибкой. Но иногда полезно создать переменную, которую вы пока не используете, например, когда вы создаёте протовид или только начинаете дело. В этой случае вы можете сказать Ржавчине не предупреждать вас о неиспользуемой переменной, начав имя переменной с подчёркивания. В приложении 18-20 мы создаём две неиспользуемые переменные, но когда мы собираем такую рукопись, мы должны получить предупреждение только об одной из них.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-20/src/main.rs}}
```

<span class="caption">Приложение 18-20: Начинаем имя переменной с подчёркивания, чтобы не получить предупреждения о неиспользованных переменных</span>

Здесь мы получаем предупреждение о том, что не используем переменную `y`, но мы не получаем предупреждения о неиспользовании переменной`_x`.

Обратите внимание, что есть небольшая разница между использованием только `_` и использованием имени, начинающегося с подчёркивания. Правила написания `_x ` по-прежнему привязывают значение к переменной, тогда как `_` не привязывает ничего. В приложении 18-21 представлена ошибка, показывающая, в каком случае это различие имеет значение.

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-21/src/main.rs:here}}
```

<span class="caption">Приложение 18-21: Неиспользуемая переменная, начинающаяся с подчёркивания, по-прежнему привязывает значение, что может привести к смене владельца значения</span>

Мы получим ошибку, поскольку значение `s` все равно будет перемещено в `_s`, что не позволит нам больше воспользоваться `s`. Однако использование подчёркивания само по себе никогда не приводит к привязке к значению. Приложение 18-22 собирается без ошибок, поскольку `s` не будет перемещён в `_`.

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-22/src/main.rs:here}}
```

<span class="caption">Приложение 18-22. Использование подчёркивания не привязывает значение</span>

Эта рукопись работает правильно, потому что мы никогда не привязываем `s` к чему либо; оно не перемещается.

#### Пренебрежение оставшихся частей значения с помощью `..`

Со значениями, которые имеют много частей, можно использовать правила написания `..`, чтобы использовать только некоторые части и пренебрегать остальные, избегая необходимости перечислять подчёркивания для каждого пренебрегаемого значения. Образец данных `..` пренебрегает любые части значения, которые мы явно не сопоставили в остальной частью образца. В приложении 18-23 мы имеем стопку `Point`, которая содержит координату в трёхмерном пространстве. В выражении `match` мы хотим работать только с координатой `x` и пренебрегать значения полей `y` и `z`.

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-23/src/main.rs:here}}
```

<span class="caption">Приложение 18-21: Пренебрежение полей стопки <code>Point</code> кроме поля <code>x</code> с помощью <code>..</code></span>

Мы перечисляем значение `x` и затем просто включаем образец данных `..`. Это быстрее, чем перечислять `y: _` и `z: _`, особенно когда мы работаем со стопками, которые имеют много полей, в случаях, когда только одно или два поля представляют для нас влечение.

Согласно правил написания `..` раскроется до необходимого количества значений. В приложении 18-24 показано, как использовать `..` с упорядоченным рядом.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-24/src/main.rs}}
```

<span class="caption">Приложение 18-24: Сопоставление только первого и последнего значений в упорядоченном ряде и пренебрежение всех других значений</span>

В этой рукописи первое и последнее значение соответствуют `first` и `last`. Значение `..` будет соответствовать и пренебрегать всё, что находится между ними.

Однако использование `..` должно быть однозначным. Если неясно, какие значения предназначены для сопоставления, а какие следует пренебрегать, Ржавчина выдаст ошибку. В приложении 18-25 показан пример неоднозначного использования `..`, поэтому он не будет собираться.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-25/src/main.rs}}
```

<span class="caption">Приложение 18-25: Попытка использовать <code>..</code> неоднозначным способом</span>

При сборке примера, мы получаем эту ошибку:

```console
{{#include ../listings/ch18-patterns-and-matching/listing-18-25/output.txt}}
```

Ржавчина не может определить, сколько значений в упорядоченном ряде нужно пренебрегать, прежде чем сопоставить значение с `second`, и сколько следующих значений пренебрегать после этого. Эта рукопись может означать, что мы хотим пренебрегать `2`, связать `second` с `4`, а затем пренебрегать `8`, `16` и `32`; или что мы хотим пренебрегать `2` и `4`, связать `second` с `8`, а затем пренебрегать `16` и `32`; и так далее. Имя переменной `second` не означает ничего особенного для Ржавчины, поэтому мы получаем ошибку сборщика, так как использование `..` в двух местах как здесь, является неоднозначным.

### Дополнительные условия приказчика сопоставления (Match Guards)

*Условие сопоставления* (match guard) является дополнительным условием `if`, указанным после образца данных в ветке `match`, которое также должно быть выполнено, чтобы ветка была выбрана. Условия сопоставления полезны для выражения более сложных мыслей, чем позволяет только образец данных.

Условие может использовать переменные, созданные в образце. В приложении 18-26 показан `match`, в котором первая ветка имеет образец данных `Some(x)`, а также имеет условие сопоставления, `if x % 2 == 0` (которое будет истинным, если число чётное).

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-26/src/main.rs:here}}
```

<span class="caption">Приложение 18-26: Добавление условия сопоставления в образец данных</span>

В этом примере будет выведено `The number 4 is even`. Когда `num` сравнивается с образцом в первой ветке, он совпадает, потому что `Some(4)` соответствует `Some(x)`. Затем условие сопоставления проверяет, равен ли 0 остаток от деления `x` на 2 и если это так, то выбирается первая ветка.

Если бы `num` вместо этого было `Some(5)`, условие в сопоставлении первой ветки было бы ложным, потому что остаток от 5 делённый на 2, равен 1, что не равно 0. Ржавчина тогда перешёл бы ко второй ветке, которое совпадает, потому что вторая ветка не имеет условия сопоставления и, следовательно, соответствует любому исходу `Some`.

Невозможно выразить условие `if x % 2 == 0` внутри образца, поэтому условие в сопоставлении даёт нам возможность выразить этот ход мыслей. Недостатком этой дополнительной выразительности является то, что сборщик не пытается проверять полноту, когда задействованы выражения с условием в сопоставлении.

В приложении 18-11 мы упомянули, что можно использовать условия сопоставления для решения наших сбоев затенения образца. Напомним, что внутри образца данных в выражении `match` была создана новая переменная, вместо использования внешней к `match` переменной. Эта новая переменная означала, что мы не могли выполнить сравнение с помощью значения внешней переменной. В приложении 18-27 показано, как мы можем использовать условие сопоставления для решения этих сбоев.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-27/src/main.rs}}
```

<span class="caption">Приложение 18-27. Использование условия сопоставления для проверки на равенство со значением внешней переменной</span>

Эта рукопись теперь выведет `Default case, x = Some(5)`. Образец данных во второй ветке не вводит новую переменную `y`, которая будет затенять внешнюю `y`, это означает, что теперь можно использовать внешнюю переменную `y` в условии сопоставления. Вместо указания образца данных как `Some(y)`, который бы затенял бы внешнюю `y`, мы указываем `Some(n)`. Это создаёт новую переменную `n`, которая ничего не затеняет, так как переменной `n` нет вне устройства `match`.

Условие сопоставления `if n == y` не является образцом и следовательно, не вводит новые переменные. Переменная `y` *и есть* внешняя `y`, а не новая затенённая `y`, и теперь мы можем искать переменную, которая будет иметь то же значение, что и внешняя `y`, путём сравнения `n` и `y`.

Вы также можете использовать приказчик *или* `|` в условии сопоставления, чтобы указать несколько образцов; условие сопоставления будет применяться ко всем образцам. В приложении 18-28 показан приоритет соединения условия сопоставления с образцом, который использует `|`. Важной частью этого примера является то, что условие сопоставления `if y` применяется к `4`, `5`, *и* к `6`, хотя это может выглядеть как будто `if y` относится только к `6`.

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-28/src/main.rs:here}}
```

<span class="caption">Приложение 18-28: Соединение нескольких образцов с условием сопоставления</span>

Условие сопоставления гласит, что ветка совпадает, только если значение `x` равно `4`, `5` или `6`, *и* если `y` равно `true`. Когда эта рукопись выполняется, образец данных первой ветки совпадает, потому что `x` равно `4`, но условие сопоставления `if y` равно false, поэтому первая ветка не выбрана. Рукопись переходит ко второй ветке, которая совпадает, и эта программа выводит `no`. Причина в том, что условие `if` применяется ко всему образцу данных `4 | 5 | 6`, а не только к последнему значению `6`. Другими словами, приоритет условия сопоставления по отношению к образцу данных ведёт себя так:

```text
(4 | 5 | 6) if y => ...
```

а не так:

```text
4 | 5 | (6 if y) => ...
```

После запуска рукописи, старшинство в поведении становится очевидным: если условие сопоставления применялось бы только к конечному значению в списке, указанном с помощью приказчика `|`, то ветка бы совпала и программа вывела бы `yes`.

### Связывание `@`

Приказчик *at* (`@`) позволяет создать переменную, которая содержит значение, одновременно с тем, как мы проверяем, соответствует ли это значение образцу данных. В приложении 18-29 показан пример, в котором мы хотим проверить, что перечисление `Message::Hello` со значением поля `id` находится в ряде `3..=7`. Но мы также хотим привязать такое значение к переменной `id_variable`, чтобы использовать его внутри рукописи данной ветки. Мы могли бы назвать эту переменную `id`, так же как поле, но для этого примера мы будем использовать другое имя.

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-29/src/main.rs:here}}
```

<span class="caption">Приложение 18-29: Использование <code>@</code> для привязывания значения в образце, с одновременной его проверкой</span>

В этом примере будет выведено `Found an id in range: 5`. Указывая `id_variable @` перед рядом `3..=7`, мы захватываем любое значение, попадающее в ряд, одновременно проверяя, что это значение соответствует ряду в образце.

Во второй ветке, где у нас в образце указан только ряд, рукопись этой ветки не имеет переменной, которая содержит действительное значение поля `id`. Значение поля `id` могло бы быть 10, 11 или 12, но рукопись, соответствующую этому образцу данных, не знает, чему оно равно. Рукопись образца не может использовать значение из поля `id`, потому что мы не сохранили значение `id` в переменной.

В последней ветке, где мы указали переменную без ряда, у нас есть значение, доступное для использования в рукописи ветки, в переменной с именем `id`. Причина в том, что мы использовали упрощённый правила написания полей стопки. Но мы не применяли никакого сравнения со значением в поле `id` в этой ветке, как мы это делали в первых двух ветках: любое значение будет соответствовать этому образцу данных.

Использование `@` позволяет проверять значение и сохранять его в переменной в пределах одного образца.

## Итоги

Образцы Ржавчина очень помогают различать разные виды данных. При использовании их в выражениях `match`, Ржавчина заверяет, что ваши образцы охватывают все возможные значения, потому что иначе ваша программа не собирается. Образцы в указаниях `let` и свойствах функций делают такие устройства более полезными, позволяя разбивать переменные на более мелкие части, одновременно присваивая их значения переменным. Мы можем создавать простые или сложные образцы в соответствии с нашими потребностями.

Далее, в предпоследней главе книги, мы рассмотрим некоторые продвинутые особенности различных возможностей Ржавчины.
