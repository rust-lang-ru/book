## Пути для ссылки на переменную в дереве разделов

Чтобы указать Ржавчине, где найти то или иное звено (способ/переменная/стопка/сущность и т.д.) в дереве разделов, мы используем `путь` так же, как мы используем `путь` при поиске по файловой системе. Чтобы вызвать способ(функцию), нам нужно знать её `путь`.

Пути бывают двух видов:

- *безусловный путь* - это `полный путь`, начинающийся от корневого раздела ящика. Для содержимого из внешнего ящика `безусловный путь` начинается с имени ящика, а для содержимого из текущего ящика он начинается с ключевого слова `crate`.
- *Относительный путь*  - он начинается с текущего раздела и использует ключевые слова `self`, `super` или ссылку на текущий раздел.

Как *безусловные*, так и *относительные*, `пути` состоят из одного или нескольких двойных разделителей в виде (`::`).

Вернёмся к приложению 7-1, скажем, мы хотим вызвать способ (функцию) `добавить_в_ожидание`. Это то же самое, что спросить: какой *путь* до способа (функции) `добавить_в_ожидание` ? В приложении 7-3 мы сократили содержимое приложения 7-1, удалив некоторые разделы и способы (функции).

Мы покажем два исхода вызова способа (функции) `добавить_в_ожидание` внутри способа `поесть_в_ресторане`, определённом в корневом разделе ящика. Эти `пути` правильные, но остаётся ещё одна неполадка, которая не позволит этому примеру собрать в текущем изложении. Мы скоро объясним почему.

Способ (функция) `поесть_в_ресторане` является частью общедоступного API нашего библиотечного ящика, поэтому мы помечаем её ключевым словом `pub`. В разделе <a data-md-type="raw_html" href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">"Раскрываем закрытые `пути` с помощью ключевого слова `pub`"</a><!-- ignore --> мы рассмотрим более подробно само ключевое слово `pub`.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-03/src/lib.rs}}
```

<span class="caption">Приложение 7-3: Вызов способа (функции) <code>добавить_в_ожидание</code> с использованием `безусловного` и `относительного пути`</span>

При первом вызове способа (функции) `добавить_в_ожидание` из `поесть_в_ресторане` мы используем `безусловный путь`. Способ (функция) `добавить_в_ожидание` определена в том же разделе, что и `поесть_в_ресторане`, и это означает, что мы можем использовать ключевое слово `crate` в начале *безусловного пути*. Затем, мы добавляем каждый из последующих порождённых разделов, пока не составим `путь` до `добавить_в_ожидание`. Вы можете представить себе устройство папок на вашей ОС, которые так же устроены: мы указываем *путь*  `/перед_дома/hosting/добавить_в_ожидание` для запуска приложения `добавить_в_ожидание`. Использование ключевого слова `crate` в качестве корневого раздела ящика подобно использованию `/` для указания корня устройства папок в вашей оболочке.

Второй раз, когда мы вызываем `добавить_в_ожидание` из `поесть_в_ресторане`, мы используем *относительный путь*. `Путь` начинается с имени главного раздела `перед_дома`, определённого на том же этаже дерева разделов, что и `поесть_в_ресторане`. В соответствии с файловой системой, *путь* соответствует `перед_дома/hosting/добавить_в_ожидание`. Начало пути с имени раздела означает, что `путь` является относительным.

Выбор, использовать `относительный` или `безусловный путь`, является решением, которое вы примете на основании вашего ящика или дополнения. Решение должно зависеть от того, с какой вероятностью вы переместите объявление внутреннего содержимого раздела отдельно от или вместе с разделом, использующей это звено раздела. Например, в случае перемещения раздела `перед_дома` и его способ(функцию) `поесть_в_ресторане` в другой раздел с именем `customer_experience`, необходимо будет изменить `безусловный путь` до `добавить_в_ожидание`, но `относительный путь` всё равно будет действителен. Однако, если мы переместим способ (функцию) `поесть_в_ресторане` отдельно в раздел с именем `dining`, то `безусловный путь` вызова `добавить_в_ожидание` останется прежним, но `относительный путь` нужно будет изменить. Мы предпочитаем указывать безусловные пути, потому что это позволяет безошибочно перемещать содержимое разделов и ящиков, в том числе обращения к звеньям содержимого разделов независимо друг от друга.

Давайте попробуем собрать ящик из приложения 7-3 и выяснить, почему он собирается с ошибкой. Ошибка, которую мы получаем, указана в приложении 7-4.

```console
{{#include ../listings/ch07-managing-growing-projects/listing-07-03/output.txt}}
```

<span class="caption">Приложение 7-4: Ошибки сборки при сборке рукописи из приложения 7-3</span>

Сообщения об ошибках говорят о том, что раздел `hosting` является закрытым. Другими словами, у нас указаны правильные `пути` к разделу `hosting` и способу (функции) `добавить_в_ожидание`, но Ржавчина не позволяет нам использовать их, потому что у него нет доступа к закрытым разделам. В Ржавчине все переменные ,способы (функции), стопки, перечисления, разделы и постоянные переменные по умолчанию являются закрытыми (частными) для родительских разделов. Если вы хотите сделать способ (функцию) или вид данных, закрытым, вы помещаете их в раздел, в котором будете использовать данное содержимое.

Переменные в родительском разделе не могут использовать закрытые переменные внутри дочерних разделов, но переменные в дочерних разделах могут использовать переменные у своих разделов-предков. Это связано с тем, что дочерние разделы оборачивают и скрывают подробности своего выполнения, но дочерние разделы могут видеть среду, в которой они определены. Продолжая наше сравнение, подумайте о правилах закрытости как о тыла ресторана: то, что там происходит, скрыто от конечных потребителей ресторана, но офис-управленцы могут видеть и делать всё в ресторане, которым они управляют.

В Ржавчине решили, что устройство разделов должно работать таким образом, чтобы по умолчанию скрывать подробности выполнения. Таким образом, вы знаете, какие части внутренней рукописи вы можете изменять не нарушая работы внешней рукописи. Тем не менее, Ржавчина даёт нам возможность открывать внутренние части рукописи дочерних разделов для внешних разделов-предков, используя ключевое слово `pub`, чтобы сделать переменную или способ общедоступным.

### Раскрываем закрытые пути с помощью ключевого слова `pub`<a id="exposing-paths-with-the-pub-keyword"></a>

Давайте вернёмся к ошибке в приложении 7-4, которая говорит, что раздел `hosting` является закрытым. Мы хотим, чтобы способ (функция) `поесть_в_ресторане` из родительского раздела имела доступ к способу (функции) `добавить_в_ожидание` в дочернем разделе, поэтому мы помечаем раздел `hosting` ключевым словом `pub`, как показано в приложении 7-5.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-05/src/lib.rs}}
```

<span class="caption">Приложение 7-5: Объявление раздела <code>hosting</code> как <code>pub</code> для его использования из <code>поесть_в_ресторане</code></span>

К сожалению, рукопись в приложении 7-5 всё ещё приводит к ошибке, как показано в приложении 7-6.

```console
{{#include ../listings/ch07-managing-growing-projects/listing-07-05/output.txt}}
```

<span class="caption">Приложение 7-6: Ошибки сборки при сборке рукописи в приложении 7-5</span>

Что произошло? Добавление ключевого слова `pub` перед `mod hosting` сделало раздел общедоступным. После этого изменения, если мы можем получить доступ к разделу `перед_дома`, то мы можем получить доступ к разделу `hosting`. Но *содержимое* раздела `hosting` всё ещё является закрытым: превращение раздела в общедоступный раздел не делает его содержимое общедоступным. Ключевое слово `pub` позволяет внешней рукописи в разделах-предках обращаться только к разделу, без доступа ко внутреннему содержимому раздела. Поскольку разделы являются ящиками, мы мало что можем сделать, просто сделав раздел общедоступным; нам нужно пойти дальше и сделать один или несколько переменных в разделе общедоступными.

Ошибки в приложении 7-6 говорят, что способ (функция) `добавить_в_ожидание` является закрытой. Правила закрытости применяются к стопкам, перечислениям, функциям и способам, также как и к разделам.

Давайте также сделаем способ (функцию) `добавить_в_ожидание` общедоступной, добавив ключевое слово `pub` перед её определением, как показано в приложении 7-7.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground,test_harness
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-07/src/lib.rs}}
```

<span class="caption">Приложение 7-7: Добавление ключевого слова <code>pub</code> к <code>mod hosting</code> и к <code>fn добавить_в_ожидание</code> позволяет нам вызывать способ (функцию) из <code>поесть_в_ресторане</code></span>

Теперь рукопись собирается! Чтобы понять, почему добавление ключевого слова `pub` позволяет нам использовать эти `пути` для `добавить_в_ожидание` в соответствии с правилами закрытости, давайте рассмотрим безусловный и относительный пути.

В случае `безусловного пути` мы начинаем с `crate`, корня дерева разделов нашего ящика. Раздел `перед_дома` определён в корневом разделе ящика. Хотя `перед_дома` не является общедоступным, но поскольку способ (функция) `поесть_в_ресторане` определена в том же разделе, что и `перед_дома` (то есть, `поесть_в_ресторане` и `перед_дома` являются потомками одного родителя), мы можем ссылаться на `перед_дома` из `поесть_в_ресторане`. Далее идёт раздел `hosting`, помеченный как `pub`. Мы можем получить доступ к родительскому разделу раздела `hosting`, поэтому мы можем получить доступ и к `hosting`. Наконец, способ (функция) `добавить_в_ожидание` помечена как `pub`, и так как мы можем получить доступ к её родительскому разделу, то вызов этого способа (функции) разрешён!

В случае `относительного пути` ход мыслей такой же как для `безусловного пути`, за исключением первого шага: вместо того, чтобы начинать с корневого раздела ящика, `путь` начинается с `перед_дома`. Раздел `перед_дома` определён в том же разделе, что и `поесть_в_ресторане`, поэтому `относительный путь`, начинающийся с раздела, в котором определена `поесть_в_ресторане` тоже работает. Тогда, по причине того, что `hosting` и `добавить_в_ожидание` помечены как `pub`, остальная часть `пути` работает и вызов этого способа (функции) разрешён!

Если вы собираетесь предоставить общий доступ к своему библиотечному ящику, чтобы другие приложения могли использовать вашу рукопись, ваш общедоступный API — это ваш договор с пользователями вашего ящика, определяющий, как они могут взаимодействовать с вашей рукописью. Есть много соображений по поводу управления изменениями в вашем общедоступном API, чтобы сделать необременительным для людей дополнение из вашего ящика. Эти соображения выходят за рамки этой книги; если вам важен этот вопрос, см. [Руководства по API Ржавчины].

> #### Лучшие опыты для ящиков с исполняемым и библиотечным ящиками
>
> Мы упоминали, что ящик может содержать как корневой раздел исполняемого ящика *src/main.rs*, так и корневой раздел библиотечного ящика *src/lib.rs*, и оба ящика будут по умолчанию иметь имя ящика. Как правило, ящика с таким образцом, содержащим как библиотечный, так и исполняемый ящик, будут иметь достаточно рукописи в исполняемом ящике, чтобы запустить исполняемый файл, который вызывает рукопись из библиотечного ящика. Это позволяет другим делам извлечь выгоду из большей части возможности, предоставляемой ящиком, поскольку рукопись библиотечного ящика можно использовать совместно.
>
> Дерево разделов должно быть определено в *src/lib.rs*. Затем любые общедоступные переменные можно использовать в исполняемом ящике, начав `пути` с имени ящика. Исполняемый ящик становится пользователем библиотечного ящика точно так же, как полностью внешний ящик использует библиотечный ящик: он может использовать только общедоступный API. Это поможет вам разработать хороший API; вы не только составитель, но и пользователь!
>
> В [Главе 12]<!-- ignore --> мы использовали данный опыт согласования рукописи с помощью приложения с окном вывода, которое будет содержать как исполняемый, так и библиотечного ящика.

### Начинаем относительный путь с помощью `super`

Также можно построить `относительные пути`, которые начинаются в родительском разделе, используя ключевое слово `super` в начале `пути`. Это похоже на правила написания начала `пути` файловой системы `..`. Использование `super` позволяет нам сослаться на содержимое, которое, как мы знаем, находится в родительском разделе, что может упростить переупорядочение дерева разделов, чем когда раздел тесно связан с родителем, но родитель может когда-нибудь быть перемещён в другое место в дереве разделов.

Рассмотрим рукопись в приложении 7-8, где рассматривается случай, в котором повар исправляет неправильный заказ и лично приносит его потребителю. Способ (функция) `исправить_неверный_заказr` вызывает способ (функцию) `доставить_заказ`, определённую в родительском разделе, указывая *путь* к `доставить_заказ`, начинающийся с `super`:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground,test_harness
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-08/src/lib.rs}}
```

<span class="caption">Приложение 7-8: Вызов способа (функции) с использованием `относительного пути`, начинающегося с <code>super</code></span>

Способ (функция) `исправить_неверный_заказr` находится в разделе `тыл_дома`, поэтому мы можем использовать `super` для перехода к родительскому разделу из раздела `тыл_дома`, который в этом случае является `crate`, корневым разделом. В этом разделе мы ищем `доставить_заказ` и находим его. Успех! Мы думаем, что раздел `тыл_дома` и способ (функция) `доставить_заказ`, скорее всего, останутся в тех же родственных отношениях друг с другом, и должны будут перемещены вместе, если мы решим повторно согласовать дерево разделов ящика. Поэтому мы использовали `super`, чтобы в будущем у нас было меньше мест для обновления рукописи, если эта рукопись будет перемещена в другой раздел.

### Делаем общедоступными стопки и перечисления

Мы также можем использовать `pub` для обозначения стопок и перечислений как общедоступных, но есть несколько дополнительных подробностей использования `pub` со стопками и перечислениями. Если мы используем `pub` перед определением стопки, мы делаем стопку общедоступной, но поля стопки по-прежнему остаются закрытыми. Мы можем сделать каждое поле общедоступным или нет в каждом определенном случае. В приложении 7-9 мы определили общедоступную стопку `тыл_дома::Поесть` с общедоступным полем `хлеб` и с закрытым полем `сезонный_фрукт`. Это рассчитывает случай в ресторане, когда потребитель может выбрать вид хлеба, который подаётся с едой, а шеф-повар решает какие фрукты сопровождают еду, исходя из того, что сезонно и что есть в наличии. Доступные фрукты быстро меняются, поэтому конечные потребители не могут выбирать фрукты или даже увидеть, какие фрукты они получат.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-09/src/lib.rs}}
```

<span class="caption">Приложение 7-9: Стопки с общедоступными и закрытыми полями</span>

Поскольку поле `хлеб` в стопке `тыл_дома::Поесть` является открытым, то в способе (функции) `поесть_в_ресторане` можно вносить изменения и получать данные из поля `хлеб`, используя точечное наставление. Обратите внимание, что мы не можем использовать поле `сезонный_фрукт` в `поесть_в_ресторане`, потому что `сезонный_фрукт` является закрытым. Попробуйте убрать примечания с последней строки для значения поля `сезонный_фрукт`, чтобы увидеть какую ошибку вы получите!

Также обратите внимание, что поскольку `тыл_дома::Поесть` имеет закрытое поле, то стопка должна предоставить открытый сопряженную способ (функцию), который создаёт образец данных `Поесть` (мы назвали его `лето`). Если `Поесть` не имел бы такого способа (функции), мы бы не могли создать образец данных `Поесть` внутри `поесть_в_ресторане`, потому что мы не смогли бы установить значение закрытого поля `сезонный_фрукт` в способе (функции) `поесть_в_ресторане`.

В отличии от стопки, если мы сделаем общедоступным перечисление, то все его исходы будут общедоступными. Нужно только указать `pub` перед ключевым словом `enum`, как показано в приложении 7-10.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-10/src/lib.rs}}
```

<span class="caption">Приложение 7-10: Определяя перечисление общедоступным, мы делаем все его исходы общедоступными</span>

Поскольку мы сделали общедоступным перечисление `Закуска`, то можно использовать исходы `Суп` и `Салат` в способе (функции) `поесть_в_ресторане`.

Перечисления не очень полезны, если их исходы не являются общедоступными: было бы досадно каждый раз определять все исходы перечисления как `pub`. По этой причине по умолчанию исходы перечислений являются общедоступными. Стопки часто полезны, если их поля не являются общедоступными, поэтому поля стопки следуют общему правилу, согласно которому, всё по умолчанию является закрытым, если не указано `pub`.

Есть ещё один случай с `pub`, который мы не освещали, и это последняя особенность, состоящая из разделов системы: ключевое слово `use`. Мы сначала опишем `use` само по себе, а затем покажем как сочетать `pub` и `use` вместе.


[Руководства по API Ржавчины]: https://rust-lang.github.io/api-руководства/
[Главе 12]: ch12-00-an-io-project.html