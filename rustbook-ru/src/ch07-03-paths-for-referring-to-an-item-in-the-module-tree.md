## Пути для ссылки на переменную в дереве разделов

Чтобы показать Ржавчине, где найти переменную в дереве разделов, мы используем путь так же, как мы используем путь при поиске по файловой системе. Чтобы вызвать функцию, нам нужно знать её путь.

Пути бывают двух видов:

- *безусловный путь* - это полный путь, начинающийся от корневого раздела дополнения; для рукописи из внешнего дополнения безусловный путь начинается с имени дополнения, а для рукописи из текущего дополнения он начинается с записи `crate`.
- *относительный путь* начинается с текущего раздела и использует ключевые слова `self`, `super` или определитель в текущем разделе.

Как безусловные, так и относительные, пути состоят из одного или нескольких определителей, разделённых двойными двоеточиями (`::`).

Вернёмся к приложению 7-1, скажем, мы хотим вызвать функцию `add_to_waitlist`. Это то же самое, что спросить: какой путь у функции `add_to_waitlist`? В приложении 7-3 мы немного упростили рукопись приложения 7-1, удалив некоторые разделы и функции.

Мы покажем два способа вызова функции `add_to_waitlist` из новой функции `eat_at_restaurant`, определённой в корневом разделе дополнения. Эти пути правильные, но остаётся ещё одна неполадка, которая не позволит этому примеру собраться как есть. Мы скоро объясним почему.

Функция `eat_at_restaurant` является частью общедоступного API нашего библиотечного дополнения, поэтому мы помечаем её ключевым словом `pub`. В разделе <a data-md-type="raw_html" href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">"Раскрываем закрытые пути с помощью ключевого слова `pub`"</a><!-- ignore --> мы рассмотрим более подробно `pub`.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-03/src/lib.rs}}
```

<span class="caption">Приложение 7-3: Вызов функции <code>add_to_waitlist</code> с использованием безусловного и относительного пути</span>

При первом вызове функции `add_to_waitlist` из `eat_at_restaurant` мы используем безусловный путь. Функция `add_to_waitlist` определена в том же дополнение, что и `eat_at_restaurant`, и это означает, что мы можем использовать ключевое слово `crate` в начале безусловного пути. Затем мы добавляем каждый из последующих дочерних разделов, пока не составим путь до `add_to_waitlist`. Вы можете представить себе файловую устройство с таким же устройством: мы указываем путь `/front_of_house/hosting/add_to_waitlist` для запуска приложения `add_to_waitlist`; использование имени `crate` в качестве корневого раздела дополнения подобно использованию `/` для указания корня файловой системы в вашей оболочке.

Второй раз, когда мы вызываем `add_to_waitlist` из `eat_at_restaurant`, мы используем относительный путь. Путь начинается с имени раздела `front_of_house`, определённого на том же уровне дерева разделов, что и `eat_at_restaurant`. Для равнозначной файловой системы использовался бы путь `front_of_house/hosting/add_to_waitlist`. Начало пути с имени раздела означает, что путь является относительным.

Выбор, использовать относительный или безусловный путь, является решением, которое вы примете на основании вашего дела. Решение должно зависеть от того, с какой вероятностью вы переместите объявление переменной или способа отдельно от или вместе с рукописью использующей эту переменную или способ. Например, в случае перемещения раздела `front_of_house` и его функции `eat_at_restaurant` в другой раздел с именем `customer_experience`, будет необходимо обновить безусловный путь до `add_to_waitlist`, но относительный путь всё равно будет действителен. Однако, если мы переместим отдельно функцию `eat_at_restaurant` в раздел с именем `dining`, то безусловный путь вызова `add_to_waitlist` останется прежним, а относительный путь нужно будет обновить. Мы предпочитаем указывать безусловные пути, потому что это позволяет проще перемещать определения рукописи и вызовы переменных независимо друг от друга.

Давайте попробуем собрать рукопись из приложения 7-3 и выяснить, почему она ещё не собирается. Ошибка, которую мы получаем, показана в приложении 7-4.

```console
{{#include ../listings/ch07-managing-growing-projects/listing-07-03/output.txt}}
```

<span class="caption">Приложение 7-4: Ошибки сборки при сборке рукописи из приложения 7-3</span>

Сообщения об ошибках говорят о том, что раздел `hosting` является закрытым. Другими словами, у нас указаны правильные пути к разделу `hosting` и функции `add_to_waitlist`, но Ржавчина не позволяет нам использовать их, потому что у него нет доступа к закрытым разделам. В Ржавчине все переменные (функции, способы, стопки, перечисления, разделы и постоянные переменные) по умолчанию являются закрытыми для родительских разделов. Если вы хотите сделать функцию или вид данных, закрытым, вы помещаете их в раздел.

Переменные в родительском разделе не могут использовать закрытые переменные внутри дочерних разделов, но переменные в дочерних разделах могут использовать переменные у своих разделов-предков. Это связано с тем, что дочерние разделы оборачивают и скрывают подробности своего выполнения, но дочерние разделы могут видеть среду, в которой они определены. Продолжая наше сравнение, подумайте о правилах закрытости как о задней части ресторана: то, что там происходит, скрыто от конечных потребителей ресторана, но офис-управленцы могут видеть и делать всё в ресторане, которым они управляют.

В Ржавчине решили, что устройство разделов должно работать таким образом, чтобы по умолчанию скрывать подробности выполнения. Таким образом, вы знаете, какие части внутренней рукописи вы можете изменять не нарушая работы внешней рукописи. Тем не менее, Ржавчина даёт нам возможность открывать внутренние части рукописи дочерних разделов для внешних разделов-предков, используя ключевое слово `pub`, чтобы сделать переменную или способ общедоступным.

### Раскрываем закрытые пути с помощью ключевого слова `pub`<a id="exposing-paths-with-the-pub-keyword"></a>

Давайте вернёмся к ошибке в приложении 7-4, которая говорит, что раздел `hosting` является закрытым. Мы хотим, чтобы функция `eat_at_restaurant` из родительского раздела имела доступ к функции `add_to_waitlist` в дочернем разделе, поэтому мы помечаем раздел `hosting` ключевым словом `pub`, как показано в приложении 7-5.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-05/src/lib.rs}}
```

<span class="caption">Приложение 7-5: Объявление раздела <code>hosting</code> как <code>pub</code> для его использования из <code>eat_at_restaurant</code></span>

К сожалению, рукопись в приложении 7-5 всё ещё приводит к ошибке, как показано в приложении 7-6.

```console
{{#include ../listings/ch07-managing-growing-projects/listing-07-05/output.txt}}
```

<span class="caption">Приложение 7-6: Ошибки сборки при сборке рукописи в приложении 7-5</span>

Что произошло? Добавление ключевого слова `pub` перед `mod hosting` сделало раздел общедоступным. После этого изменения, если мы можем получить доступ к разделу `front_of_house`, то мы можем получить доступ к разделу `hosting`. Но *содержимое* раздела `hosting` всё ещё является закрытым: превращение раздела в общедоступный раздел не делает его содержимое общедоступным. Ключевое слово `pub` позволяет внешней рукописи в разделах-предках обращаться только к разделу, без доступа ко внутренней рукописи. Поскольку разделы являются дополнениями, мы мало что можем сделать, просто сделав раздел общедоступным; нам нужно пойти дальше и сделать один или несколько переменных в разделе общедоступными.

Ошибки в приложении 7-6 говорят, что функция `add_to_waitlist` является закрытой. Правила закрытости применяются к стопкам, перечислениям, функциям и способам, также как и к разделам.

Давайте также сделаем функцию `add_to_waitlist` общедоступной, добавив ключевое слово `pub` перед её определением, как показано в приложении 7-7.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground,test_harness
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-07/src/lib.rs}}
```

<span class="caption">Приложение 7-7: Добавление ключевого слова <code>pub</code> к <code>mod hosting</code> и к <code>fn add_to_waitlist</code> позволяет нам вызывать функцию из <code>eat_at_restaurant</code></span>

Теперь рукопись собирается! Чтобы понять, почему добавление ключевого слова `pub` позволяет нам использовать эти пути для `add_to_waitlist` в соответствии с правилами закрытости, давайте рассмотрим безусловный и относительный пути.

В случае безусловного пути мы начинаем с `crate`, корня дерева разделов нашего дополнения. Раздел `front_of_house` определён в корневом разделе дополнения. Хотя `front_of_house` не является общедоступным, но поскольку функция `eat_at_restaurant` определена в том же разделе, что и `front_of_house` (то есть, `eat_at_restaurant` и `front_of_house` являются потомками одного родителя), мы можем ссылаться на `front_of_house` из `eat_at_restaurant`. Далее идёт раздел `hosting`, помеченный как `pub`. Мы можем получить доступ к родительскому разделу раздела `hosting`, поэтому мы можем получить доступ и к `hosting`. Наконец, функция `add_to_waitlist` помечена как `pub`, и так как мы можем получить доступ к её родительскому разделу, то вызов этой функции разрешён!

В случае относительного пути ход мыслей такой же как для безусловного пути, за исключением первого шага: вместо того, чтобы начинать с корневого раздела дополнения, путь начинается с `front_of_house`. Раздел `front_of_house` определён в том же разделе, что и `eat_at_restaurant`, поэтому относительный путь, начинающийся с раздела, в котором определена `eat_at_restaurant` тоже работает. Тогда, по причине того, что `hosting` и `add_to_waitlist` помечены как `pub`, остальная часть пути работает и вызов этой функции разрешён!

Если вы собираетесь предоставить общий доступ к своему библиотечному дополнениеу, чтобы другие приложения могли использовать вашу рукопись, ваш общедоступный API — это ваш договор с пользователями вашего дополнения, определяющий, как они могут взаимодействовать с вашей рукописью. Есть много соображений по поводу управления изменениями в вашем общедоступном API, чтобы сделать необременительным для людей дополнение от вашего дополнения. Эти соображения выходят за рамки этой книги; если вам важен этот вопрос, см. [The Ржавчина API Guidelines].

> #### Лучшие опыты для дополнений с исполняемым и библиотечным дополнениями
>
> Мы упоминали, что дополнение может содержать как корневой раздел исполняемого дополнения *src/main.rs*, так и корневой раздел библиотечного дополнения *src/lib.rs*, и оба дополнения будут по умолчанию иметь имя дополнения. Как правило, дополнения с таким образцом, содержащим как библиотечный, так и исполняемый дополнение, будут иметь достаточно рукописи в исполняемом дополнение, чтобы запустить исполняемый файл, который вызывает рукопись из библиотечного дополнения. Это позволяет другим делам извлечь выгоду из большей части возможности, предоставляемой дополнением, поскольку рукопись библиотечного дополнения можно использовать совместно.
>
> Дерево разделов должно быть определено в *src/lib.rs*. Затем любые общедоступные переменные можно использовать в исполняемом дополнение, начав пути с имени дополнения. Исполняемый дополнение становится пользователем библиотечного дополнения точно так же, как полностью внешний дополнение использует библиотечное дополнение: он может использовать только общедоступный API. Это поможет вам разработать хороший API; вы не только составитель, но и пользователь!
>
> В [Главе 12]<!-- ignore --> мы использовали данный опыт согласования рукописи с помощью приложения с окном вывода, которое будет содержать как исполняемый, так и библиотечный дополнения.

### Начинаем относительный путь с помощью `super`

Также можно построить относительные пути, которые начинаются в родительском разделе, используя ключевое слово `super` в начале пути. Это похоже на правила написания начала пути файловой системы `..`. Использование `super` позволяет нам сослаться на переменную, который, как мы знаем, находится в родительском разделе, что может упростить переупорядочение дерева разделов, чем когда раздел тесно связан с родителем, но родитель может когда-нибудь быть перемещён в другое место в дереве разделов.

Рассмотрим рукопись в приложении 7-8, где рассчитывается случай, в котором повар исправляет неправильный заказ и лично приносит его потребителю. Функция `fix_incorrect_order` вызывает функцию `deliver_order`, определённую в родительском разделе, указывая путь к `deliver_order`, начинающийся с `super`:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground,test_harness
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-08/src/lib.rs}}
```

<span class="caption">Приложение 7-8: Вызов функции с использованием относительного пути, начинающегося с <code>super</code></span>

Функция `fix_incorrect_order` находится в разделе `back_of_house`, поэтому мы можем использовать `super` для перехода к родительскому разделу раздела `back_of_house`, который в этом случае является `crate`, корневым разделом. В этом разделе мы ищем `deliver_order` и находим его. Успех! Мы думаем, что раздел `back_of_house` и функция `deliver_order`, скорее всего, останутся в тех же родственных отношениях друг с другом, и должны будут перемещены вместе, если мы решим повторно согласовать дерево разделов дополнения. Поэтому мы использовали `super`, чтобы в будущем у нас было меньше мест для обновления рукописи, если эта рукопись будет перемещена в другой раздел.

### Делаем общедоступными стопки и перечисления

Мы также можем использовать `pub` для обозначения стопок и перечислений как общедоступных, но есть несколько дополнительных подробностей использования `pub` со стопками и перечислениями. Если мы используем `pub` перед определением стопки, мы делаем стопку общедоступной, но поля стопки по-прежнему остаются закрытыми. Мы можем сделать каждое поле общедоступным или нет в каждом определенном случае. В приложении 7-9 мы определили общедоступную стопку `back_of_house::Breakfast` с общедоступным полем `toast` и с закрытым полем `seasonal_fruit`. Это рассчитывает случай в ресторане, когда потребитель может выбрать вид хлеба, который подаётся с едой, а шеф-повар решает какие фрукты сопровождают еду, исходя из того, что сезонно и что есть в наличии. Доступные фрукты быстро меняются, поэтому конечные потребители не могут выбирать фрукты или даже увидеть, какие фрукты они получат.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-09/src/lib.rs}}
```

<span class="caption">Приложение 7-9: Стопки с общедоступными и закрытыми полями</span>

Поскольку поле `toast` в стопке `back_of_house::Breakfast` является открытым, то в функции `eat_at_restaurant` можно вносить изменения и получать данные из поля `toast`, используя точечное наставление. Обратите внимание, что мы не можем использовать поле `seasonal_fruit` в `eat_at_restaurant`, потому что `seasonal_fruit` является закрытым. Попробуйте убрать примечания с последней строки для значения поля `seasonal_fruit`, чтобы увидеть какую ошибку вы получите!

Также обратите внимание, что поскольку `back_of_house::Breakfast` имеет закрытое поле, то стопка должна предоставить открытую сопряженную функцию, которая создаёт образец данных `Breakfast` (мы назвали её `summer`). Если `Breakfast` не имел бы такой функции, мы бы не могли создать образец данных `Breakfast` внутри `eat_at_restaurant`, потому что мы не смогли бы установить значение закрытого поля `seasonal_fruit` в функции `eat_at_restaurant`.

В отличии от стопки, если мы сделаем общедоступным перечисление, то все его исходы будут общедоступными. Нужно только указать `pub` перед ключевым словом `enum`, как показано в приложении 7-10.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-10/src/lib.rs}}
```

<span class="caption">Приложение 7-10: Определяя перечисление общедоступным, мы делаем все его исходы общедоступными</span>

Поскольку мы сделали общедоступным перечисление `Appetizer`, то можно использовать исходы `Soup` и `Salad` в функции `eat_at_restaurant`.

Перечисления не очень полезны, если их исходы не являются общедоступными: было бы досадно каждый раз определять все исходы перечисления как `pub`. По этой причине по умолчанию исходы перечислений являются общедоступными. Стопки часто полезны, если их поля не являются общедоступными, поэтому поля стопки следуют общему правилу, согласно которому, всё по умолчанию является закрытым, если не указано `pub`.

Есть ещё один случай с `pub`, который мы не освещали, и это последняя особенность, состоящая из разделов системы: ключевое слово `use`. Мы сначала опишем `use` само по себе, а затем покажем как сочетать `pub` и `use` вместе.


[The Ржавчина API Guidelines]: https://rust-lang.github.io/api-guidelines/
[Главе 12]: ch12-00-an-io-project.html