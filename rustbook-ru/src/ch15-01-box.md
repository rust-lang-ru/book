## Использование `Box<T>` для ссылки на данные в куче

Наиболее простой умный указатель - это *box*, чей вид данных записывается как `Box<T>`. Такие переменные позволяют хранить данные в куче, а не в обойме. То, что остаётся в обойме, является указателем на данные в куче. Обратитесь к Главе 4, чтобы рассмотреть разницу между обоймой и кучей.

У Box нет неполадок с производительностью, кроме хранения данных в куче вместо обоймы. Но он также и не имеет множества дополнительных возможностей. Вы будете использовать его чаще всего в следующих случаях:

- Когда у вас есть вид данных, размер которого невозможно определить во время сборки, а вы хотите использовать значение этого вида в среде, требующем точного размера;
- Когда у вас есть большой размер данных и вы хотите передать владение, но при этом быть уверенным, что данные не будут воспроизведены;
- Когда вы хотите получить значение во владение и вас важно только то, что оно относится к виду данных, выполняющему определённую сущность, а не то, является ли оно значением какого-то определенного вида данных;

Мы рассмотрим первый случай в разделе [“Использование рекурсивных видов данных с помощью Boxes”](#Использование-рекурсивных-видов-данных-с-помощью-boxes)<!-- ignore -->. Во втором случае, передача владения на большой размер данных может занять много времени, потому что данные создают повтор через обойму. Для повышения производительности в этой случае, мы можем хранить большое количество данных в куче с помощью Box. Затем только небольшое количество данных указателя воспроизводится в обойме, в то время как данные, на которые он ссылается, остаются в одном месте кучи. Третий случай известен как *сущность предмет* (trait object) и глава 18 посвящает целый раздел ["Использование сущность предметов, которые допускают значения разных видов данных"]<!-- ignore --> только этой теме. Итак, то, что вы узнаете здесь, вы примените снова в Главе 18!

### Использование `Box<T>` для хранения данных в куче

Прежде чем мы обсудим этот способ использования `Box<T>`, мы рассмотрим правила написания и то, как взаимодействовать со значениями, хранящимися в `Box<T>`.

В приложении 15-1 показано, как использовать поле для хранения значения `i32` в куче:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-01/src/main.rs}}
```

<span class="caption">Приложение 15-1: Сохранение значения <code>i32</code> в куче с использованием box</span>

Мы объявляем переменную `b` со значением `Box`, указывающим на Число `5`, размещённое в куче. Эта приложение выведет `b = 5`; в этом случае мы получаем доступ к данным в box так же, как если бы эти данные находились в обойме. Как и любое другое значение, когда box выйдет из области видимости, как `b` в конце `main`, он будет удалён. Освобождение происходит как для box (хранящегося в обойме), так и для данных, на которые он указывает (хранящихся в куче).

Размещать одиночные значения в куче не слишком целесообразно, поэтому вряд ли вы будете часто использовать box'ы таким образом. В большинстве случаев более уместно размещать такие значения, как `i32`, в обойме, где они и сохраняются по умолчанию. Давайте рассмотрим случай, когда box позволяет нам определить виды данных, которые мы не могли бы иметь, если бы у нас не было box.

### Использование рекурсивных видов данных с помощью Boxes

Значение *рекурсивного вида* может иметь другое значение такого же вида данных как часть себя. Рекурсивные виды представляют собой неполадку, поскольку во время сборки Ржавчина должна знать, сколько места занимает вид. Однако вложенность значений рекурсивных видов предположительно может продолжаться бесконечно, поэтому Ржавчина не может определить, сколько места потребуется. Поскольку box имеет известный размер, мы можем включить рекурсивные виды, добавив box в определение рекурсивного вида.

В качестве примера рекурсивного вида рассмотрим *cons список*. Это вид данных, часто встречающийся в полезных языках программирования. Вид cons список, который мы определим, достаточно прост, за исключением наличия рекурсии; поэтому подходы, заложенные в примере, с которым мы будем работать, пригодятся вам в любом более сложной случае, связанной с рекурсивными видами.

#### Больше сведений о cons списке

*cons список* - это стопки данных из языка программирования Lisp и его диалектов, представляющая собой набор вложенных пар и являющаяся Lisp-исполнением связного списка. Его название происходит от функции `cons` (сокращение от "construct function") в Lisp, которая создает пару из двух своих переменных. Вызывая `cons` для пары, которая состоит из некоторого значения и другой пары, мы можем выстраивать списки cons, состоящие из рекурсивных пар.

Вот, пример cons список в виде псевдорукописи, содержащий список 1, 2, 3, где каждая пара заключена в круглые скобки:

```text
(1, (2, (3, Nil)))
```

Каждая переменная в cons списке содержит две вещи: значение текущей переменной и следующая переменная. Последняя переменная в списке содержит только значение, называемое `Nil` без следующей переменной. Cons список создаётся путём рекурсивного вызова функции `cons`. Каноничное имя для обозначения основного случая рекурсии - `Nil`. Обратите внимание, что это не то же самое, что понятие “пустота/null” или “nil” из Главы 6, которая является недействительным или отсутствующим значением.

Cons список не является часто используемым видом данных в Ржавчине. В большинстве случаев, когда вам нужен список переменных при использовании Ржавчины, лучше использовать `Vec<T>`. Другие, более сложные рекурсивные виды данных *полезны* в определённых случаях, но благодаря тому, что в этой главе мы начнём с cons список, мы сможем выяснить, как box позволяет нам определить рекурсивный вид данных без особого напряжения.

Приложение 15-2 содержит объявление перечисления cons списка. Обратите внимание, что эта рукопись не будет собираться, потому что вид данных `Список` не имеет известного размера, что мы и выясним.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-02/src/main.rs:here}}
```

<span class="caption">Приложение 15-2: Первая попытка определить перечисление в качестве стопки данных cons список, состоящей из <code>i32</code> значений.</span>

> Примечание: В данном примере мы выполняем cons список, который содержит только значения `i32`. Мы могли бы использовать его с помощью generics, о которых мы говорили в главе 10, чтобы определить вид cons список, который мог бы хранить значения любого вида данных.

Использование вида данных `Список` для хранения списка `1, 2, 3` будет выглядеть как рукопись в приложении 15-3:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-03/src/main.rs:here}}
```

<span class="caption">Приложение 15-3: Использование перечисления <code>Список</code> для хранения списка <code>1, 2, 3</code></span>

Первое значение `Cons` содержит `1` и другой `Список`. Это значение `Список` является следующим значением `Cons`, которое содержит `2` и другой `Список`. Это значение `Список` является ещё один значением `Cons`, которое содержит `3` и значение `Список`, которое наконец является `Nil`, не рекурсивным исходом, сообщающим об окончании списка.

Если мы попытаемся собрать рукопись в приложении 15-3, мы получим ошибку, показанную в приложении 15-4:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-03/output.txt}}
```

<span class="caption">Приложение 15-4: Ошибка, которую мы получаем при попытке определить рекурсивное перечисление</span>

Ошибка говорит о том, что этот вид данных "имеет бесконечный размер". Причина в том, что мы определили `Список` в виде данных, которая является рекурсивной: она непосредственно хранит другое значение своего собственного вида данных. В итоге Ржавчина не может определить, сколько места ему нужно для хранения значения `Список`. Давайте разберёмся, почему мы получаем эту ошибку. Сначала мы рассмотрим, как Ржавчина решает, сколько места ему нужно для хранения значения нерекурсивного вида.

#### Вычисление размера нерекурсивного вида

Вспомните перечисление `Сообщение` определённое в приложении 6-2, когда обсуждали объявление enum  в главе 6:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-02/src/main.rs:here}}
```

Чтобы определить, сколько памяти выделять под значение `Сообщение`, Ржавчина проходит каждый из исходов, чтобы увидеть, какой исход требует наибольшее количество памяти. Ржавчина видит, что для `Сообщение::Выход` не требуется места, `Сообщение::Move` хватает места для хранения двух значений `i32` и т.д. Так как будет использоваться только один исход, то наибольшее пространство, которое потребуется для значения `Сообщение`, это пространство, которое потребуется для хранения самого большого из исходов перечисления.

Сравните это с тем, что происходит, когда Ржавчина пытается определить, сколько места необходимо рекурсивному виду, такому как перечисление `Список` в приложении 15-2. Сборщик смотрит на исход `Cons`, который содержит значение вида данных `i32` и значение вида данных `Список`. Следовательно, `Cons` нужно пространство, равное размеру `i32` дополнительно размер `Список`. Чтобы выяснить, сколько памяти необходимо виду `Список`, сборщик смотрит на исходы, начиная с `Cons`. Исход `Cons` содержит значение вида данных `i32` и значение вида данных `Список`, и этот этап продолжается бесконечно, как показано на рисунке 15-1.

 <img alt="Бесконечный список Cons" src="img/trpl15-01.svg" class="center" style="width: 50%;">

<span class="caption">Рисунок 15-1: Бесконечный <code>Список</code>, состоящий из нескончаемого числа исходов <code>Cons</code></span>

#### Использование `Box<T>` для получения рекурсивного вида с известным размером

Поскольку Ржавчина не может определить, сколько места нужно выделить для видов с рекурсивным изложением, сборщик выдаёт ошибку с этим полезным предложением:

<!-- manual-regeneration
after doing automatic regeneration, look at listings/ch15-smart-pointers/listing-15-03/output.txt and copy the relevant line
-->

```text
help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Список` representable
  |
2 |     Cons(i32, Box<Список>),
  |               ++++    +
```

В данном предложении "перенаправление" означает, что вместо того, чтобы непосредственно хранить само значение, мы должны изменить вид данных, так чтобы хранить его косвенно - хранить указатель на это значение.

Поскольку `Box<T>` является указателем, Ржавчина всегда знает, сколько места нужно `Box<T>`: размер указателя не меняется в зависимости от размера данных, на которые он указывает. Это означает, что мы можем поместить `Box<T>` внутрь образца данных `Cons` вместо значения `Список` напрямую. `Box<T>` будет указывать на значение очередного `Список`, который будет находиться в куче, а не внутри образца данных `Cons`. Мировоззренческо у нас все ещё есть список, созданный из списков, содержащих другие списки, но это изложение теперь больше похоже на размещение переменных рядом друг с другом, а не внутри друг друга.

Мы можем изменить изложение перечисления `Список` в приложении 15-2 и использование `Список` в приложении 15-3 на рукопись из приложения 15-5, которая будет собрана:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-05/src/main.rs}}
```

<span class="caption">Приложение 15-5: Изложение перечисления <code>Список</code>, которое использует <code>Box&lt;T&gt;</code> для того, чтобы размер, выделяемый в ОЗУ можно было определить</span>

`Cons` требует размер `i32` и дополнительно место для хранения данных указателя `Box`. `Nil` не хранит никаких значений, поэтому ему нужно меньше места, чем `Cons`. Теперь мы знаем, что любое значение `Список` займёт размер : `i32` и дополнительно область памяти для размещения данных указателя `Box`. Используя `Box`, мы разорвали бесконечную рекурсивную цепочку, поэтому сборщик может определить размер, необходимый для хранения значения `Список`. На рисунке 15-2 показано, как теперь выглядит `Cons`.

 <img alt="Бесконечный список Cons" src="img/trpl15-02.svg" class="center" style="width: 50%;">

<span class="caption">Рисунок 15-2: <code>Список</code>, который не является бесконечно большим, потому что <code>Cons</code> хранит <code>Box</code>.</span>

`Box-ы` обеспечивают только перенаправление и выделение в куче. У них нет никаких других особых возможностей, подобных тем, которые мы увидим у других видов умных указателей. У них также нет накладных расходов на производительность, которые несут эти особые возможности, поэтому они могут быть полезны в таких случаях, как cons список, где перенаправление - единственная функция, которая нам нужна. В главе 18 мы также рассмотрим другие случаи использования `Box`.

Вид данных `Box<T>` является умным указателем, поскольку он использует сущность `Deref`, которая позволяет обрабатывать значения `Box<T>` как ссылки. Когда значение `Box<T>` выходит из области видимости, данные кучи, на которые указывает `Box`, также очищаются благодаря использованию сущности `Drop`. Эти две сущности будут ещё более значимыми для возможностей, предоставляемых другими видами умных указателей, которые мы обсудим в оставшейся части этой Главы. Давайте рассмотрим эти две сущности более подробно.


["Использование сущность предметов, которые допускают значения разных видов данных"]: ch18-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types