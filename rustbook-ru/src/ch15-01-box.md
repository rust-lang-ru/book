## Использование `Box<T>` для ссылки на данные в куче

Наиболее простой умный указатель - это *box*, чей вид данных записывается как `Box<T>`. Такие переменные позволяют хранить данные в куче, а не в обойме. То, что остаётся в обойме, является указателем на данные в куче. Обратитесь к Главе 4, чтобы рассмотреть разницу между обоймой и кучей.

У Box нет неполадок с производительностью, кроме хранения данных в куче вместо обоймы. Но он также и не имеет множества дополнительных возможностей. Вы будете использовать его чаще всего в следующих случаях:

- Когда у вас есть вид данных, размер которого невозможно определить во время сборки, а вы хотите использовать значение этого вида в среде, требующем точного размера;
- Когда у вас есть большой размер данных и вы хотите передать владение, но при этом быть уверенным, что данные не будут воспроизведены;
- Когда вы хотите получить значение во владение и вас важно только то, что оно относится к виду данных, выполняющему определённую сущность, а не то, является ли оно значением какого-то определенного вида данных;

Мы выясним первую случай в разделе ["Выполнение рекурсивных видов данных с помощью Box"](#%D0%92%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D0%B2%D0%BD%D1%8B%D1%85-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-Boxes)<!-- ignore -->. Во втором случае, передача владения на большой размер данных может занять много времени, потому что данные повторяются через обойма. Для повышения производительности в этой случае, мы можем хранить большое количество данных в куче с помощью Box. Затем только небольшое количество данных указателя воспроизводится в обойме, в то время как данные, на которые он ссылается, остаются в одном месте кучи. Третий случай известен как *сущность предмет* (trait object) и глава 17 посвящает целый раздел ["Использование сущность предметов, которые допускают значения разных видов данных"]<!-- ignore --> только этой теме. Итак, то, что вы узнаете здесь, вы примените снова в Главе 17!

### Использование `Box<T>` для хранения данных в куче

Прежде чем мы обсудим этот исход использования `Box<T>`, мы рассмотрим правила написания и то, как взаимодействовать со значениями, хранящимися в `Box<T>`.

В приложении 15-1 показано, как использовать поле для хранения значения `i32` в куче:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-01/src/main.rs}}
```

<span class="caption">Приложение 15-1: Сохранение значения <code>i32</code> в куче с использованием box</span>

Мы объявляем переменную `b` со значением `Box`, указывающим на число `5`, размещённое в куче. Эта программа выведет `b = 5`; в этом случае мы получаем доступ к данным в box так же, как если бы эти данные находились в обойме. Как и любое другое значение, когда box выйдет из области видимости, как `b` в конце `main`, он будет удалён. Деаллокация происходит как для box ( хранящегося в обойме), так и для данных, на которые он указывает (хранящихся в куче).

Размещать одиночные значения в куче не слишком целесообразно, поэтому вряд ли вы будете часто использовать box'ы таким образом. В большинстве случаев более уместно размещать такие значения, как `i32`, в обойме, где они и сохраняются по умолчанию. Давайте рассмотрим случай, когда box позволяет нам определить виды данных, которые мы не могли бы иметь, если бы у нас не было box.

### Включение рекурсивных видов с помощью Boxes

Значение *рекурсивного вида* может иметь другое значение такого же вида данных как свой составляющая. Рекурсивные виды представляют собой неполадку, поскольку во время сборки Ржавчина должна знать, сколько места занимает вид. Однако вложенность значений рекурсивных видов предположительно может продолжаться бесконечно, поэтому Ржавчина не может определить, сколько места потребуется. Поскольку box имеет известный размер, мы можем включить рекурсивные виды, добавив box в определение рекурсивного вида.

В качестве примера рекурсивного вида рассмотрим *cons list*. Это вид данных, часто встречающийся в полезных языках программирования. Вид cons list, который мы определим, достаточно прост, за исключением наличия рекурсии; поэтому подходы, заложенные в примере, с которым мы будем работать, пригодятся вам в любом более сложной случае, связанной с рекурсивными видами.

#### Больше сведений о cons списке

*cons list* - это стопки данных из языка программирования Lisp и его диалектов, представляющая собой набор вложенных пар и являющаяся Lisp-исполнением связного списка. Его название происходит от функции `cons` (сокращение от "construct function") в Lisp, которая создает пару из двух своих переменных. Вызывая `cons` для пары, которая состоит из некоторого значения и другой пары, мы можем выстраивать списки cons, состоящие из рекурсивных пар.

Вот, пример cons list в виде псевдорукописи, содержащий список 1, 2, 3, где каждая пара заключена в круглые скобки:

```text
(1, (2, (3, Nil)))
```

Каждая переменная в cons списке содержит две вещи: значение текущей переменной и следующая переменная. Последняя переменная в списке содержит только значение, называемое `Nil` без следующей переменной. Cons список создаётся путём рекурсивного вызова функции `cons`. Каноничное имя для обозначения основного случая рекурсии - `Nil`. Обратите внимание, что это не то же самое, что понятие “пустота/null” или “nil” из Главы 6, которая является недействительным или отсутствующим значением.

Cons list не является часто используемым видом данных в Ржавчине. В большинстве случаев, когда вам нужен список переменных при использовании Ржавчины, лучше использовать `Vec<T>`. Другие, более сложные рекурсивные виды данных *полезны* в определённых случаях, но благодаря тому, что в этой главе мы начнём с cons list, мы сможем выяснить, как box позволяет нам определить рекурсивный вид данных без особого напряжения.

Приложение 15-2 содержит объявление перечисления cons списка. Обратите внимание, что эта рукопись не будет собираться, потому что вид данных `List` не имеет известного размера, что мы и выясним.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-02/src/main.rs:here}}
```

<span class="caption">Приложение 15-2: Первая попытка определить перечисление в качестве стопки данных cons list, состоящей из <code>i32</code> значений.</span>

> Примечание: В данном примере мы выполняем cons list, который содержит только значения `i32`. Мы могли бы использовать его с помощью generics, о которых мы говорили в главе 10, чтобы определить вид cons list, который мог бы хранить значения любого вида данных.

Использование вида данных `List` для хранения списка `1, 2, 3` будет выглядеть как рукопись в приложении 15-3:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-03/src/main.rs:here}}
```

<span class="caption">Приложение 15-3: Использование перечисления <code>List</code> для хранения списка <code>1, 2, 3</code></span>

Первое значение `Cons` содержит `1` и другой `List`. Это значение `List` является следующим значением `Cons`, которое содержит `2` и другой `List`. Это значение `List` является ещё один значением `Cons`, которое содержит `3` и значение `List`, которое наконец является `Nil`, не рекурсивным исходом, сигнализирующим об окончании списка.

Если мы попытаемся собрать рукопись в приложении 15-3, мы получим ошибку, показанную в приложении 15-4:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-03/output.txt}}
```

<span class="caption">Приложение 15-4: Ошибка, которую мы получаем при попытке определить рекурсивное перечисление</span>

Ошибка говорит о том, что этот вид данных "имеет бесконечный размер". Причина в том, что мы определили `List` в виде данных, которая является рекурсивной: она непосредственно хранит другое значение своего собственного вида данных. В итоге Ржавчина не может определить, сколько места ему нужно для хранения значения `List`. Давайте разберёмся, почему мы получаем эту ошибку. Сначала мы рассмотрим, как Ржавчина решает, сколько места ему нужно для хранения значения нерекурсивного вида.

#### Вычисление размера нерекурсивного вида

Вспомните перечисление `Message` определённое в приложении 6-2, когда обсуждали объявление enum  в главе 6:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-02/src/main.rs:here}}
```

Чтобы определить, сколько памяти выделять под значение `Message`, Ржавчина проходит каждый из исходов, чтобы увидеть, какой исход требует наибольшее количество памяти. Ржавчина видит, что для `Message::Quit` не требуется места, `Message::Move` хватает места для хранения двух значений `i32` и т.д. Так как будет использоваться только один исход, то наибольшее пространство, которое потребуется для значения `Message`, это пространство, которое потребуется для хранения самого большого из исходов перечисления.

Сравните это с тем, что происходит, когда Ржавчина пытается определить, сколько места необходимо рекурсивному виду, такому как перечисление `List` в приложении 15-2. Сборщик смотрит на исход `Cons`, который содержит значение вида данных `i32` и значение вида данных `List`. Следовательно, `Cons` нужно пространство, равное размеру `i32` дополнительно размер `List`. Чтобы выяснить, сколько памяти необходимо виду `List`, сборщик смотрит на исходы, начиная с `Cons`. Исход `Cons` содержит значение вида данных `i32` и значение вида данных `List`, и этот этап продолжается бесконечно, как показано на рисунке 15-1.

 <img alt="Бесконечный список Cons" src="img/trpl15-01.svg" class="center" style="width: 50%;">

<span class="caption">Рисунок 15-1: Бесконечный <code>List</code>, состоящий из нескончаемого числа исходов <code>Cons</code></span>

#### Использование `Box<T>` для получения рекурсивного вида с известным размером

Поскольку Ржавчина не может определить, сколько места нужно выделить для видов с рекурсивным определением, сборщик выдаёт ошибку с этим полезным предложением:

<!-- manual-regeneration
after doing automatic regeneration, look at listings/ch15-smart-pointers/listing-15-03/output.txt and copy the relevant line
-->

```text
help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `List` representable
  |
2 |     Cons(i32, Box<List>),
  |               ++++    +
```

В данном предложении "перенаправление" означает, что вместо того, чтобы непосредственно хранить само значение, мы должны изменить вид данных, так чтобы хранить его косвенно - хранить указатель на это значение.

Поскольку `Box<T>` является указателем, Ржавчина всегда знает, сколько места нужно `Box<T>`: размер указателя не меняется в зависимости от размера данных, на которые он указывает. Это означает, что мы можем поместить `Box<T>` внутрь образца данных `Cons` вместо значения `List` напрямую. `Box<T>` будет указывать на значение очередного `List`, который будет находиться в куче, а не внутри образца данных `Cons`. Мировозренческо у нас все ещё есть список, созданный из списков, содержащих другие списки, но эта выполнение теперь больше похожа на размещение переменных рядом друг с другом, а не внутри друг друга.

Мы можем изменить определение перечисления `List` в приложении 15-2 и использование `List` в приложении 15-3 на рукопись из приложения 15-5, который будет собираться:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-05/src/main.rs}}
```

<span class="caption">Приложение 15-5: Определение <code>List</code>, которое использует <code>Box&lt;T&gt;</code> для того, чтобы иметь вычисляемый размер</span>

`Cons` требуется размер `i32` дополнительно место для хранения данных указателя box. `Nil` не хранит никаких значений, поэтому ему нужно меньше места, чем `Cons`. Теперь мы знаем, что любое значение `List` займёт размер `i32` дополнительно размер данных указателя box. Используя box, мы разорвали бесконечную рекурсивную цепочку, поэтому сборщик может определить размер, необходимый для хранения значения `List`. На рисунке 15-2 показано, как теперь выглядит `Cons`.

 <img alt="Бесконечный список Cons" src="img/trpl15-02.svg" class="center" style="width: 50%;">

<span class="caption">Рисунок 15-2: <code>List</code>, который не является бесконечно большим, потому что <code>Cons</code> хранит <code>Box</code>.</span>

Box-ы обеспечивают только перенаправление и выделение в куче; у них нет никаких других особых возможностей, подобных тем, которые мы увидим у других видов умных указателей. У них также нет накладных расходов на производительность, которые несут эти особые возможности, поэтому они могут быть полезны в таких случаях, как cons list, где перенаправление - единственная функция, которая нам нужна. В главе 17 мы также рассмотрим другие случаи использования box.

Вид данных `Box<T>` является умным указателем, поскольку он использует сущность `Deref`, который позволяет обрабатывать значения `Box<T>` как ссылки. Когда значение `Box<T>` выходит из области видимости, данные кучи, на которые указывает box, также очищаются благодаря выполнения сущности `Drop`. Эти две сущности будут ещё более значимыми для возможности, предоставляемой другими видами умных указателей, которые мы обсудим в оставшейся части этой Главы. Давайте рассмотрим эти два сущности более подробно.


["Использование сущностей предметов, которые допускают значения разных видов"]: ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types