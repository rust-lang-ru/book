## Создание объединения потоков и сохранение в него потоков

Предостережения сборщика сообщают о том, что рукопись не использует способы и свойства.
Далее мы выполняем возможности.

### Проверка количества потоков в объединении

Для начала рассмотрим способ `new`. Он получает целочисленное положительное значение.
Обратите внимание, что объединение с нулевым количеством потоков имеет смысл, т.к. 0 может
иметь вид данных `u32`. Выполняем проверку значения свойства количества потоков перед
возвращение образца данных `ThreadPool` и используем макрос `panic!` если значение равно
0. Для этого используем макрос `assert!`:

<span class="filename">Filename: src/lib.rs</span>

```rust
# pub struct ThreadPool;
impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: u32) -> ThreadPool {
        assert!(size > 0);

        ThreadPool
    }

    // ...snip...
}
```

<span class="caption">рукопись 20-13: выполнение функции `ThreadPool::new`, которая прервёт
работу программы, если переменная `size` будет равна `0`</span>

Обратите внимание, что добавили сведения для создания пособия. Это хороший
тон добавлять разделы пособия. Она будет весьма полезна, чтобы узнать почему
же рукопись не сработал (это мы обсуждали в главе 14). Запустим нашу программу с помощью
приказы `cargo doc --open` и посмотрим на созданную пособие.

Вместо добавления макроса `assert!` мы также могли бы использовать решение и примера
12-9. Если вы уверены в своих знаниях Ржавчина API, выполните способ `new` такого вида:

```rust,ignore
fn new(size: u32) -> Result<ThreadPool, PoolCreationError> {
```

### Сохранение потоков в объединении

После того, как вы проверили соблюдение правил входных данных мы можем приступить к
созданию нужного количества потоков и сохранить их в образце вида данных `ThreadPool`
перед тем как возвратить образец данных.

Возникает вопрос, как же всё-таки сохранять потоки? Рассмотрим способ `thread::spawn`
ещё раз:

```rust,ignore
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
    where
        F: FnOnce() -> T + Send + 'static,
        T: Send + 'static
```

`spawn` возвращает образец данных `JoinHandle<T>`, где `T` является видом данных возвращаемого
значения из замыкания. Попробуем использовать `JoinHandle<T>`.  В нашем случае,
замыкание, которое мы посылаем в объединение потоков будет обрабатывать соединение и ничего
не возвращать. Т.е. `T` будет действительно пока будет действителен пустой составной ряд
`()`.

Приведём мысль решения, которое ещё пока не будет собираться (рукопись 201-14).
Мы изменим определение вида данных `ThreadPool`, чтобы он хранил вектор с размером, выполняем круговорот `for` таким образом, чтобы он создавал потоки и возвращал образец данных `ThreadPool`:

<span class="filename">Filename: src/lib.rs</span>

```rust,ignore
use std::thread;

pub struct ThreadPool {
    threads: Vec<thread::JoinHandle<()>>,
}

impl ThreadPool {
    // ...snip...
    pub fn new(size: u32) -> ThreadPool {
        assert!(size > 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // create some threads and store them in the vector
        }

        ThreadPool {
            threads
        }
    }

    // ...snip...
}
```

<span class="caption"> 20-14: создание вектора для хранения потоков в `ThreadPool`</span>

Мы добавили использование `std::thread`, т.к. нам понадобиться использовать
`thread::JoinHandle` в качестве вида переменных в `ThreadPool`. Мы ещё не использовали функцию `with_capacity`. Она делает то же самое, что и `Vec::new` - изменяет размеры при вставке переменных. Поскольку мы создали вектор нужного размера, который нам нужен, никаких изменений размера не потребуется.

Давайте соберем эту рукопись и посмотрим на ошибку:

```text
$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0308]: mismatched types
  --> src\main.rs:70:46
   |
70 |         let mut threads = Vec::with_capacity(size);
   |                                              ^^^^ expected usize, found u32

error: aborting due to previous error
```
`size` имеет вид данных `u32`. Функции `Vec::with_capacity` нужно входное свойство вида данных
`usize`. У нас есть две возможности - мы можем изменить вид свойства функции или мы можем
привести вид данных `u32` к виду данных `usize`. Как вы помните, когда мы объявляли функцию `new`
мы не задумывались о виде входных данных. Задумаемся сейчас. Вид данных `usize` имеет большое значение для вектора. Давайте изменим описание функции:

```rust,ignore
fn new(size: usize) -> ThreadPool {
```

Если вы запустите приказ `cargo check` - рукопись собирается.

Как же всё-таки создавать потоки в круговороте? Мы ещё не можем знать для чего они нам понадобятся - мы просто вносим замыкания Это сложный вопрос. Какие должны идти в этих потоках? Мы не знаем, какую работу они должны делать при этом поскольку способ `execute` берет замыкание и передаем его в объединение

Давим некоторых изменений. Вместо создания образцов  `JoinHandle<()>`, создадим новое устройство, которое использует способ *Рабочий* (*Worker*). *Рабочий* будет получать замыкание в способе `execute` и будет вызывать её. Дополнительно, нам даст это возможность иметь ограниченное количество образцов *Рабочих* и
будет выполнена абстракция.

Итак, выполняем устройство. Описание изменений:

1. Создадим стопку `Worker`, полями которой будут `id` и `JoinHandle<()>`
2. Сделаем так, чтобы вектор в `ThreadPool` содержал бы образцы `Worker`
3. Опишем функцию `Worker::new`, чтобы она получала бы `id` и возвращала бы
   образец данных `Worker` с `id` и поток с пустым замыканием
4. В `ThreadPool::new`, будем использовать круговорот `for` и его счётчик будет `id`.
   Будет создаваться образец данных `Worker` с этим `id` и этот вектор будет сохраняться в
   вектор.

Если вы чувствуете в себе силы, пожалуйста, выполните свое решение этой задачи,
а потом посмотрите на решение 20-15.

Готовы? Вот рукопись 20-15, который использует  with one way to make these modifications:

<span class="filename">Filename: src/lib.rs</span>

```rust
use std::thread;

pub struct ThreadPool {
    workers: Vec<Worker>,
}

impl ThreadPool {
    // ...snip...
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool {
            workers
        }
    }
    // ...snip...
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle<()>,
}

impl Worker {
    fn new(id: usize) -> Worker {
        let thread = thread::spawn(|| {});

        Worker {
            id,
            thread,
        }
    }
}
```

<span class="caption">рукопись 20-15: изменения устройства `ThreadPool` для хранения
образцов `Worker` вместо хранение непосредственно потоков</span>

Мы решили изменить имя поля с `threads` на `workers`, т.к. мы изменили вид данных
поля. Мы используем счётчик в круговороте.

Эта рукопись собирается и сохраняет образцы устройств. Пока мы никак не обрабатываем,
т.е. не делаем никаких действий, не предоставляем никаких действий над потоками.
Об этом мы поговорим в следующий разделы.
