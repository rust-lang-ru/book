## Обработка последовательности переменных с помощью повторителей

Использование образца Повторитель помогает при необходимости поочерёдного выполнения какого-либо действия над переменными в последовательности. Повторитель отвечает за ход перебора переменных и определение времени завершения последовательности. Используя повторители, вам не нужно самостоятельно выполнять весь этот ход мыслей.

В Ржавчине повторители *ленивые (lazy)*, то есть они не делают ничего, пока вы не вызовете особые способы, использующие повторитель , чтобы задействовать его. Например, рукопись в приложении 13-10 создаёт повторитель переменных вектора `v1`, вызывая способ `iter`, определённый у `Vec<T>`. Сама по себе эта рукопись не делает ничего полезного.

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-10/src/main.rs:here}}
```

<span class="caption">Приложение 13-10: Создание повторителя</span>

Повторитель  хранится в переменной `v1_iter`. Создав повторитель , мы можем использовать его различными способами. В приложении 3-5 Главы 3 мы совершали обход переменных массива используя круговорот `for` для выполнения какой-либо рукописи над каждым из её переменных. Под капотом это неявно создавало, а затем использовало повторитель , но до сих пор мы не касались того, как именно это работает.

В примере из приложения 13-11 мы отделили создание повторителя от его использования в круговороте for. В круговороте for, использующем повторитель в v1_iter, каждая переменная повторителя участвует только в одном повторении круговорота, в ходе которой выводится на экран его значение.

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-11/src/main.rs:here}}
```

<span class="caption">Приложение 13-11: Использование повторителя в круговороте <code>for</code></span>

В языках, обычные библиотеки которых не предоставляют повторители, вы, скорее всего, напишите эту же возможность так: создадите переменную со значением 0 затем, в круговороте, использовав её для получения переменной вектора по порядковому указателю, будете увеличивать её значение, и так, пока оно не достигнет числа равного количеству переменных в векторе.

Повторители выполняют весь этот ход мыслей за вас, сокращая количество повторяющейся рукописи, которая возможно может была написана неправильно. Повторители дают вам гибкость, позволяя использовать одинаковые принципы работы с различными видами последовательностей, а не только с видами данных, которые можно упорядочивать, например, векторами. Давайте рассмотрим, как повторители это делают.

### Сущность `Iterator` и способ `next`

Все повторители используют сущность `Iterator`, который определён во встроенной библиотеке. Его определение выглядит так:

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // methods with default implementations elided
}
```

Обратите внимание данное объявление использует новые правила написания: `type Item` и `Self::Item`, которые определяют *сопряженный вид данных* (associated type) с этой сущностью. Мы подробнее поговорим о сопряженных видах данных в главе 19. Сейчас вам нужно знать, что эта рукопись требует от выполнений сущности `Iterator` определить требуемый им вид данных `Item` и данный вид данных `Item` используется в способе `next`. Другими словами, вид данных `Item` будет являться видом переменной, который возвращает повторитель .

Сущность `Iterator` требует, чтобы разработчики определяли только один способ: способ `next`, который возвращает одну переменную повторителя за раз обёрнутый в исход `Some` и когда повторение завершено, возвращает `None`.

Мы можем вызывать способ `next` у повторителей напрямую; в приложении 13-12 показано, какие значения возвращаются при повторных вызовах `next` у повторителя, созданного из вектора.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-12/src/lib.rs:here}}
```

<span class="caption">Приложение 13-12: Вызов способа <code>next</code> повторителя</span>

Обратите внимание, что нам нужно сделать переменную `v1_iter` изменяемой: вызов способа `next` повторителя изменяет внутреннее состояние повторителя, которое повторитель использует для отслеживания того, где он находится в последовательности. Другими словами, эта рукопись *использует* (consume) или использует повторитель . Каждый вызов `next` использует переменную из повторителя. Нам не нужно было делать изменяемой `v1_iter` при использовании круговорота `for`, потому что круговорот забрал во владение `v1_iter` и сделал её изменяемой неявно для нас.

Заметьте также, что значения, которые мы получаем при вызовах `next` являются неизменяемыми ссылками на значения в векторе. Способ `iter` создаёт повторитель по неизменяемым ссылкам. Если мы хотим создать повторитель , который становится владельцем `v1` и возвращает принадлежащие ему значения, мы можем вызвать `into_iter` вместо `iter`. Точно так же, если мы хотим перебирать изменяемые ссылки, мы можем вызвать `iter_mut` вместо `iter`.

### Способы, которые используют повторитель 

У сущности `Iterator` есть несколько способов, выполнение которых по умолчанию предоставляется встроенной библиотекой; вы можете узнать об этих способах, просмотрев пособие API встроенной библиотеки для `Iterator`. Некоторые из этих способов вызывают `next` в своём определении, поэтому вам необходимо использовать способ `next` при выполнения сущности `Iterator`.

Способы, вызывающие `next`, называются *использующими переходниками*, поскольку их вызов использует повторитель . Примером может служить способ `sum`, который забирает во владение повторитель и перебирает переменные, многократно вызывая `next`, тем самым используя повторитель . В этапе повторения он добавляет каждая переменная к текущему итогу сложения и возвращает итоговое значение по завершении повторения. В приложении 13-13 приведена проверка, отображающая использование способа `sum`:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-13/src/lib.rs:here}}
```

<span class="caption">Приложение 13-13: Вызов способа <code>sum</code> для получения итога сложения всех переменных в повторителе</span>

Мы не можем использовать `v1_iter` после вызова способа `sum`, потому что `sum` забирает во владение повторитель у которого вызван способ.

### Способы, которые создают другие повторители

*Переходники повторителей* - это способы, определённые для сущности `Iterator`, которые не используют повторитель . Вместо этого они создают различные повторители, изменяя некоторые особенности исходного повторителя.

В приложении 13-14 показан пример вызова способа переходника повторителя `map`, который принимает замыкание и вызывает его для каждой переменной по мере повторения переменных. Способ `map` возвращает новый повторитель , который создаёт изменённые переменные. Замыкание здесь создаёт новый повторитель , в котором каждая переменная из вектора будет увеличен на 1:

<span class="filename">Файл: src/main.rs</span>

```rust,not_desired_behavior
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-14/src/main.rs:here}}
```

<span class="caption">Приложение 13-14: Вызов переходника повторителя <code>map</code> для создания нового повторителя</span>

Однако эта рукопись выдаёт предупреждение:

```console
{{#include ../listings/ch13-functional-features/listing-13-14/output.txt}}
```

Рукопись в приложении 13-14 ничего не делает; указанное нами замыкание никогда не вызывается. Предупреждение напоминает нам, почему: переходники повторителей ленивы, и здесь нам нужно потребить повторитель .

Чтобы устранить это предупреждение и потребить повторитель , мы воспользуемся способом `collect`, который мы использовали в главе 12 с `env::args` в приложении 12-1. Этот способ использует повторитель и собирает полученные значения в собрание указанного вида данных.

В приложении 13-15 мы собираем в вектор итоги перебора повторителя, который возвращается в итоге вызова `map`. Этот вектор в итоге будет содержать каждая переменная исходного вектора, увеличенный на 1.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-15/src/main.rs:here}}
```

<span class="caption">Приложение 13-15: Вызов способа <code>map</code> для создания нового повторителя, а затем вызов способа <code>collect</code> для использования нового повторителя и создания вектора</span>

Поскольку `map` принимает замыкание, мы можем указать любое действие, которое хотим выполнить над каждой переменной. Это отличный пример того, как замыкания позволяют задавать желаемое поведение, используя при этом особенности повторения, которые предоставляет сущность `Iterator`.

Вы можете выстроить цепочку из нескольких вызовов переходников повторителя для выполнения сложных действий удобном для прочтения виде. Но поскольку все повторители являются "ленивыми", для получения итогов вызовов переходников повторителя необходимо вызвать один из способов использующего переходника.

### Использование замыканий, которые получают переменные окружения

Многие переходники повторителей принимают замыкания в качестве переменных, и обычно замыкания, которые мы будем указывать в качестве переменных переходникам повторителей, это замыкания, которые определяют (получают) своё окружение.

В этом примере мы будем использовать способ `filter`, который принимает замыкание. Замыкание получает переменную из повторителя и возвращает `bool`. Если замыкание возвращает `true`, значение будет включено в повторение, создаваемую `filter`. Если замыкание возвращает `false`, значение не будет включено.

В приложении 13-16 мы используем `filter` с замыканием, которое получает переменную `shoe_size` из своего окружения для повторения по собрания образцов стопки `Shoe`. Он будет возвращать обувь только указанного размера.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-16/src/lib.rs}}
```

<span class="caption">Приложение 13-16: Использование способа <code>filter</code> с замыканием, определяющим <code>shoe_size</code></span>

Функция `shoes_in_size` принимает в качестве свойств вектор с образцами обуви и размер обуви, а возвращает вектор, содержащий только обувь указанного размера.

В теле `shoes_in_my_size` мы вызываем `into_iter` чтобы создать повторитель , который становится владельцем вектора. Затем мы вызываем `filter`, чтобы превратить этот повторитель в другой, который содержит только переменные, для которых замыкание возвращает `true`.

Замыкание получает свойство `shoe_size` из окружения и сравнивает его с размером каждой пары обуви, оставляя только обувь указанного размера. Наконец, вызов `collect` собирает значения, возвращаемые приспособленным повторителем, в вектор, возвращаемый функцией.

Проверка показывает, что когда мы вызываем `shoes_in_my_size`, мы возвращаем только туфли, размер которых совпадает с указанным нами значением.
