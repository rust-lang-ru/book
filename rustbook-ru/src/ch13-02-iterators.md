## Обработка переменных последовательно с помощью повторителей

Использование таких средств как повторители помогает при необходимости поочерёдного выполнения какого-либо действия над переменными в последовательности. Повторитель отвечает за этап перебора переменных и определение времени завершения всех действий. Используя повторители, вам не нужно самостоятельно выполнять весь этот ход мыслей.

Ржавчине использует _ленивые (lazy)_ повторители, то есть для их использования обязательно необходимо их вызов. Например, рукопись в приложении 13-10 использует повторитель `iter` при переборе переменных ,содержащихся в векторе `v1`. Способ `iter` определён у `Vec<T>`. Сама по себе эта рукопись ничего не делает.

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-10/src/main.rs:here}}
```

<span class="caption">Приложение 13-10: Использование повторителя</span>

Повторитель  хранится в переменной `v1_iter`. Создав повторитель , мы можем использовать его различными способами. В приложении 3-5 Главы 3 мы совершали перебор переменных массива, используя круговорот `for` для выполнения какого-либо действия над каждым из её переменных. Под капотом это неявно создавало, а затем использовало повторитель , но до сих пор мы не касались того, как именно это работает.

В примере из приложения 13-11 мы отделили объявление повторителя от его использования при вызове в круговороте for. В круговороте for, использующем повторитель в v1_iter, каждая переменная повторителя участвует только в одном повторении круговорота, в ходе которой выводится на экран его значение.

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-11/src/main.rs:here}}
```

<span class="caption">Приложение 13-11: Использование повторителя в круговороте <code>for</code></span>

В языках, в которых обычные библиотеки не предоставляют повторители, вы, скорее всего, напишите эту же возможность так: создадите переменную со значением 0 затем, в круговороте, использовав её для получения переменной вектора по порядковому указателю, будете увеличивать её значение, и так, пока оно не достигнет числа равного количеству переменных в векторе.

Повторители выполняют весь этот ход мыслей за вас, сокращая количество повторяющейся рукописи, которая возможно может была написана неправильно. Повторители дают вам гибкость, позволяя использовать одинаковые принципы работы с различными видами последовательностей, а не только с видами данных, которые можно упорядочивать, например, векторами. Давайте рассмотрим, как повторители это делают.

### Сущность `Iterator` и способ `next`

Все повторители используют сущность `Iterator`, которая определена во встроенной библиотеке. Её определение выглядит так:

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // methods with default implementations elided
}
```

Обратите внимание данное объявление использует новые правила написания: `type Item` и `Self::Item`, которые определяют _сопряженный вид данных_ (associated type) с этой сущностью. Мы подробнее поговорим о сопряженных видах данных в главе 20. Сейчас вам нужно знать, что эта рукопись требует от выполнений сущности `Iterator` определить требуемый им вид данных `Item` и данный вид данных `Item` используется в способе `next`. Другими словами, вид данных `Item` будет являться видом переменной, который возвращает повторитель .

Сущность `Iterator` требует, чтобы разработчики определяли только один способ: способ `next`, который возвращает одну переменную повторителя за раз обёрнутую в исход `Some` и когда повторение более не возможно, возвращает `None`.

Мы можем вызывать способ `next` у повторителей напрямую; в приложении 13-12 показано, какие значения возвращаются при повторных вызовах `next` у повторителя, созданного из вектора.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-12/src/lib.rs:here}}
```

<span class="caption">Приложение 13-12: Вызов способа <code>next</code> повторителя</span>

Обратите внимание, что нам нужно сделать переменную `v1_iter` изменяемой: вызов способа `next` повторителя изменяет внутреннее состояние повторителя, которое повторитель использует для отслеживания того, где он находится в последовательности. Другими словами, эта рукопись _использует_ (consume) или использует повторитель . Каждый вызов `next` использует переменную из повторителя. Нам не нужно было делать изменяемой `v1_iter` при использовании круговорота `for`, потому что круговорот забрал во владение `v1_iter` и сделал её изменяемой неявно для нас.

Заметьте также, что значения, которые мы получаем при вызовах `next` являются неизменяемыми ссылками на значения в векторе. Способ `iter` создаёт повторитель по неизменяемым ссылкам. Если мы хотим создать повторитель , который становится владельцем `v1` и возвращает принадлежащие ему значения, мы можем вызвать `into_iter` вместо `iter`. Точно так же, если мы хотим перебирать изменяемые ссылки, мы можем вызвать `iter_mut` вместо `iter`.

### Способы, которые используют повторитель 

У сущности `Iterator` есть несколько способов, выполнение которых по умолчанию предоставляется встроенной библиотекой; вы можете узнать об этих способах, просмотрев пособие API встроенной библиотеки для `Iterator`. Некоторые из этих способов вызывают `next` в своём определении, поэтому вам необходимо использовать способ `next` при выполнения сущности `Iterator`.

Способы, вызывающие `next`, называются _итоговыми переходниками_, поскольку их вызов использует повторитель . Примером может служить способ `sum`, который забирает во владение повторитель и перебирает переменные, многократно вызывая `next`, тем самым используя повторитель . В этапе повторения он добавляет каждую переменную к текущему итогу сложения и возвращает итоговое значение по завершении повторения. В приложении 13-13 приведен пример, отображающий использование способа `sum`:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-13/src/lib.rs:here}}
```

<span class="caption">Приложение 13-13: Вызов способа <code>sum</code> для получения итога сложения всех переменных в повторителе</span>

Мы не можем использовать `v1_iter` после вызова способа `sum`, потому что `sum` забирает во владение повторитель у которого вызван способ.

### Способы, которые создают другие повторители

_Переходники повторителей_ - это способы, определённые для сущности `Iterator`, которые не используют повторитель . Вместо этого они создают различные повторители, изменяя некоторые особенности исходного повторителя.

В приложении 13-14 показан пример вызова способа переходника повторителя `map`, который использует замыкание и вызывает его для каждой переменной по мере повторения переменных. Способ `map` возвращает новый повторитель , который создаёт изменённые переменные. Замыкание здесь создаёт новый повторитель , в котором каждая переменная из вектора будет увеличен на 1:

<span class="filename">Файл: src/main.rs</span>

```rust,not_desired_behavior
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-14/src/main.rs:here}}
```

<span class="caption">Приложение 13-14: Вызов переходника повторителя <code>map</code> для создания нового повторителя</span>

Однако эта рукопись выдаёт предупреждение:

```console
{{#include ../listings/ch13-functional-features/listing-13-14/output.txt}}
```

Рукопись в приложении 13-14 ничего не делает; указанное нами замыкание никогда не вызывается. Предупреждение напоминает нам, почему: переходники повторителей ленивы, и здесь нам нужно использовать повторитель .

Чтобы устранить это предупреждение и использовать повторитель , мы воспользуемся способом `collect`, который мы использовали в главе 12 с `env::args` в приложении 12-1. Этот способ использует повторитель и собирает полученные значения в собрание указанного вида данных.

В приложении 13-15 мы собираем в вектор итоги перебора повторителя, который возвращает итог вызова `map`. Этот вектор в итоге будет содержать каждую переменную исходного вектора, увеличенную на 1.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-15/src/main.rs:here}}
```

<span class="caption">Приложение 13-15: Вызов способа <code>map</code> для создания нового повторителя, а затем вызов способа <code>collect</code> для использования нового повторителя и создания вектора</span>

Поскольку `map` использует замыкание, мы можем указать любое действие, которое хотим выполнить над каждой переменной. Это отличный пример того, как замыкания позволяют производить необходимые нам действия, используя при этом особенности повторения, которые предоставляет сущность `Iterator`.

Вы можете выстроить цепочку из нескольких вызовов переходников повторителя для выполнения сложных действий удобном для прочтения виде. Но поскольку все повторители являются "ленивыми", для получения итогов вызовов переходников повторителя необходимо вызвать один из способов _итогового переходника_.

### Использование замыканий, которые получают переменные окружения

Многие переходники повторителей используют замыкания в качестве переменных, и обычно замыкания, которые мы будем указывать в качестве переменных переходникам повторителей, это замыкания, которые определяют (получают) своё окружение.

В этом примере мы будем применять способ `filter`, который использует замыкание. Замыкание получает переменную из повторителя и возвращает `bool`. Если замыкание возвращает `true`, значение будет включено в повторение, создаваемое `filter`. Если замыкание возвращает `false`, значение не будет включено.

В приложении 13-16 мы используем `filter` с замыканием, которое получает переменную `shoe_size` из своего окружения с целью его повторных прогонов для добавления в вектор `Shoe`. Он будет возвращать обувь только указанного размера с указанием наименования.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-16/src/lib.rs}}
```

<span class="caption">Приложение 13-16: Использование способа <code>filter</code> с замыканием, определяющим <code>shoe_size</code></span>

Функция `shoes_in_size` принимает в качестве свойств вектор с образцами обуви и размер обуви, а возвращает вектор, содержащий только обувь указанного размера с указанием наименования.

В теле `shoes_in_my_size` мы вызываем `into_iter` чтобы использовать повторитель, которому передаём право владения над вектором `Vec<Shoe>`. Затем мы вызываем способ `filter`, внутри которого используем замыкание, которое обращается к вектору `Vec<Shoe>`, производя проверку согласно условию и возвращает в случае `true` стопку `Shoe`.

Замыкание получает переменную `shoe_size` вида данных `u32` из окружения и сравнивает его с размером каждой пары обуви, оставляя только обувь указанного размера. Наконец, вызов `collect` собирает возвращенные итоги `filter` в виде стопки `Shoe`, собирая их в вектор `Vec<Shoe>`.

Проверка показывает, что когда мы вызываем `shoes_in_my_size`, мы возвращаем только туфли с указанием наименования, размер которых совпадает с указанным нами значением.
