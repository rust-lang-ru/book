## Обработка переменных последовательно с помощью повторителей

Использование таких средств как повторители помогает при необходимости поочерёдного выполнения какого-либо действия над переменными в последовательности. Повторитель отвечает за этап перебора переменных и определение времени завершения всех действий. Используя повторители, вам не нужно самостоятельно выполнять весь этот ход мыслей.

Ржавчине использует _ленивые (lazy)_ повторители, то есть для их использования обязательно необходимо их вызов. Например, рукопись в приложении 13-10 использует повторитель `iter` при переборе переменных ,содержащихся в векторе `v1`. Способ `iter` определён у `Vec<T>`. Сама по себе эта рукопись ничего не делает.

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-10/src/main.rs:here}}
```

<span class="caption">Приложение 13-10: Использование повторителя</span>

Повторитель  хранится в переменной `v1_iter`. Создав повторитель , мы можем использовать его различными способами. В приложении 3-5 Главы 3 мы совершали перебор переменных массива, используя круговорот `for` для выполнения какого-либо действия над каждым из её переменных. Под капотом это неявно создавало, а затем использовало повторитель , но до сих пор мы не касались того, как именно это работает.

В примере из приложения 13-11 мы отделили объявление повторителя от его использования при вызове в круговороте for. В круговороте for, использующем повторитель в v1_iter, каждая переменная повторителя участвует только в одном повторении круговорота, в ходе которой выводится на экран его значение.

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-11/src/main.rs:here}}
```

<span class="caption">Приложение 13-11: Использование повторителя в круговороте <code>for</code></span>

В языках, в которых обычные библиотеки не предоставляют повторители, вы, скорее всего, напишите эту же возможность так: создадите переменную со значением 0 затем, в круговороте, использовав её для получения переменной вектора по порядковому указателю, будете увеличивать её значение, и так, пока оно не достигнет числа равного количеству переменных в векторе.

Повторители выполняют весь этот ход мыслей за вас, сокращая количество повторяющейся рукописи, которая возможно может была написана неправильно. Повторители дают вам гибкость, позволяя использовать одинаковые принципы работы с различными видами последовательностей, а не только с видами данных, которые можно упорядочивать, например, векторами. Давайте рассмотрим, как повторители это делают.

### Сущность `Iterator` и способ `next`

Все повторители используют сущность `Iterator`, которая определена во встроенной библиотеке. Её определение выглядит так:

```rust
pub trait Iterator {
    type Предмет;

    fn next(&mut self) -> Option<Self::Item>;

    // methods with default implementations elided
}
```

Обратите внимание данное объявление использует новые правила написания: `type Item` и `Self::Item`, которые определяют _сопряженный вид данных_ (associated type) с этой сущностью. Мы подробнее поговорим о сопряженных видах данных в главе 20. Сейчас вам нужно знать, что эта рукопись требует от выполнений сущности `Iterator` определить требуемый им вид данных `Item` и данный вид данных `Item` используется в способе `next`. Другими словами, вид данных `Item` будет являться видом переменной, который возвращает повторитель .

Сущность `Iterator` требует, чтобы разработчики определяли только один способ: способ `next`, который возвращает одну переменную повторителя за раз обёрнутую в исход `Some` и когда перебор более не возможен и это конечное значение, возвращает `None`.

Мы можем вызывать способ `next` у повторителей напрямую; в приложении 13-12 показано, какие значения возвращаются при повторных вызовах `next` у повторителя, созданного из вектора.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-12/src/lib.rs:here}}
```

<span class="caption">Приложение 13-12: Вызов способа <code>next</code> повторителя</span>

Обратите внимание, что нам нужно сделать переменную `v1_iter` изменяемой: вызов способа `next` повторителя изменяет внутреннее состояние повторителя, которое повторитель использует для отслеживания того, где он находится в последовательности. Другими словами, эта рукопись _использует_ (consume) или использует повторитель . Каждый вызов `next` использует переменную из повторителя. Нам не нужно было делать изменяемой `v1_iter` при использовании круговорота `for`, потому что круговорот забрал во владение `v1_iter` и сделал её изменяемой неявно для нас.

Заметьте также, что значения, которые мы получаем при вызовах `next` являются неизменяемыми ссылками на значения в векторе. Способ `iter` получает ссылки без права владения или изменения данных. Если мы хотим создать повторитель , который становится владельцем `v1` и возвращает принадлежащие ему значения, мы можем вызвать `into_iter` вместо `iter`. Точно так же, если мы хотим перебирать изменяемые ссылки, мы можем вызвать `iter_mut` вместо `iter`. `iter_mut` не получает права владения, только лишь право на изменяемую ссылку `&mut`.

### Способы, которые используют повторитель 

У сущности `Iterator` есть несколько способов, выполнение которых по умолчанию предоставляется встроенной библиотекой; вы можете узнать об этих способах, просмотрев пособие API встроенной библиотеки для `Iterator`. Некоторые из этих способов вызывают `next` в своём определении, поэтому вам необходимо использовать способ `next` при выполнения сущности `Iterator`.

Способы, вызывающие `next`, называются _итоговыми переходниками_, поскольку их вызов использует повторитель . Примером может служить способ `sum`, который забирает во владение повторитель и перебирает переменные, многократно вызывая `next`, тем самым используя повторитель . В этапе повторения он добавляет каждую переменную к текущему итогу сложения и возвращает итоговое значение по завершении повторения. В приложении 13-13 приведен пример, отображающий использование способа `sum`:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-13/src/lib.rs:here}}
```

<span class="caption">Приложение 13-13: Вызов способа <code>sum</code> для получения итога сложения всех переменных в повторителе</span>

Мы не можем использовать `v1_iter` после вызова способа `sum`, потому что `sum` забирает во владение повторитель у которого вызван способ.

### Способы, которые создают другие повторители

_Переходники повторителей_ - это способы, определённые для сущности `Iterator`, которые не используют повторитель . Вместо этого они создают различные повторители, изменяя некоторые особенности исходного повторителя.

В приложении 13-14 показан пример вызова способа переходника повторителя `map`, который использует замыкание и вызывает его для каждой переменной по мере повторения переменных. Способ `map` возвращает новый повторитель , который создаёт изменённые переменные. Замыкание здесь создаёт новый повторитель , в котором каждая переменная из вектора будет увеличен на 1:

<span class="filename">Файл: src/main.rs</span>

```rust,not_desired_behavior
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-14/src/main.rs:here}}
```

<span class="caption">Приложение 13-14: Вызов переходника повторителя <code>map</code> для использования с повторителем `iter`</span>

Однако эта рукопись выдаёт предупреждение:

```console
{{#include ../listings/ch13-functional-features/listing-13-14/output.txt}}
```

Рукопись в приложении 13-14 ничего не делает, указанное нами замыкание никогда не вызывается. Предупреждение указывает нам почему: переходники повторителей ленивы по умолчанию, и в данном случае нам обязательно нужно использовать повторитель .

Чтобы устранить это предупреждение и использовать повторитель , мы воспользуемся способом `collect`, который мы использовали в главе 12 с `env::args` в приложении 12-1. Этот способ используется повторителем и собирает полученные значения в указанный вид данных (в нашем случае в вектор `Vec`).

В приложении 13-15 мы собираем в вектор итоги действий `map`  повторителя `iter`. Этот вектор будет содержать каждую переменную из исходного вектора, увеличенную на 1.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-15/src/main.rs:here}}
```

<span class="caption">Приложение 13-15: Вызов способа <code>map</code> при использовании повторителем, а затем вызов способа <code>collect</code> для сбора итога в вектор</span>

Поскольку `map` использует замыкание, мы можем указать любое действие, которое хотим выполнить над каждой переменной. Это отличный пример того, как замыкания позволяют производить необходимые нам действия, используя при этом особенности повторения, которые предоставляет сущность `Iterator`.

Вы можете выстроить цепочку из нескольких вызовов переходников повторителя для выполнения сложных действий удобном для прочтения виде. Но поскольку все повторители являются "ленивыми", для получения итогов вызовов переходников повторителя необходимо вызвать один из способов _итогового переходника_.

### Использование замыканий, которые получают переменные окружения

Многие переходники повторителей используют замыкания в качестве переменных, и обычно замыкания, которые мы будем указывать в качестве переменных переходникам повторителей, это замыкания, которые определяют (получают) своё окружение.

В этом примере мы будем применять способ `filter`, который использует замыкание. Замыкание получает переменную из повторителя и возвращает `bool`. Если замыкание возвращает `true`, `filter` возвращает `Option<вид данных>`. Если замыкание возвращает `false`, возвращается `None`.

В приложении 13-16 мы используем `filter` , в которое встроено замыкание. Оно (замыкание) получает переменную `shoe_size` из своего окружения с целью его сравнения со значениями размеров обуви в `Vec<Shoe>.size`. В случае если размер обуви из переменной `shoe_size` соответствует размеру в `Vec<Shoe>.size`, то размер добавляется в `Vec<Shoe>`. Он будет возвращать обувь только указанного размера с указанием наименования.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-16/src/lib.rs}}
```

<span class="caption">Приложение 13-16: Использование способа <code>filter</code> с замыканием, находящий нужный нам размер обуви, указываемый в переменной <code>shoe_size</code></span>

Способ (функция) `shoes_in_size` принимает в качестве свойств вектор с образцами обуви и искомый нами размер обуви, а возвращает вектор, содержащий  обувь указанного размера с указанием наименования.

В теле `shoes_in_my_size` мы вызываем `into_iter` ,так как он передаёт право владения над `Vec<Shoe>`. Затем мы вызываем способ `filter`, внутри которого используем замыкание, последнее обращается к вектору `Vec<Shoe>`, сверяя размер обуви согласно условию. В случае совпадения размера обуви `true` способ `filter`  возвращает стопку `Shoe` с искомым размером и наименованием обуви.

Замыкание получает переменную `shoe_size` вида данных `u32` из окружения и сравнивает его с размером каждой пары обуви, оставляя обувь указанного размера. Наконец, вызов `collect` собирает возвращенные итоги `filter` в виде стопки(-ок) `Shoe`, собирая их в вектор `Vec<Shoe>`.

Проверка показывает, что когда мы вызываем `shoes_in_my_size`, мы возвращаем стопки с обувью `Shoe`  , размер которых мы запрашивали в свойстве способы (функции) `shoes_in_my_size`.
