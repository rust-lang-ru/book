## Макросы

Мы использовали макросы, такие как `println!` на протяжении всей этой книги, но мы не изучили полностью, что такое макрос и как он работает. Понятие *макрос* относится к семейству возможностей в Ржавчине. Это *объявляющие* (declarative) макросы с помощью `macro_rules!` и три вида *процедурных* (procedural) макросов:

- Пользовательские (выводимые) `#[derive]` макросы, которые указывают в рукописи, добавленный с помощью средства `derive`, используемые для стопок и перечислений
- Макросы подобные свойствам (attribute-like), которые определяют настраиваемые свойства, используемые для любой переменной языка
- Похожие на функции (function-like) макросы, которые выглядят как вызовы функций, но работают с TokenStream

Мы поговорим о каждом из них по очереди, но сначала давайте рассмотрим, зачем вообще нужны макросы, если есть функции.

### Разница между макросами и функциями

По сути, макросы являются способом написания рукописи, которая записывает другую рукопись, что известно как *мета программирование*. В Приложении C мы обсуждаем средство `derive`, которое порождает за вас выполнение различных сущностей. Мы также использовали макросы `println!` и `vec!` на протяжении всей книги. Все эти макросы *раскрываются* для создания большего количества рукописей, чем исходная рукопись написанная вами вручную.

Мета программирование полезно для уменьшения размера рукописи, которую вы должны написать и поддерживать, что также является одним из предназначений функций. Однако макросы имеют некоторые дополнительные возможности, которых функции не имеют.

Ярлык функции должен объявлять некоторое количество и вид данных этих свойств имеющихся у функции. Макросы, с другой стороны, могут принимать переменное Число свойств: мы можем вызвать `println!("здравствуй")` с одной переменной или `println!("hello {}", name)` с двумя переменными. Также макросы раскрываются до того как сборщик преобразует смысл рукописи, поэтому макрос может, например, использовать сущность заданного вида данных. Функция этого не может, потому что она вызывается во время выполнения и сущность должна быть выполнена во время сборки.

Обратной стороной выполнения макроса вместо функции является то, что определения макросов являются более сложными, чем определения функций, потому что вы создаёте в Ржавчине рукопись, которая записывает другую рукопись Ржавчины. Из-за этой косвенности, объявления макросов, как правило, труднее читать, понимать и поддерживать, чем объявления функций.

Другое важное различие между макросами и функциями заключается в том, что вы должны объявить макросы или добавить их в область видимости *прежде* чем можете вызывать их в файле, в отличии от функций, которые вы можете объявить где угодно и вызывать из любого места.

### Объявляющие макросы с `macro_rules!` для общего мета программирования

Наиболее широко используемой способом макросов в Ржавчине являются *объявляющие макросы*. Они также иногда упоминаются как "макросы на примере", "`macro_rules!` макрос" или просто "макросы". По своей сути объявляющие макросы позволяют писать нечто похожее на выражение `match` в  Ржавчине. Как обсуждалось в главе 6, `match` выражения являются управляющими средствами, которые принимают некоторое выражение, итог значения выражения сопоставляют с образцами данных, а затем запускают рукопись для сопоставляемой ветки. Макросы также сравнивают значение с образцами данных, которые связаны с определенной рукописью: в этом случае значение является записью исходной рукописи Ржавчины, переданным в макрос. Образцы сравниваются со значениями исходной рукописи и при совпадении рукописи, связанная с каждым образцом, заменяет рукопись переданную макросу. Все это происходит во время сборки.

Для определения макроса используется устройство `macro_rules!`. Давайте рассмотрим, как использовать `macro_rules!` глядя на то, как объявлен макрос `vec!`. В главе 8 рассказано, как можно использовать макрос `vec!` для создания нового вектора с определёнными значениями. Например, следующий макрос создаёт новый вектор, содержащий три целых числа:

```rust
let v: Vec<u32> = vec![1, 2, 3];
```

Мы также могли использовать макрос `vec!` для создания вектора из двух целых чисел или вектора из пяти строковых срезов. Мы не смогли бы использовать функцию, чтобы сделать то же самое, потому что мы не знали бы заранее количество или вид значений.

В приложении 19-28 приведено несколько упрощённое определение макроса `vec!`.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch20-advanced-features/listing-19-28/src/lib.rs}}
```

<span class="caption">Приложение 19-28: Упрощённая исполнение определения макроса <code>vec!</code></span>

> Примечание: действительное определение макроса `vec!` во встроенной библиотеке содержит рукопись для предварительного выделения правильного размера памяти. Эта рукопись является переработкой, которую мы здесь не используем, чтобы сделать пример проще.

Изложение `#[macro_export]` указывает, что данный макрос должен быть доступен всякий раз, когда дополнение с объявленным макросом, добавлен в область видимости. Без этой изложении макрос нельзя добавить в область видимости.

Затем мы начинаем объявление макроса с помощью  `macro_rules!` и имени макроса, который объявляется *без* восклицательного знака. Название, в данном случае `vec`, после которого следуют узорчатые скобки, указывающие тело определения макроса.

Стопка в теле макроса `vec!` похожа на устройство `match` выражения. Здесь у нас есть одна ветвь с образцом `( $( $x:expr ),* )`, затем следует ветвь `=>` и раздел рукописи, связанный с этим образцом. Если образец данных сопоставлен успешно, то соответствующий раздел рукописи будет создан. Учитывая, что данная рукопись является единственным образцом в этом макросе, существует только один действительный способ сопоставления, любой другой образец данных приведёт к ошибке. Более сложные макросы будут иметь более одной ветви.

Допустимые правила написания образца в определениях макросов отличается от правил написания образца рассмотренного в главе 18, потому что образцы макроса сопоставляются со средствами рукописи Ржавчины, а не со значениями. Давайте пройдёмся по тому, какие части образца в приложении 19-28 что означают; полные правила написания образцов макроса можно найти в [Справочнике по Ржавчине].

Во-первых, мы используем набор скобок, чтобы охватить весь образец данных. Мы используем знак доллара ( `$`) для объявления переменной в системе макросов, которая будет содержать рукопись на Ржавчине, соответствующий образцу данных. Знак доллара показывает, что это макропеременная, а не обычная переменная Ржавчины. Далее следует набор скобок, в котором определятся значения, соответствующие образцу данных в скобках, для использования в рукописи замены. Внутри `$()` находится `$x:expr`, которое соответствует любому выражению Ржавчина и даёт выражению имя `$x`.

Запятая, следующая за `$()` указывает на то, что буквенный знак-разделитель запятая может дополнительно появиться после рукописи, которую соответствует рукописи в `$()`. Звёздочка `*` указывает, что образец данных соответствует ноль или больше раз тому, что предшествует `*`.

Когда вызывается этот макрос с помощью `vec![1, 2, 3];` образец данных `$x` соответствует три раза всем трём выражениям `1`, `2` и `3`.

Теперь давайте посмотрим на образец данных в теле рукописи, связанного с этой ветвью: `temp_vec.push()` внутри `$()*` порождается для каждой части, которая соответствует знаку `$()` в образце ноль или более раз в зависимости от того, сколько раз образец данных сопоставлен. Знак `$x` заменяется на каждое совпадающее выражение. Когда мы вызываем этот макрос с `vec![1, 2, 3];`, созданная рукопись, заменяющая этот вызов макроса будет следующим:

```rust,ignore
{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}
```

Мы определили макрос, который может принимать любое количество переменных любого вида данных и может порождать рукопись для создания вектора, содержащего указанные переменные.

Чтобы узнать больше о том, как писать макросы, обратитесь к в сети-пособия или другим источникамм, таким как [«Маленькая книга макросов Ржавчины»] , начатая Дэниелом Кипом и продолженная Лукасом Виртом.

### Процедурные макросы для создания рукописи из свойств

Вторая разновидность макросов - это *процедурные макросы* (procedural macros), которые действуют как функции (и являются видом процедуры). Процедурные макросы принимают некоторую рукопись в качестве входных данных, работают над этим рукописью и создают некоторую рукопись в качестве вывода, а не выполняют сопоставления с образцами данных и замену рукописи другой рукописью, как это делают объявляющие макросы. Процедурные макросы могут быть трёх видов: "пользовательского вывода" (custom-derive), "похожие на свойство" (attribute-like) и "похожие на функцию" (function-like), все они работают схожим образом.

При создании процедурных макросов объявления должны находиться в собственном дополнениее целенаправленного вида. Это из-за сложных технических причин, которые мы надеемся будут устранены в будущем. В приложении 19-29 показано, как задать процедурный макрос, где `some_attribute` является исполнителем для использования целенаправленного макроса.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -> TokenStream {
}
```

<span class="caption">Приложение 19-29: Пример определения процедурного макроса</span>

Функция, которая определяет процедурный макрос, принимает `TokenStream` в качестве входных данных и создаёт `TokenStream` в качестве вывода. Вид данных `TokenStream` объявлен дополнением `proc_macro`, включённым в Ржавчине и представляет собой последовательность токенов. Это ядро макроса: исходную рукопись над которым работает макрос, является входным `TokenStream`, а рукопись создаваемый макросом является выходным `TokenStream`. К функции имеет также прикреплённый свойство, определяющий какой вид процедурного макроса мы создаём. Можно иметь несколько видов процедурных макросов в одном и том же дополнениее.

Давайте посмотрим на различные виды процедурных макросов. Начнём с пользовательского, выводимого (derive) макроса и затем объясним небольшие различия, делающие другие разновидности отличающимися.

### Как написать пользовательский `derive` макрос

Давайте создадим дополнение с именем `здравствуй_macro`, который определяет сущность с именем `здравствуйMacro` и имеет одну с ним сопряженную функцию с именем `здравствуй_macro`. Вместо того, чтобы пользователи нашего дополнения самостоятельно выполнили сущность `здравствуйMacro` для каждого из своих видов данных, мы предоставим им процедурный макрос, чтобы они могли определять свой вид данных с помощью средства `#[derive(HelloMacro)]` и получили выполнение по умолчанию для функции `здравствуй_macro`. Выполнение по умолчанию выведет `здравствуй, Macro! My name is TypeName!`, где `TypeName` - это имя вида данных, для которого был определён эту сущность. Другими словами, мы напишем дополнение, использование которого позволит другому программисту писать рукопись показанный в приложении 19-30.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch20-advanced-features/listing-19-30/src/main.rs}}
```

<span class="caption">Приложение 19-30: Рукопись, которую сможет написать пользователь нашего дополнения при использовании нашего процедурного макроса</span>

Эта рукопись выведет `Здравствуй, Макро! Меня зовут Блины!`, когда мы закончим. Первый шаг - создать новый, библиотечное дополнение так:

```console
$ cargo new hello_macro --lib
```

Далее, мы определим сущность `здравствуйMacro` и сопряженную с ним функцию:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-20-impl-hellomacro-for-pancakes/hello_macro/src/lib.rs}}
```

У нас есть сущность и его функция. На этом этапе пользователь дополнения может использовать сущность для достижения желаемой возможности, так:

```rust,ignore
{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-20-impl-hellomacro-for-pancakes/pancakes/src/main.rs}}
```

Тем не менее, ему придётся написать раздел выполнения для каждого вида, который он хотел использовать вместе с `здравствуй_macro`; а мы хотим избавить их от необходимости делать эту работу.

Кроме того, мы пока не можем предоставить функцию `здравствуй_macro` с выполнением по умолчанию, которая будет выводить имя вида данных, для которого выполнена сущность: Ржавчина не имеет возможностей размышления (reflection), поэтому он не может использовать поиск имени вида данных во время выполнения рукописи. Нам нужен макрос для создания рукописи во время сборки.

Следующим шагом является определение процедурного макроса. На мгновение написания этой статьи процедурные макросы должны быть в собственном дополнениее. Со временем это ограничение может быть отменено. Соглашение о внутреннем выстраивании

 дополнений и макросов является следующим: для дополнения с именем `foo`, его пользовательский, дополнение с выводимым процедурным макросом называется `foo_derive`. Давайте начнём с создания нового дополнения с именем `здравствуй_macro_derive` внутри дела `здравствуй_macro`:

```console
$ cargo new hello_macro_derive --lib
```

Наши два дополнения тесно связаны, поэтому мы создаём процедурный макрос-дополнение в папке дополнения `здравствуй_macro`. Если мы изменим определение сущности в `здравствуй_macro`, то нам придётся также изменить выполнение процедурного макроса в `здравствуй_macro_derive`. Два дополнения нужно будет обнародовать отдельно и программисты, использующие эти дополнения, должны будут добавить их как дополнения, а затем добавить их в область видимости. Мы могли вместо этого сделать так, что дополнение `здравствуй_macro` использует `здравствуй_macro_derive` как дополнение и реэкспортирует рукопись процедурного макроса. Однако то, как мы внутренне выстраивали дело, делает возможным программистам использовать `здравствуй_macro` даже если они не хотят `derive` возможность.
Нам нужно объявить дополнение `здравствуй_macro_derive` как процедурный макрос-дополнение. Также понадобятся возможности из дополнений `syn` и `quote`, как вы увидите через мгновение, поэтому нам нужно добавить их как дополнения. Добавьте следующее в файл *Cargo.toml* для `здравствуй_macro_derive`:

<span class="filename">Файл: hello_macro_derive/Cargo.toml</span>

```toml
{{#include ../listings/ch20-advanced-features/listing-19-31/hello_macro/hello_macro_derive/Cargo.toml:6:12}}
```

Чтобы начать определение процедурного макроса, поместите рукопись приложения 19-31 в ваш файл *src/lib.rs* дополнения `здравствуй_macro_derive`. Обратите внимание, что эта рукопись не собирается пока мы не добавим определение для функции `impl_здравствуй_macro`.

<span class="filename">Файл: hello_macro_derive/src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch20-advanced-features/listing-19-31/hello_macro/hello_macro_derive/src/lib.rs}}
```

<span class="caption">Приложение 19-31: Рукопись, которая потребуется в большинстве процедурных макро дополнений для обработки рукописи Ржавчины </span>

Обратите внимание, что мы разделили рукопись на функцию `здравствуй_macro_derive`, которая отвечает за связанную оценку`TokenStream` и функцию `impl_здравствуй_macro`, которая отвечает за преобразование согласно правил написания дерева: это делает написание процедурного макроса удобнее. Рукопись во внешней функции ( `здравствуй_macro_derive` в данном случае) будет одинаковой для почти любого процедурного макрос дополнения, который вы видите или создаёте. Рукопись, которую вы указываете в теле внутренней функции (в данном случае `impl_здравствуй_macro` ) будет отличаться в зависимости от цели вашего процедурного макроса.

Мы представили три новых дополнения: `proc_macro` [`syn`] и [`quote`]. Макрос `proc_macro` поставляется с Ржавчиной, поэтому нам не нужно было добавлять его в зависимости внутри *Cargo.toml*. Макрос `proc_macro` - это API сборщика, который позволяет нам читать и управлять Ржавчина рукописью из нашей рукописи.

Дополнение `syn` разбирает рукопись Ржавчины из строки в вид данных над которой мы может выполнять действия. Дополнение `quote` превращает вид данных `syn` обратно в рукопись Ржавчины. Эти дополнения упрощают разбор любого вида рукописи Ржавчины , которую мы хотели бы обрабатывать: написание полного оценщика согласно правил написания для рукописи Ржавчины не является простой задачей.

Функция `здравствуй_macro_derive` будет вызываться, когда пользователь нашей библиотеки указывает своему виду `#[derive(HelloMacro)]`. Это возможно, потому что мы определяли функцию `здравствуй_macro_derive` с помощью `proc_macro_derive` и указали имя `здравствуйMacro`, которое соответствует имени нашего сущности; это соглашение, которому следует большинство процедурных макросов.

Функция `здравствуй_macro_derive` сначала преобразует `input` из `TokenStream` в вид данных, который мы можем затем преобразовать и над которым выполнять действия. Здесь дополнение `syn` вступает в игру. Функция `parse` в `syn` принимает `TokenStream` и возвращает вид данных `DeriveInput`, представляющую разобранный рукопись Ржавчины. Приложение 19-32 показывает соответствующие части вида данных `DeriveInput`, которые мы получаем при разборе строки `struct Pancakes;`:

```rust,ignore
DeriveInput {
    // --snip--

    ident: Ident {
        ident: "Pancakes",
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}
```

<span class="caption">Приложение 19-32: Образец данных <code>DeriveInput</code> получаемый, когда разбирается рукопись, имеющая свойство макроса из приложения 19-30</span>

Поля этой стопки показывают, что рукопись Ржавчины, которую мы разобрали, является разделом стопки с `ident` (определителем, означающим имя) `Pancakes`. В этой стопке есть больше полей для описания всех видов рукописи Ржавчины; проверьте [пособие `syn` о стопке `DeriveInput`] для получения дополнительных сведений.

Вскоре мы определим функцию `impl_здравствуй_macro`, в которой построим новую, дополнительную рукопись Ржавчины. Но прежде чем мы это сделаем, обратите внимание, что выводом для нашего выводимого (derive) макроса также является `TokenStream`. Возвращаемый `TokenStream` добавляется в рукопись, написанный пользователями макроса, поэтому, когда они соберут свой дополнение, они получат дополнительную возможность, которую мы предоставляем в изменённом `TokenStream`.

Возможно, вы заметили, что мы вызываем `unwrap` чтобы использовать сбой в функции `здравствуй_macro_derive`, если вызов функции `syn::parse` потерпит неудачу. Наш процедурный макрос должен вызвать сбой при ошибках, потому что функции `proc_macro_derive` должны возвращать `TokenStream`, а не вид данных `Result` для соответствия API процедурного макроса. Мы упростили этот пример с помощью `unwrap`, но в рабочей рукописи вы должны предоставить более определенные сообщения об ошибках, если что-то пошло не правильно, используя `panic!` или `expect`.

Теперь, когда у нас есть рукопись для преобразования определенного Ржавчиной рукописи из `TokenStream` в образец данных `DeriveInput`, давайте создадим рукопись, выполняющую сущность `здравствуйMacro` у определенного вида данных, как показано в приложении 19-33.

<span class="filename">Файл: hello_macro_derive/src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch20-advanced-features/listing-19-33/hello_macro/hello_macro_derive/src/lib.rs:here}}
```

<span class="caption">Приложение 19-33: Использование сущности <code>здравствуйMacro</code> с использованием рассмотренного рукописи Ржавчины.</span>

Мы получаем образец данных стопки `Ident` содержащий имя (определитель) определенного вида данных с использованием `ast.ident`. Стопка в приложении 19-32 показывает, что когда мы запускаем функцию `impl_здравствуй_macro` для рукописи из приложения 19-30, то получаемый `ident` будет иметь поле `ident` со значением `"Pancakes"`. Таким образом, переменная `name` в приложении 19-33 будет содержать образец данных стопки `Ident`, что при выводе выдаст строку `"Pancakes"`, что является именем стопки в приложении 19-30.

Макрос `quote!` позволяет определить рукопись Ржавчины, которое. мы хотим вернуть. Сборщик ожидает что-то отличное от прямого итога выполнения макроса `quote!`, поэтому нужно преобразовать его в `TokenStream`. Мы делаем это путём вызова способа `into`, который использует промежуточное представление и возвращает значение требуемого вида данных `TokenStream`.

Макрос `quote!` также предоставляет очень полезную механику образцов: мы можем ввести `#name` и `quote!` заменит его значением из переменной `name`. Вы можете даже сделать некоторое повторение, подобное тому, как работают обычные макросы. Проверьте [пособие дополнения `quote`] для подробного введения.

Мы хотим, чтобы наш процедурный макрос порождал выполнение нашего сущности `здравствуйMacro` для вида данных, который определял пользователь, который мы можем получить, используя `#name`. Использование сущности имеет одну функцию `здравствуй_macro`, тело которой содержит возможность, которую мы хотим предоставить: вывести `здравствуй, Macro! My name is` с именем определенного вида данных.

Макрос `stringify!` используемый здесь, встроен в Ржавчину. Он принимает Ржавчина выражение, такое как `1 + 2` и во время сборки сборщик превращает выражение в строковый запись, такой как `"1 + 2"`. Он отличается от макросов `format!` или `println!`, которые вычисляют выражение, а затем превращают итог в виде данных`String`. Существует возможность того, что введённый `#name` может оказаться выражением для вывода буквально как есть, поэтому здесь мы используем `stringify!`. Использование `stringify!` также уменьшает выделение памяти путём преобразования `#name` в строковый запись во время сборки.

На этом этапе приказ `cargo build` должна завершиться успешно для обоих `здравствуй_macro` и `здравствуй_macro_derive`. Давайте подключим эти дополнения к рукописи в приложении 19-30, чтобы увидеть процедурный макрос в действии! Создайте новое двоичное дело в папке ваших *дел* с использованием приказы `cargo new pancakes`. Нам нужно добавить `здравствуй_macro` и `здравствуй_macro_derive` в качестве дополнений для дополнения `pancakes` в файл *Cargo.toml*. Если вы размещаете свои исполнения `здравствуй_macro` и `здравствуй_macro_derive` на сайт [crates.io](https://crates.io/), они будут обычными дополнениями; если нет, вы можете указать их как `path` зависимости следующим образом:

```toml
{{#include ../listings/ch20-advanced-features/no-listing-21-pancakes/pancakes/Cargo.toml:7:9}}
```

Поместите рукопись в приложении 19-30 в *src/main.rs* и выполните `cargo run`: он должен вывести `Здравствуй, Макро! Меня зовут Блины!`. Использование сущности `здравствуйMacro` из процедурного макроса была включена без необходимости его выполнения дополнением `pancakes`; `#[derive(HelloMacro)]` добавил использование сущности.

Далее давайте рассмотрим, как другие виды процедурных макросов отличаются от пользовательских выводимых макросов.

### Макросы, похожие на свойство

Подобные свойствам макросы похожи на пользовательские выводимые макросы, но вместо создания рукописи для `derive` свойства, они позволяют создавать новые свойства. Они являются также более гибкими: `derive` работает только для стопок и перечислений; свойство-подобные могут применяться и к другим переменным, таким как функции. Вот пример использования  имеющего свойство макроса: допустим, у вас есть свойство именованный `route` который определяет функции при использовании фреймворка для сетевых-приложений:

```rust,ignore
#[route(GET, "/")]
fn index() {
```

Данный свойство `#[route]` будет определён платспособом как процедурный макрос. Ярлык функции определения макроса будет выглядеть так:

```rust,ignore
#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {
```

Здесь есть два свойства вида данных `TokenStream`. Первое -  для содержимого свойства: часть `GET, "/"` . Второе - это тело переменной, к которому прикреплён свойство: в данном случае `fn index() {}` и остальная часть тела функции.

Кроме того, имеющие свойства макросы работают так же как и пользовательские выводимые макросы: вы создаёте дополнение с видом `proc-macro` и используете функцию, которая порождает рукопись, которую хотите!

### Макросы, похожие на функции

Макросы, похожие на функции, выглядят подобно вызову функций. Подобно макросам `macro_rules!` они являются более гибкими, чем функции; например, они могут принимать неизвестное количество переменных. Тем не менее, макросы `macro_rules!` можно объявлять только с использованием правил написания подобного сопоставлению, который мы обсуждали ранее в разделе <a data-md-type="raw_html" href="#declarative-macros-with-macro_rules-for-general-metaprogramming">"Объявляющие макросы `macro_rules!` для общего мета программирования"</a>. Макросы, похожие на функции, принимают свойство <code>TokenStream</code> и их определение управляет этим `TokenStream`, используя рукопись Ржавчины, как это делают два других вида процедурных макроса. Примером подобного возможностей макроса является макрос `sql!`, который можно вызвать так:

```rust,ignore
let sql = sql!(SELECT * FROM posts WHERE id=1);
```

Этот макрос будет разбирать SQL указанию внутри него и проверять, что она правильная согласно правил написания, что является гораздо более сложной обработкой, чем то что может сделать макрос `macro_rules!`. Макрос `sql!` мог бы быть определён так:

```rust,ignore
#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {
```

Это определение похоже на ярлык пользовательского выводимого макроса: мы получаем токены, которые находятся внутри скобок и возвращаем рукопись, которую мы хотели создать.

## Итоги

Фух! Теперь у вас в распоряжении есть некоторые возможности Ржавчины, которые вы не будете часто использовать, но вы будете знать, что они доступны в особых обстоятельствах. Мы представили несколько сложных тем, чтобы при появлении сообщения с предложением исправить ошибку или в рукописи других людей, вы могли бы распознать эти подходы и правила написания. Используйте эту главу как справочник, который поможет вам найти решение.

Далее мы применим в действительности все, что обсуждали на протяжении всей книги, и выполним ещё одно дело!


[Справочнике по Ржавчине]: ../reference/macros-by-example.html
[«Маленькая книга макросов Ржавчины»]: https://veykril.github.io/tlborm/
[`syn`]: https://crates.io/crates/syn
[`quote`]: https://crates.io/crates/quote
[Пособие `syn` о стопке `DeriveInput`]: https://docs.rs/syn/1.0/syn/struct.DeriveInput.html
[Пособие дополнения `quote`]: https://docs.rs/quote