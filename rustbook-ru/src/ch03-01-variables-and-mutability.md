## Переменные и изменяемость

Как упоминалось в разделе ["Хранение значений с помощью переменных"](ch02-00-guessing-game-tutorial.html#%D0%A5%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B9-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85), по умолчанию переменные неизменяемы. Это одно из многих преимуществ Ржавчины, позволяющих писать рукопись с использованием преимущества безопасности и удобной состязательности (concurrency), предоставляемых Ржавчиной. Тем не менее, существует возможность сделать переменные изменяемыми. Давайте рассмотрим, как и почему Ржавчина побуждает предпочесть неизменяемость и почему иногда можно отказаться от этого.
Если переменная является неизменяемой, то после привязки значения к имени изменить его будет нельзя. Чтобы показать это, создайте новое дело под названием *variables* в папке *projects* с помощью приказов `cargo new variables`.

Далее, в новой папке *variables* откройте *src/main.rs* и замените в нем рукопись на ниже приведённую, который пока не будет собираться:

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore,does_not_compile
fn main() {
let x = 5;
println!("The value of x is: {}", x);
x = 6;
println!("The value of x is: {}", x);
}
```

Сохраните и запустите программу, используя `cargo run`. Будет получено сообщение об ошибке относительно неизменяемости, как показано ниже:

```console
error[E0384]: cannot assign twice to immutable variable `x`  --> src/main.rs:4:5   | 2 |     let x = 5;   |         - first assignment to `x` 3 |     println!("The value of x is: {}", x); 4 |     x = 6;   |     ^^^^^ cannot assign twice to immutable variable
```

В этом примере показано, как сборщик помогает находить ошибки в ваших программах. Ошибки сборщика могут расстраивать, но в действительности они означают, что программа пока не делает правильно то, что вы ожидаете; это *не значит*, что вы плохой программист! Даже опытные Rustaceans иногда сталкиваются с ошибками сборщика.

Вы получили сообщение об ошибке `cannot assign twice to immutable variable `x``, потому что попытались присвоить новое значение неизменяемой переменной `x`.

Важно, чтобы при попытке изменить значение, объявленное неизменяемым, выдавались ошибки времени сборки, так как подобный случай может привести к сбоям. Если одна часть нашей рукописи исполняется исходя из уверенности в неизменяемости значения, а другая часть изменяет это значение, то велика вероятность , что первая часть не выполнит своего предназначения. Причину такой ошибки бывает трудно отследить, особенно если вторая часть рукописи изменяет значение лишь *изредка*. Сборщик Ржавчины предоставляет заверение, что если объявить значение неизменяемым, то оно действительно не изменится, а значит, не нужно следить за этим самим. Таким образом, ваша рукопись становится проще для понимания.

Однако изменяемость может быть очень полезной и может сделать рукопись более удобной для написания. Хотя переменные по умолчанию неизменяемы, их можно сделать изменяемыми, добавив `mut` перед именем переменной, как это было сделано в [Главе 2]. Добавление `mut` также передаёт будущим читателям рукописи намерение, обозначая, что другие части рукописи будут изменять значение этой переменной.

Например, изменим *src/main.rs* на следующую рукопись:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-02-adding-mut/src/main.rs}}
```

Запустив программу, мы получим итог:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-02-adding-mut/output.txt}}
```

Нам разрешено изменить значение, связанное с x, с 5 на 6 при помощи mut. В конечном счёте, решение об использовании изменяемости остаётся за вами и зависит от вашего мнения о наилучшем исходе в данном именно случае.

### Постоянные переменные

Подобно неизменяемым переменным, *постоянные переменные* — это значения, которые связаны с именем и не могут изменяться, но между постоянными переменными и переменными есть несколько различий.

Во-первых, нельзя использовать `mut` с постоянными переменными. Постоянные переменные не просто неизменяемы по умолчанию — они неизменяемы всегда. Для объявления постоянных переменных используется ключевое слово `const` вместо `let`, а также вид данных значения *должен быть* указан в изложении. Мы рассмотрим виды данных и изложение в следующем разделе [«Виды данных».]<!-- ignore -->, так что не беспокойтесь о подробностях прямо сейчас. Просто знайте, что вы всегда должны определять вид данных.

Постоянные переменные можно объявлять в любой области видимости, включая вездесущую, благодаря этому они полезны для значений, которые нужны во многих частях рукописи.

Последнее отличие в том, что постоянные переменные могут быть заданы только постоянным выражением, но не итогом вычисленного во время выполнения значения.

Вот пример объявления постоянные переменные:

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

Имя постоянных переменных - `THREE_HOURS_IN_SECONDS`, а её значение устанавливается как итог умножения 60 (количество секунд в минуте) на 60 (количество минут в часе) на 3 (количество часов, которые нужно посчитать в этой программе). Установленный порядок в Ржавчине для именования постоянных переменных требует использования всех заглавных букв с подчёркиванием между словами. Сборщик может вычислять ограниченный набор действий во время сборки, позволяющий записать это значение более понятным и простым для проверки способом, чем установка этой постоянной переменной значение в 10 800. Дополнительные сведения о том, какие действия можно использовать при объявлении постоянных переменных, см. в разделе [Раздел справки Ржавчина по вычислениям постоянных переменных].

Постоянные переменные существуют в течение всего времени работы программы в пределах области, в которой они были объявлены. Это свойство делает постоянные переменные полезными для значений в области владения вашего приложения, о которых могут знать несколько частей программы, например, наибольшее количество очков, которое может заработать любой игрок в игре, или скорость света.

Обозначение строго определенных значений, используемых в программе, именуемых как постоянные переменные -  полезно для передачи смысла этого значения будущим сопровождающим рукописи. Это также позволяет иметь единственное место в рукописи, которое нужно будет изменить, если в будущем потребуется обновить значение.

### Затенение (переменных)

Как было показано в уроке по игре в Угадайка в [главе 2](ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number), можно объявить новую переменную с тем же именем, как и у существующей переменной. Rustaceans говорят, что первая переменная *затеняется* второй, то есть вторая переменная - это то, что увидит сборщик, когда вы будете использовать имя переменной. По сути, вторая переменная затеняет первую, принимая любое использование имени переменной на себя до тех пор, пока либо она сама не станет тенью, либо не закончится область видимости. Мы можем затенять переменную, используя то же имя переменной и повторяя использование ключевого слова `let` следующим образом:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-03-shadowing/src/main.rs}}
```

Эта программа сначала привязывает `x` к значению `5`. Затем она создаёт новую переменную `x`, повторяя `let x =`, беря исходное значение и добавляя `1`, чтобы значение `x` стало равным `6`. Затем во внутренней области видимости, созданной с помощью узорчатых скобок, третий приказчик `let` также затеняет `x` и создаёт новую переменную, умножая предыдущее значение на `2`, чтобы дать `x` значение `12`. Когда эта область заканчивается, внутреннее затенение заканчивается, и `x` возвращается к значению `6`. Запустив эту программу, она выведет следующее:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-03-shadowing/output.txt}}
```

Затенение отличается от объявления переменной с помощью `mut`, так как мы получим ошибку сборки, если случайно попробуем переназначить значение без использования ключевого слова `let`. Используя `let`, можно выполнить несколько превращений над значением, при этом оставляя переменную неизменяемой, после того как все эти превращения завершены.

Другой разницей между `mut` и затенением является то, что мы создаём совершенно новую переменную, когда снова используем слово `let` (ещё одну). Мы можем даже изменить вид данных значения, но снова использовать прежнее имя. К примеру, наша программа спрашивает пользователя, сколько пробелов он хочет разместить между некоторым писанием, запрашивая знаки пробела, но мы на самом деле хотим сохранить данный ввод как число:

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-04-shadowing-can-change-types/src/main.rs:here}}
```

Первая переменная `spaces` — является строковым видом данных, а вторая переменная `spaces` — числовым видом данных. Таким образом, затенение избавляет нас от необходимости придумывать разные имена, такие как `spaces_str` и `spaces_num`. Вместо этого мы можем повторно использовать более простое имя `spaces`. Однако, если мы попытаемся использовать для этого `mut`, как показано далее, то получим ошибку времени сборки:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-05-mut-cant-change-types/src/main.rs:here}}
```

Ошибка говорит, что не разрешается менять вид данных переменной:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-05-mut-cant-change-types/output.txt}}
```

Теперь, когда мы изучили, как работают переменные, давайте рассмотрим различные виды данных, которые они могут иметь.


[«Виды данных».]: ch03-02-data-types.html#data-types
[Главе 2]: ch02-00-guessing-game-tutorial.html#storing-values-with-variables
[Раздел справки Ржавчина по вычислениям постоянных переменных]: ../reference/const_eval.html