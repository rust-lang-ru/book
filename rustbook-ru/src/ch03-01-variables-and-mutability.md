## Переменные и понятие изменяемости

Как упоминалось в разделе [“Сохранение значений в переменных”]<!--  -->, по умолчанию переменные являются неизменяемыми. Это одна из многих подсказок, которые Rust даёт вам для написания кода таким образом, чтобы использовать преимущества безопасности и простого параллелизма, которые предлагает Rust. Однако у вас есть возможность сделать ваши переменные изменяемыми. Давайте рассмотрим, как и почему Rust поощряет неизменность и почему иногда вы можете отказаться от этого.

Когда переменная неизменяемая, то её значение нельзя менять, как только значение привязано к её имени. Приведём пример использования этого типа переменной. Для этого создадим новый проект *variables* в каталоге *projects* при помощи команды: `cargo new variables`.

Потом в созданной папке проекта *variables* откройте исходный файл *src/main.rs* и замените содержимое следующим кодом, который пока не будет компилироваться:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-01-variables-are-immutable/src/main.rs}}
```

Сохраните код программы и выполните команду `cargo run`. В командной строке вы увидите сообщение об ошибке:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-01-variables-are-immutable/output.txt}}
```

Данный пример показывает как компилятор помогает найти ошибки в программах. Ошибки компилятора могут вызывать разочарование, они означают, что ваша программа ещё не выполняет то, что вы от неё хотите. Ошибки *не означают*, что вы пока не являетесь хорошим программистом! Опытные разработчики Rust также получают ошибки компиляции.

Сообщение об ошибке указывает, что причиной ошибки является то, что вы `cannot assign twice to immutable variable `x`` (не можете присвоить неизменяемой переменной новое значение), потому что вы пытались присвоить второе значение неизменяемой переменной `x`.

Важно, что мы получаем ошибку времени компиляции,  при попытке изменить значение, обозначенное как неизменяемое, потому что такая ситуация может привести к ошибкам. Если одна часть нашего кода исходит из предположения, что значение никогда не изменится, а другая часть кода изменяет это значение, вполне возможно, что первая часть кода не будет делать то, для чего она предназначена. Причину такого рода ошибок может быть трудно отследить постфактум, особенно когда второй фрагмент кода изменяет значение только *иногда*. Компилятор Rust гарантирует, что если вы заявите, что значение не изменится, оно действительно не изменится, поэтому вам не нужно следить за ним самостоятельно. Таким образом, ваш код легче понять.

Но изменяемость может быть очень полезной. Переменные являются неизменяемыми только по умолчанию. Аналогично как вы делали в Главе 2, можно сделать переменные изменяемыми добавлением ключевого слова `mut` перед названием переменной. В дополнение к возможности изменить значение, указание `mut` передаёт намерение будущим читателям кода, что другие части кода будут изменять значение этой переменной.

Например, изменим *src/main.rs* на следующий код:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-02-adding-mut/src/main.rs}}
```

Запустив программу, мы получим результат:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-02-adding-mut/output.txt}}
```

Разрешено изменять значение, где `x`  связывается с `5` и потом на `6`, когда используется `mut`. Есть несколько компромиссов, которые следует дополнительно учитывать для предотвращения ошибок. Например, в случаях, когда вы используете большие структуры данных, изменение экземпляра на месте может быть быстрее, чем копирование и возврат вновь созданных экземпляров. С меньшими структурами данных может быть легче продумать создание новых экземпляров и написание кода в более функциональном стиле, поэтому более низкая производительность может быть достойным штрафом за достижение ясности кода.

### Константы

Подобно неизменяемым переменным, *константы* — это значения, которые связаны с именем и не могут изменяться, но между константами и переменными есть несколько различий.

Во-первых, не разрешается использовать `mut` с константами. Константы не просто неизменны по умолчанию — они неизменны всегда. Вы объявляете константы, используя ключевое слово `const` вместо ключевого слова `let` и тип *должен* быть явно указан. Мы собираемся рассмотреть типы и аннотации типов в следующем разделе<a>“Типы данных”</a><!--  --> так что не беспокойтесь о деталях сейчас. Просто знайте, что вы всегда должны указывать тип.

Константы можно объявить в любой области видимости, включая глобальную. Это делает их удобными для значений, про которые должны знать многие другие части кода.

Последней разницей является то, что константы можно установить только в константное выражение, а не в результат значения, которое можно посчитать только во время выполнения.

Вот пример объявления константы:

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

Имя константы `THREE_HOURS_IN_SECONDS` и её значение устанавливается в результате умножения числа 60 (количество секунд в минуте) на 60 (количество минут в часе) на 3 (количество часов, которое мы хотим подсчитать в этой программе). ). Соглашение об именах констант в Rust состоит в том, чтобы использовать все символы в верхнем регистре с символами подчёркивания между словами. Компилятор способен вычислить ограниченный набор операций во время компиляции, что позволяет нам записать это значение так, чтобы его было легче понять и проверить, вместо того, чтобы устанавливать для этой константы значение 10,800. См [раздел справочника Rust, посвящённый вычислению констант] для получения дополнительной информации о том, какие операции можно использовать при объявлении констант.

Константы являются корректными для всего времени выполнения программы, внутри области видимости где они были объявлены. Это  делает константы удобным выбором для значений в приложении, которые могут быть доступны во многих частях приложения. Например, максимально разрешённое количество очков игрока в игре или скорость света в вакууме.

Наименование не изменяемых значений во всей программе, таких как константа, является удобным способом выразить смысл значения для будущих пользователей кода. Этот помогает иметь только одно место в коде, которое придётся обновить, если будет необходимо поменять его значение в будущем.

### Затенение (переменных)

Как вы видели в учебнике по игре по угадыванию числа в [Главе 2](ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number)<!--  -->, можно объявить новую переменную с тем же именем, что и предыдущая переменная. Rust разработчики говорят, что первая переменная *затенена* второй, а это означает, что значение второй переменной — это то, что программа видит при её использовании. Мы можем затенить переменную, используя то же имя переменной и повторив использование ключевого слова `let` следующим образом:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-03-shadowing/src/main.rs}}
```

Программа сначала связывает значение `5` с переменной `x`. Затем `x` затеняется повторением кода  `let x =` с помощью начального значения и прибавления к нему `1`, так что значение `x` становится равным `6`. Третье выражение `let` также затеняет переменную `x`, умножением предыдущее значение на `2`. Это даёт переменной `x` значение равное `12`. При запуске программы мы получим вывод:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-03-shadowing/output.txt}}
```

Затенение отличается от объявления переменной с помощью `mut`, так как мы получим ошибку компиляции, если случайно попробуем переназначить значение без использования ключевого слова `let`. Используя `let`, можно выполнить несколько превращений над значением, при этом оставляя переменную неизменяемой, после того как все эти превращения завершены.

Другой разницей между `mut` и затенением является то, что мы создаём совершенно новую переменную, когда снова используем слово `let` (ещё одну). Мы можем даже изменить тип значения, но снова использовать предыдущее имя. К примеру, наша программа спрашивает пользователя сколько пробелов он хочет разместить между некоторым текстом, запрашивая символы пробела, но мы на самом деле хотим сохранить данный ввод как число:

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-04-shadowing-can-change-types/src/main.rs:here}}
```

Первая переменная `spaces` — является строковым типом, а вторая переменная `spaces` — числовым типом. Таким образом, затенение избавляет нас от необходимости придумывать разные имена, такие как `spaces_str` и `spaces_num`; вместо этого мы можем повторно использовать более простое имя `spaces`. Однако, если мы попытаемся использовать для этого `mut`, как здесь показано, то мы получим ошибку времени компиляции:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-05-mut-cant-change-types/src/main.rs:here}}
```

Ошибка говорит, что не разрешается менять тип переменной:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-05-mut-cant-change-types/output.txt}}
```

Теперь, когда вы имеете представление о работе с переменными, посмотрим на большее количество типов данных, которые они могут иметь.


[“Сохранение значений в переменных”]: ch02-00-guessing-game-tutorial.html#storing-values-with-variables
[раздел справочника Rust, посвящённый вычислению констант]: ../reference/const_eval.html
