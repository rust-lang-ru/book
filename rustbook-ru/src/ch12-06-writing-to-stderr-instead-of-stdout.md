## Запись сообщений ошибок в поток ошибок вместо принятого потока вывода

В данное мгновение мы записываем весь наш вывод в окно вызова, используя функцию `println!`. В большинстве окон вызовов предоставлено два вида вывода: *обычный поток вывода* ( `stdout` ) для общей сведений и *обычный поток ошибок* ( `stderr` ) для сообщений об ошибках. Это различие позволяет пользователям выбирать, направлять ли успешный вывод приложения в файл, но при этом выводить сообщения об ошибках на экран.

Функция  `println!` может выводить только в обычный вывод, поэтому мы должны использовать что-то ещё для вывода в обычный поток ошибок.

### Проверка, куда записываются ошибки

Во-первых, давайте посмотрим, как содержимое, выведенное из `minigrep` в настоящее время записывается в обычный вывод, включая любые сообщения об ошибках, которые мы хотим вместо этого записать в обычный поток ошибок. Мы сделаем это, перенаправив обычный поток вывода в файл и намеренно вызовем ошибку. Мы не будем перенаправлять обычный поток ошибок, поэтому любой содержание, отправленный в поток принятых ошибок будет продолжать отображаться на экране.

Ожидается, что приложения приказной строки будут отправлять сообщения об ошибках в обычный поток ошибок, поэтому мы все равно можем видеть сообщения об ошибках на экране, даже если мы перенаправляем обычный поток вывода в файл. Наша приложение в настоящее время не ведёт себя правильно: мы увидим, что она сохраняет вывод сообщения об ошибке в файл!

Чтобы отобразить это поведение, мы запустим программу с помощью `>` и именем файла *output.txt* в который мы хотим перенаправить обычный поток вывода. Мы не будем передавать никаких переменных, что должно вызвать ошибку:

```console
$  cargo run > output.txt
```

Согласно правил написания `>` указывает оболочке записывать содержимое принятого вывода в *output.txt* вместо экрана. Мы не увидели сообщение об ошибке, которое мы ожидали увидеть на экране, так что это означает, что оно должно быть в файле. Вот что содержит *output.txt*:

```text
Problem parsing arguments: не хватает переменных
```

Да, наше сообщение об ошибке выводится в обычный вывод. Гораздо более полезнее, чтобы подобные сообщения об ошибках выводились во встроенной поток ошибок, поэтому в файл попадают только данные из успешного запуска. Мы поменяем это.

### вывод ошибок в поток ошибок

Мы будем использовать рукопись в приложении 12-24, чтобы изменить способ вывода сообщений об ошибках. Из-за переработки рукописи, которую мы делали ранее в этой главе, вся рукопись, которая выводит сообщения об ошибках, находится в одной функции: `main`. Встроенная библиотека предоставляет макрос `eprintln!`который выводит в обычный поток ошибок, поэтому давайте изменим два места, где мы вызывали `println!` для вывода ошибок, чтобы использовать `eprintln!` вместо этого.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-24/src/main.rs:here}}
```

<span class="caption">Запись сообщений об ошибках в Standard Error вместо Standard Output используя <code>eprintln!</code></span>

Давайте снова запустим программу таким же образом, без каких-либо переменных и перенаправим обычный вывод с помощью `>`:

```console
$ cargo run > output.txt
Problem parsing arguments: не хватает переменных
```

Теперь мы видим ошибку на экране и *output.txt* не содержит ничего, что мы ожидаем от приложения приказной строки.

Давайте снова запустим программу с переменными, которые не вызывают ошибку, но все же перенаправляют обычный вывод в файл, например так:

```console
$ cargo run -- to poem.txt > output.txt
```

Мы не увидим никакого вывода в окно вызова, а *output.txt* будет содержать наши итоги:

<span class="filename">Файл: output.txt</span>

```text
Are you nobody, too?
How dreary to be somebody!
```

Это отображает, что в зависимости от случая мы теперь используем обычный поток вывода для успешного писания и обычный поток ошибок для вывода ошибок.

## Итоги

В этой главе были повторены некоторые основные подходы, которые вы изучили до сих пор и было рассказано, как выполнять обычные действия ввода-вывода в Ржавчине. Используя переменные приказной строки, файлы, переменные среды и макрос`eprintln!` для вывода ошибок и вы теперь готовы писать приложения приказной строки. В сочетании с  подходами из предыдущих глав, Ваша рукопись будет хорошо согласована, будет правильно хранить данные в соответствующих стопках, хорошо обрабатывать ошибки и хорошо проверяться.

Далее мы рассмотрим некоторые возможности Ржавчины, на которые повлияли полезные  языки: замыкания и повторители.
