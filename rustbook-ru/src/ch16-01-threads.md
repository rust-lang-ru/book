## Использование потоков для одновременного выполнения рукописи

В большинстве современных операционных систем программная рукопись выполняется в виде *этапа*, причём операционная система способна управлять несколькими этапами сразу. Программа, в свою очередь, может состоять из нескольких независимых частей, выполняемых одновременно. Средство, благодаря которому эти независимые части выполняются, называется *потоком*. Например, сетевой отдельный вычислитель (Web) может иметь несколько потоков для того, чтобы он мог обрабатывать больше одного запроса за раз.

Разбиение вычислений на несколько потоков может повысить производительность программы, поскольку программа выполняет несколько задач одновременно, но такое разбиение также добавляет сложности. Поскольку потоки могут работать одновременно, неизвестно какой из потоков выполнится раньше - а какой позже. Это может привести к таким неполадкам, как:

- Состояния гонки, когда потоки обращаются к данным, либо внешним источникам, несогласованно.
- Взаимные запреты и ограничения, когда два потока ожидают друг друга, не позволяя тем самым продолжить работу каждому из них.
- Ошибки, которые случаются только в определённых случаях, которые трудно воспроизвести и, соответственно исправить.

Ржавчина пытается решить возникающие сбои при использовании потоков, но программирование в многопоточной среде все ещё требует тщательного обдумывания содержимого рукописи, которая отличается от содержание рукописи программ, работающих в одном потоке.

Языки программирования выполняют потоки несколькими различными способами, и многие операционные системы предоставляют API, который язык может вызывать для создания новых потоков. Обычная библиотека Ржавчины использует прообраз выполнения потоков *1:1*, при которой одному потоку операционной системы соответствует ровно один "языковой" поток. Существуют дополнения, в которых использованы другие подходы многопоточности, отличающиеся от подхода 1:1.

### Создание нового потока с помощью  `spawn`

Чтобы создать новый поток, мы вызываем функцию `thread::spawn` и передаём ей замыкание (мы говорили о замыканиях в главе 13), содержащее рукопись, которую мы хотим запустить в новом потоке. Пример в приложении 16-1 выводит некоторый отрывок из основного потока, а также другой отрывок рукописи из нового потока:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-01/src/main.rs}}
```

<span class="caption">Приложение 16-1: Создание нового потока для вывода чисел от 0 до 9, в то время как основной поток `fn main` выводит что-то другое</span>

Обратите внимание, что когда основной поток `fn main` завершается, все порождённые потоки останавливаются, независимо от того, завершили они работу или нет. Вывод этой рукописи может каждый раз немного отличаться, но он будет выглядеть примерно так:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
Число 1 вызвано из основного потока!
Число 1 вызвано из порожденного потока!
Число 2 вызвано из основного потока!
Число 2 вызвано из порожденного потока!
Число 3 вызвано из основного потока!
Число 3 вызвано из порожденного потока!
Число 4 вызвано из основного потока!
Число 4 вызвано из порожденного потока!
Число 5 вызвано из порожденного потока!
```

Вызовы `thread::sleep` заставляют поток на короткое время останавливать своё выполнение, позволяя выполняться другим потокам. Очерёдность выполнения потоков вероятно будет меняться, но это не обязательно: это зависит от того, как ваша операционная система управляет потоками. В этом круговороте основной поток вызывается первым, несмотря на то, что указание вызова порождённого потока появляется раньше в рукописи. И даже несмотря на то, что мы явно указали вызов порождённого потока до тех пор, пока значение `i` не достигнет числа 9, оно успело дойти только до 5, когда основной поток завершился.

Если вы запустите эту рукопись - то увидите вызовы только из основного потока или не увидите вызовы из других потоков. Попробуйте увеличить числа в рядах, чтобы дать операционной системе больше возможностей для переключения между потоками.

### Ожидание завершения работы всех потоков используя `join`

Рукопись в приложении 16-1 преждевременно останавливает порождённый поток в большинстве случаев, из-за завершения основного потока. Более того, так как порядок выполнения потоков чётко не определён, эта рукопись не даёт заверения, что порождённый поток вообще начнёт исполняться!

Мы можем исправить неполадку, когда созданный поток не запускается или завершается преждевременно, сохранив возвращаемое значение `thread::spawn` в какой-либо переменной. Вид возвращаемого значения `thread::spawn` — `JoinHandle` . `JoinHandle` — это владелец значения, которое, при вызове способа `join` , будет ждать завершения своего потока. Приложение 16-2 отображает, как использовать `JoinHandle` потока, созданного в приложении 16-1, и вызывать функцию `join` , для того, чтобы убедиться, что порождённый поток завершится раньше, чем поток `main`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-02/src/main.rs}}
```

<span class="caption">Приложение 16-2. Добавления владельца `владение` для сохранение значения потока <code>thread::spawn</code> в виде <code>JoinHandle</code>, заверяет, что дополнительный поток выполнит всю необходимую работу, перед тем, как завершится основной поток `fn main` </span>

Вызов способа `join` запрещает исполнение текущему основному потоку, пока порожденный поток, представленный способом `join` не завершится. *Запрет* для потока означает, что потоку запрещено выполнять работу или завершить работу. Поскольку мы поместили вызов `join` после круговорота `for` основного потока, выполнение приложения 16-2 должно привести к выводу, примерно такому:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
Число 1 вызвано из основного потока!
Число 2 вызвано из основного потока!
Число 1 вызвано из порожденного потока!
Число 3 вызвано из основного потока!
Число 2 вызвано из порожденного потока!
Число 4 вызвано из основного потока!
Число 3 вызвано из порожденного потока!
Число 4 вызвано из порожденного потока!
Число 5 вызвано из порожденного потока!
Число 6 вызвано из порожденного потока!
Число 7 вызвано из порожденного потока!
Число 8 вызвано из порожденного потока!
Число 9 вызвано из порожденного потока!
```

Два потока продолжают чередоваться, но основной поток находится в ожидании из-за вызова `владение.join()` и не завершается до тех пор, пока не завершится запущенный поток.

Но давайте посмотрим, что произойдёт, если мы вместо этого переместим `владение.join()` перед круговоротом `for` в `main`, например так:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/no-listing-01-join-too-early/src/main.rs}}
```

Основной поток будет ждать завершения порождённого потока, а затем запустит свой круговорот `for` , поэтому выходные данные больше не будут чередоваться, как показано ниже:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
Число 1 вызвано из порожденного потока!
Число 2 вызвано из порожденного потока!
Число 3 вызвано из порожденного потока!
Число 4 вызвано из порожденного потока!
Число 5 вызвано из порожденного потока!
Число 6 вызвано из порожденного потока!
Число 7 вызвано из порожденного потока!
Число 8 вызвано из порожденного потока!
Число 9 вызвано из порожденного потока!
Число 1 вызвано из основного потока!
Число 2 вызвано из основного потока!
Число 3 вызвано из основного потока!
Число 4 вызвано из основного потока!
```

Небольшие подробности, такие как место вызова `join`, могут повлиять на то, выполняются ли ваши потоки одновременно.

### Использование `move`-замыканий в потоках

Мы часто используем ключевое слово `move` с замыканиями, переданными в `thread::spawn` потому, что в этом случае замыкание получает из окружения права владения на используемые им переменные, таким образом передавая права владения этими переменными от одного потока к другому. В разделе ["Получение ссылок или передача прав владения"] Главы 13 мы обсудили `move` в среде замыканий. Теперь мы сосредоточимся на взаимодействии между `move` и `thread::spawn`.

Обратите внимание, что в приложении 16-1 замыкание, которое мы передаём в `thread::spawn` не принимает переменных: мы не используем никаких данных из основного потока в рукописи порождённого потока. Чтобы использовать данные из основного потока в порождённом потоке, замыкание порождённого потока должно получать значения, которые ему необходимы. Приложение 16-3 показывает попытку создать вектор в главном потоке и использовать его в порождённом потоке. Тем не менее, это не будет работать, как вы увидите через мгновение.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-03/src/main.rs}}
```

<span class="caption">Приложение 16-3: Попытка использовать вектор, созданный основным потоком, в другом потоке</span>

Замыкание использует переменную `v`, поэтому оно получит `v` и сделает его частью окружения замыкания. Поскольку `thread::spawn` запускает это замыкание в новом потоке, мы должны иметь доступ к `v` внутри этого нового потока. Но при сборке этого примера, мы получаем следующую ошибку:

```console
{{#include ../listings/ch16-fearless-concurrency/listing-16-03/output.txt}}
```

Ржавчина *подсказывает* как получить право владения на вектор `v` , В связи с тем, что в `println!` нужна только ссылка на `v` без права владения, то замыкание пытается получить право владения на `v`. Однако есть неполадка: Ржавчина не может определить, как долго по времени будет выполняться порождённый поток, поэтому Ржавчина не знает, во время очередного выполнения потока будет ли всегда действительна ссылка без права владения на `v`.

В приложении 16-4 приведена мысль, которая, с большей вероятностью, будет иметь ссылку на `v`, что будет недопустимо:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-04/src/main.rs}}
```

<span class="caption">Приложение 16-4. Поток с замыканием, который пытается получить ссылку на <code>v</code> из основного потока, удаляющего <code>v</code></span>

Если бы Ржавчина позволила нам запустить эту рукопись, есть вероятность, что порождённый поток был бы немедленно переведён в фоновый режим, не выполнив ничего. Порождённый поток имеет ссылку на `v`, но основной поток немедленно удаляет `v` , используя способ `drop` , который мы обсуждали в главе 15. Затем, когда порождённый поток начинает выполняться, `v` уже не существует, поэтому ссылка на него также будет недействительной. О, нет!

Чтобы исправить ошибку, указанную нам сборщиком в приложении 16-3, мы можем использовать совет, указанный в сообщении об ошибке:

<!-- manual-regeneration
after automatic regeneration, look at listings/ch16-fearless-concurrency/listing-16-03/output.txt and copy the relevant part
-->

```text
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let владение = thread::spawn(move || {
  |                                ++++
```

Добавляя ключевое слово `move` перед замыканием, мы передаём замыканию право владения переменными, вместо того, тем самым исключая ошибку Ржавчины об отсутствии права владения на переменные. Требуемые исправления из Приложения 16-3, внесены в Приложении 16-5, по итогу рукопись будет успешно собрана и запущена так, как мы ожидаем:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-05/src/main.rs}}
```

<span class="caption">Приложение 16-5. Использование ключевого слова <code>move</code> , чтобы замыкание стало владельцем используемых им значений.</span>

У нас может возникнуть соблазн попробовать то же самое, чтобы исправить рукопись в приложении 16.4, где основной поток вызывал `drop` с помощью замыкания `move` . Однако это исправление не сработает, потому что то, что пытается сделать приложение 16.4, запрещено по другой причине. Если мы укажем способ `move` в замыкании, мы передаём право владения `v` замыканию и больше не сможем использовать его нигде, тем более вызвать для него способ `drop` в основном потоке. Разумеется мы получим ошибку сборщика:

```console
{{#include ../listings/ch16-fearless-concurrency/output-only-01-move-drop/output.txt}}
```

Правила владения Ржавчины снова нас спасли! Мы получили те же самую ошибку, что и в рукописи из приложения 16-3, потому что Ржавчина передаёт право владения над вектором `v` только порожденному потоку, соответственно, основной поток ничего не может сделать, так как порождённый поток не возвращает право владения над вектором `v` и соответственно переменная `v` более не действительна. Сообщив Ржавчине о передаче владения `v` в порождаемый поток, мы заверяем Ржавчину, что использование `v` в основном потоке исключено . Если мы изменим Приложение 16-4 таким же образом, то мы нарушаем правила владения при попытке использовать `v` в главном потоке. Ключевое слово `move` определяет поведение, согласно устоявшихся правил Ржавчины по заимствованию, которые не позволяет нам нарушать правила владения.

Имея достаточное понимание о потоках и API потоков, давайте рассмотрим, что мы можем *сделать* с помощью потоков.


["Получение ссылок или передача прав владения"]: ch13-01-closures.html#capturing-references-or-moving-ownership