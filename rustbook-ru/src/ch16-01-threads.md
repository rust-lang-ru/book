## Использование потоков для одновременного выполнения рукописи

В большинстве современных операционных систем программная рукопись выполняется в виде *этапа*, причём операционная система способна управлять несколькими этапами сразу. Приложение, в свою очередь, может состоять из нескольких независимых частей, выполняемых одновременно. Средство, благодаря которому эти независимые части выполняются, называется *потоком*. Например, сетевой отдельный вычислитель (Web) может использовать несколько потоков для того, чтобы обрабатывать больше одного запроса за раз.

Разбиение производимых вычислений в несколько потоков может повысить производительность приложения, поскольку приложение выполняет несколько задач одновременно, но такое разбиение также добавляет сложности. Поскольку потоки могут выполняться одновременно, неизвестно какой из потоков завершиться раньше - а какой позже. Это может привести к таким неполадкам, как:

- Состояния гонки, когда потоки обращаются к данным, либо внешним источникам, несогласованно.
- Взаимные запреты и ограничения, когда два потока ожидают ответ друг от друга, не позволяя тем самым продолжить выполнение каждому из них.
- Ошибки, которые случаются только в определённых случаях, которые трудно воспроизвести и, соответственно исправить.

Ржавчина пытается решить возникающие сбои при использовании потоков, но испольозование многопоточности все ещё требует тщательного обдумывания для правильного написания содержимого рукописи, которая отличается от содержания рукописи приложений, работающих в одном потоке.

Языки программирования выполняют потоки несколькими различными способами, и многие операционные системы предоставляют API, который язык может вызывать для создания новых потоков. Встроенная библиотека Ржавчины использует прообраз выполнения потоков *1:1*, при которой одному потоку операционной системы соответствует ровно один "языковой" поток. Существуют дополнения, в которых использованы другие подходы многопоточности, отличающиеся от подхода 1:1.

### Создание нового потока с помощью  `spawn`

Чтобы создать новый поток, мы вызываем способ (функцию) `thread::spawn` и передаём ей замыкание (мы говорили о замыканиях в главе 13), содержащее рукопись, которую мы хотим запустить в новом потоке. Пример в приложении 16-1 выводит некоторый отрывок из основного потока, а также другой отрывок рукописи из нового потока:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-01/src/main.rs}}
```

<span class="caption">Приложение 16-1: Создание нового потока для вывода чисел от 0 до 9, в то время как основной поток `fn main` выводит что-то другое</span>

Обратите внимание, что когда основной поток `fn main` завершается, все порождённые потоки останавливаются, независимо от того, завершили они работу или нет. Вывод этой рукописи может каждый раз немного отличаться, но он будет выглядеть примерно так:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be из-за the threads запщущен differently rather than
changes in the compiler -->

```text
Число 1 выведено из основного потока!
Число 1 выведено из порожденного потока!
Число 2 выведено из основного потока!
Число 2 выведено из порожденного потока!
Число 3 выведено из основного потока!
Число 3 выведено из порожденного потока!
Число 4 выведено из основного потока!
Число 4 выведено из порожденного потока!
Число 5 выведено из порожденного потока!
```

Вызовы `thread::sleep` заставляют поток на короткое время останавливать своё выполнение, позволяя выполняться другим потокам. Очерёдность выполнения потоков вероятно будет меняться, но это не обязательно: это зависит от того, как ваша операционная система управляет потоками. В этом круговороте основной поток вызывается первым, несмотря на то, что указание вызова порождённого потока появляется раньше в рукописи. И даже несмотря на то, что мы явно указали вызов порождённого потока до тех пор, пока значение `i` не достигнет числа 9, оно успело дойти только до 5, когда основной поток завершился.

Если вы запустите эту рукопись - то увидите вызовы только из основного потока или не увидите вызовы из других потоков. Попробуйте увеличить числовые указатели в рядах круговоротов `for`, чтобы дать операционной системе больше возможностей для переключения между потоками.

### Ожидание завершения работы всех потоков используя `join`

Рукопись в приложении 16-1 преждевременно останавливает порождённый поток в большинстве случаев, из-за завершения основного потока. Более того, так как порядок выполнения потоков чётко не определён, эта рукопись не даёт заверения, что порождённый поток вообще начнёт исполняться!

Мы можем исправить неполадку, когда созданный поток не запускается или завершается преждевременно, сохранив возвращаемое значение `thread::spawn` в какой-либо переменной. Вид возвращаемого значения `thread::spawn` — `JoinHandle` . `JoinHandle` — это владелец значения, которое, при вызове способа `join` , будет ждать завершения своего потока. Приложение 16-2 отображает, как использовать `JoinHandle` потока, созданного в приложении 16-1, и вызывать способ (функцию) `join` , для того, чтобы убедиться, что порождённый поток завершится раньше, чем основной поток `main`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-02/src/main.rs}}
```

<span class="caption">Приложение 16-2. Добавления владельца переменной `владение` служит для присваивания возвращаемого значения потока <code>thread::spawn</code> в виде <code>JoinHandle</code>. Ипользование данного способа заверяет, что порожлённый поток выполнит все вложенные действия, до того, как основной поток `fn main`  завершит все свои действия </span>

Использование способа потока `join` запрещает преждевреенное завершение основного потока. Он не будет завершён пока порожденный поток, представленный способом `join` не выполнит все действия (не завершится). *Запрет* для потока означает, что потоку запрещено выполнять действия или завершиться. Поскольку мы используем способ `join`, размещенный после круговорота основного потока `for` , итог рукописи приложения 16-2 долен привести примерно к следующему итогуу:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be из-за the threads запщущен differently rather than
changes in the compiler -->

```text
Число 1 выведено из основного потока!
Число 2 выведено из основного потока!
Число 1 выведено из порожденного потока!
Число 3 выведено из основного потока!
Число 2 выведено из порожденного потока!
Число 4 выведено из основного потока!
Число 3 выведено из порожденного потока!
Число 4 выведено из порожденного потока!
Число 5 выведено из порожденного потока!
Число 6 выведено из порожденного потока!
Число 7 выведено из порожденного потока!
Число 8 выведено из порожденного потока!
Число 9 выведено из порожденного потока!
```

Два потока продолжают исполняться по очереди, но основной поток не может завершиться из-за использования способа `join()` и завершится только по завершении порождённого потока.

Но давайте посмотрим, что произойдёт, если способ `join()` будет поставлен перед круговоротом основного потока `for` в `main`, например так:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/no-listing-01-join-too-early/src/main.rs}}
```

Основной не будет исполняться до завершения порождённого потока, после чего будет запущен круговорот основного потока `for` . Поэтому выполнение круговоротов больше не будет чередоваться, как показано ниже:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be из-за the threads запщущен differently rather than
changes in the compiler -->

```text
Число 1 выведено из порожденного потока!
Число 2 выведено из порожденного потока!
Число 3 выведено из порожденного потока!
Число 4 выведено из порожденного потока!
Число 5 выведено из порожденного потока!
Число 6 выведено из порожденного потока!
Число 7 выведено из порожденного потока!
Число 8 выведено из порожденного потока!
Число 9 выведено из порожденного потока!
Число 1 выведено из основного потока!
Число 2 выведено из основного потока!
Число 3 выведено из основного потока!
Число 4 выведено из основного потока!
```

Место постановки `join` влияет на выполнение потоков..

### Использование `move`-замыканий в потоках

Мы часто используем ключевое слово `move` с замыканиями, переданными в `thread::spawn` потому, что в этом случае замыкание получает из окружения права владения на используемые им переменные, таким образом передавая права владения этими переменными от одного потока к другому. В разделе ["Получение ссылок или передача прав владения"] Главы 13 мы обсудили способ `move` в среде замыканий. Теперь мы сосредоточимся на взаимодействии между `move` и `thread::spawn`.

Обратите внимание, что в приложении 16-1 замыкание, которое мы используем в `thread::spawn` не принимает переменных: мы не используем никаких данных из основного потока в рукописи порождённого потока. Чтобы использовать переменные или данные из основного потока в порождённом потоке, замыкание в порождённом потоке должно получать значения, которые ему необходимы. Приложение 16-3 показывает попытку создать ряд в основном потоке и использовать его в порождённом потоке. Тем не менее, это не будет работать, как вы увидите через мгновение.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-03/src/main.rs}}
```

<span class="caption">Приложение 16-3: Попытка использовать вектор, созданный основным потоком, в другом потоке</span>

Замыкание использует переменную `v`, поэтому оно получит `v` и сделает его частью окружения замыкания. Поскольку `thread::spawn` запускает это замыкание в новом потоке, мы должны иметь доступ к `v` внутри этого нового потока. Но при сборке этого примера, мы получаем следующую ошибку:

```console
{{#include ../listings/ch16-fearless-concurrency/listing-16-03/output.txt}}
```

Ржавчина *подсказывает* как получить право владения на вектор `v` , В связи с тем, что в `println!` нужна только ссылка на `v` без права владения, то замыкание пытается получить право владения на `v`. Однако есть неполадка: Ржавчина не может определить, как долго по времени будет выполняться порождённый поток, поэтому Ржавчина не знает, во время очередного выполнения потока будет ли всегда действительна ссылка без права владения на `v`.

В приложении 16-4 приведена мысль, которая, с большей вероятностью, будет иметь ссылку на `v`, что будет недопустимо:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-04/src/main.rs}}
```

<span class="caption">Приложение 16-4. Поток с замыканием, который пытается получить ссылку на <code>v</code> из основного потока, удаляющего <code>v</code></span>

Если бы Ржавчина позволила нам запустить эту рукопись, есть вероятность, что порождённый поток был бы немедленно переведён в фоновый режим, не выполнив ничего. Порождённый поток имеет ссылку на `v`, но основной поток немедленно удаляет `v` , используя способ `drop` , который мы обсуждали в главе 15. Затем, когда порождённый поток начинает выполняться, `v` уже не существует, поэтому ссылка на него также будет недействительной. О, нет!

Чтобы исправить ошибку, указанную нам сборщиком в приложении 16-3, мы можем использовать совет, указанный в сообщении об ошибке:

<!-- manual-regeneration
after automatic regeneration, look at listings/ch16-fearless-concurrency/listing-16-03/output.txt and copy the relevant part
-->

```text
помощь: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let владение = thread::spawn(move || {
  |                                ++++
```

Добавляя ключевое слово `move` перед замыканием, мы передаём замыканию право владения переменными, вместо того, тем самым исключая ошибку Ржавчины об отсутствии права владения на переменные. Требуемые исправления из Приложения 16-3, внесены в Приложении 16-5, по итогу рукопись будет успешно собрана и запущена так, как мы ожидаем:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-05/src/main.rs}}
```

<span class="caption">Приложение 16-5. Использование ключевого слова <code>move</code> , чтобы замыкание стало владельцем используемых им значений.</span>

У нас может возникнуть соблазн попробовать то же самое, чтобы исправить рукопись в приложении 16.4, где основной поток вызывал `drop` с помощью замыкания `move` . Однако это исправление не сработает, потому что то, что пытается сделать приложение 16.4, запрещено по другой причине. Если мы укажем способ `move` в замыкании, мы передаём право владения `v` замыканию и больше не сможем использовать его нигде, тем более вызвать для него способ `drop` в основном потоке. Разумеется мы получим ошибку сборщика:

```console
{{#include ../listings/ch16-fearless-concurrency/output-only-01-move-drop/output.txt}}
```

Правила владения Ржавчины снова нас спасли! Мы получили те же самую ошибку, что и в рукописи из приложения 16-3, потому что Ржавчина передаёт право владения над вектором `v` только порожденному потоку, соответственно, основной поток ничего не может сделать, так как порождённый поток не возвращает право владения над вектором `v` и соответственно переменная `v` более не действительна. Сообщив Ржавчине о передаче владения `v` в порождаемый поток, мы заверяем Ржавчину, что использование `v` в основном потоке исключено . Если мы изменим Приложение 16-4 таким же образом, то мы нарушаем правила владения при попытке использовать `v` в основном потоке. Ключевое слово `move` определяет поведение, согласно устоявшихся правил Ржавчины по заимствованию, которые не позволяет нам нарушать правила владения.

Имея достаточное понимание о потоках и API потоков, давайте рассмотрим, что мы можем *сделать* с помощью потоков.


["Получение ссылок или передача прав владения"]: ch13-01-closures.html#capturing-references-or-moving-ownership