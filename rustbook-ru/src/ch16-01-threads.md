## Использование потоков для одновременного выполнения рукописи

В большинстве современных операционных систем программная рукопись выполняется в виде *этапа*, причём операционная система способна управлять несколькими этапами сразу. Программа, в свою очередь, может состоять из нескольких независимых частей, выполняемых одновременно. Средство, благодаря которому эти независимые части выполняются, называется *потоком*. Например, сетевой отдельный вычислитель (Web) может иметь несколько потоков для того, чтобы он мог обрабатывать больше одного запроса за раз.

Разбиение вычислений на несколько потоков может повысить производительность программы, поскольку программа выполняет несколько задач одновременно, но такое разбиение также добавляет сложности. Поскольку потоки могут работать одновременно, неизвестно какой из потоков выполнится раньше - а какой позже. Это может привести к таким неполадкам, как:

- Состояния гонки, когда потоки обращаются к данным, либо внешним источникам, несогласованно.
- Взаимные запреты и ограничения, когда два потока ожидают друг друга, не позволяя тем самым продолжить работу каждому из них.
- Ошибки, которые случаются только в определённых случаях, которые трудно воспроизвести и, соответственно исправить.

Ржавчина пытается решить возникающие сбои при использовании потоков, но программирование в многопоточной среде все ещё требует тщательного обдумывания содержимого рукописи, которая отличается от содержание рукописи программ, работающих в одном потоке.

Языки программирования выполняют потоки несколькими различными способами, и многие операционные системы предоставляют API, который язык может вызывать для создания новых потоков. Обычная библиотека Ржавчины использует прообраз выполнения потоков *1:1*, при которой одному потоку операционной системы соответствует ровно один "языковой" поток. Существуют дополнения, в которых выполнены другие подходы многопоточности, отличающиеся от подходы 1:1.

### Создание нового потока с помощью  `spawn`

Чтобы создать новый поток, мы вызываем функцию `thread::spawn` и передаём ей замыкание (мы говорили о замыканиях в главе 13), содержащее рукопись, которую мы хотим запустить в новом потоке. Пример в приложении 16-1 выводит некоторый писание из основного потока, а также другой писание из нового потока:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-01/src/main.rs}}
```

<span class="caption">Приложение 16-1: Создание нового потока для выводе определённого писания, в то время как основной поток выводит что-то другое</span>

Обратите внимание, что когда основной поток программы на Ржавчине завершается, все порождённые потоки закрываются, независимо от того, завершили они работу или нет. Вывод этой программы может каждый раз немного отличаться, но он будет выглядеть примерно так:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
```

Вызовы `thread::sleep` заставляют поток на короткое время останавливать своё выполнение, позволяя выполняться другим потокам. Очерёдность выполнения потоков вероятно будет меняться, но это не обязательно: это зависит от того, как ваша операционная система рассчитывает потоки. В этом круговороте основной поток выводит первым, несмотря на то, что указание выводе из порождённого потока появляется раньше в рукописи. И даже несмотря на то, что мы указали порождённый поток выводить до тех пор, пока значение `i` не достигнет числа 9, оно успело дойти только до 5, когда основной поток завершился.

Если вы запустите эту рукопись и увидите вывод только из основного потока или не увидите выводе из других потоков, попробуйте увеличить числа в рядах, чтобы дать операционной системе больше возможностей для переключения между потоками.

### Ожидание завершения работы всех потоков используя `join`

Рукопись в приложении 16-1 преждевременно останавливает порождённый поток в большинстве случаев, из-за завершения основного потока. Более того, так как порядок выполнения потоков чётко не определён, эта рукопись не даёт заверения, что порождённый поток вообще начнёт исполняться!

Мы можем исправить неполадку, когда созданный поток не запускается или завершается преждевременно, сохранив возвращаемое значение `thread::spawn` в какой-либо переменной. Вид возвращаемого значения `thread::spawn` — `JoinHandle` . `JoinHandle` — это владеющее значение, которое, при вызове способа `join` , будет ждать завершения своего потока. Приложение 16-2 отображает, как использовать `JoinHandle` потока, созданного в приложении 16-1, и вызывать функцию `join` , для того, чтобы убедиться, что порождённый поток завершится раньше, чем поток `main`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-02/src/main.rs}}
```

<span class="caption">Приложение 16-2. Сохранение значения <code>JoinHandle</code> потока <code>thread::spawn</code> , обеспечивающее, что поток выполнит всю необходимую работу, перед тем, как завершится</span>

Вызов `join` у указателя запрещает текущий поток, пока поток, представленный указателем не завершится. *Запрет* потока означает, что потоку запрещено выполнять работу или выходить из него. Поскольку мы поместили вызов `join` после круговорота `for` основного потока, выполнение приложения 16-2 должно привести к выводу, подобному следующему:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
```

Два потока продолжают чередоваться, но основной поток находится в ожидании из-за вызова `handle.join()` и не завершается до тех пор, пока не завершится запущенный поток.

Но давайте посмотрим, что произойдёт, если мы вместо этого переместим `handle.join()` перед круговоротом `for` в `main`, например так:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/no-listing-01-join-too-early/src/main.rs}}
```

Основной поток будет ждать завершения порождённого потока, а затем запустит свой круговорот `for` , поэтому выходные данные больше не будут чередоваться, как показано ниже:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
```

Небольшие подробности, такие как место вызова `join`, могут повлиять на то, выполняются ли ваши потоки одновременно.

### Использование `move`-замыканий в потоках

Мы часто используем ключевое слово `move` с замыканиями, переданными в `thread::spawn`, потому что в этом случае замыкание получает из окружения права владения на используемые им значения, таким образом передавая права владения этими значениями от одного потока к другому. В разделе ["Захват ссылок или перемещение прав владения"] Главы 13 мы обсудили `move` в среде замыканий. Теперь мы сосредоточимся на взаимодействии между `move` и `thread::spawn`.

Обратите внимание, что в приложении 16-1 замыкание, которое мы передаём в `thread::spawn` не принимает переменных: мы не используем никаких данных из основного потока в рукописи порождённого потока. Чтобы использовать данные из основного потока в порождённом потоке, замыкание порождённого потока должно захватывать значения, которые ему необходимы. Приложение 16-3 показывает попытку создать вектор в главном потоке и использовать его в порождённом потоке. Тем не менее, это не будет работать, как вы увидите через мгновение.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-03/src/main.rs}}
```

<span class="caption">Приложение 16-3: Попытка использовать вектор, созданный основным потоком, в другом потоке</span>

Замыкание использует переменную `v`, поэтому оно захватит `v` и сделает его частью окружения замыкания. Поскольку `thread::spawn` запускает это замыкание в новом потоке, мы должны иметь доступ к `v` внутри этого нового потока. Но при сборке этого примера, мы получаем следующую ошибку:

```console
{{#include ../listings/ch16-fearless-concurrency/listing-16-03/output.txt}}
```

Ржавчина *выводит* как захватить `v` и так как в `println!` нужна только ссылка на `v`, то замыкание пытается заимствовать `v`. Однако есть неполадка: Ржавчина не может определить, как долго будет работать порождённый поток, поэтому он не знает, будет ли всегда действительной ссылка на `v`.

В приложении 16-4 приведён задумка, который с большей вероятностью будет иметь ссылку на `v`, что будет недопустимо:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-04/src/main.rs}}
```

<span class="caption">Приложение 16-4. Поток с замыканием, который пытается захватить ссылку на <code>v</code> из основного потока, удаляющего <code>v</code></span>

Если бы Ржавчина позволил нам запустить эту рукопись, есть вероятность, что порождённый поток был бы немедленно переведён в фоновый режим, не выполнив ничего. Порождённый поток имеет ссылку на `v`, но основной поток немедленно удаляет `v` , используя функцию `drop` , которую мы обсуждали в главе 15. Затем, когда порождённый поток начинает выполняться, `v` уже не существует, поэтому ссылка на него также будет недействительной. О, нет!

Чтобы исправить ошибку сборщика в приложении 16-3, мы можем использовать совет из сообщения об ошибке:

<!-- manual-regeneration
after automatic regeneration, look at listings/ch16-fearless-concurrency/listing-16-03/output.txt and copy the relevant part
-->

```text
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
```

Добавляя ключевое слово `move` перед замыканием, мы заставляем замыкание забирать используемые значения во владение, вместо того, чтобы позволить Ржавчина вывести необходимость заимствования значения. Изменение Приложения 16-3, показанная в Приложении 16-5, будет собрана и запущена так, как мы ожидаем:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-05/src/main.rs}}
```

<span class="caption">Приложение 16-5. Использование ключевого слова <code>move</code> , чтобы замыкание стало владельцем используемых им значений.</span>

У нас может возникнуть соблазн попробовать то же самое, чтобы исправить рукопись в приложении 16.4, где основной поток вызывал `drop` с помощью замыкания `move` . Однако это исправление не сработает, потому что то, что пытается сделать приложение 16.4, запрещено по другой причине. Если мы добавим `move` к замыканию, мы переместим `v` в окружение замыкания и больше не сможем вызывать для него `drop` в основном потоке. Вместо этого мы получим эту ошибку сборщика:

```console
{{#include ../listings/ch16-fearless-concurrency/output-only-01-move-drop/output.txt}}
```

Правила владения Ржавчины снова нас спасли! Мы получили ошибку рукописи из приложения 16-3, потому что Ржавчина была устоявшийся и заимствовал `v` только для потока, что означало, что основной поток предположительно может сделать недействительной ссылку на порождённый поток. Сообщив Ржавчине о передаче владения `v` в порождаемый поток, мы заверяем Ржавчина, что основной поток больше не будет использовать `v`. Если мы изменим Приложение 16-4 таким же образом, то мы нарушаем правила владения при попытке использовать `v` в главном потоке. Ключевое слово `move` отменяет основное устоявшееся поведение Ржавчины по заимствованию, что не позволяет нам нарушать правила владения.

Имея достаточное понимание потоков и API потоков, давайте посмотрим, что мы можем *делать* с помощью потоков.


["Захват ссылок или перемещение прав владения"]: ch13-01-closures.html#capturing-references-or-moving-ownership