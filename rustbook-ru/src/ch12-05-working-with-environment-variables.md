## Работа с переменными окружения

Мы улучшим `minigrep`, добавив дополнительную функцию: возможность для поиска без учёта заглавных или строчных букв, которую пользователь может включить с помощью переменной среды окружения. Мы могли бы сделать эту функцию свойством приказной строки и потребовать, чтобы пользователи вводили бы её каждый раз при её применении, но вместо этого мы будем использовать переменную среды окружения, что позволит нашим пользователям устанавливать переменную среды один раз и все поиски будут не чувствительны к заглавным или строчным буквам в этом окно  онка вызова .

### Написание ошибочного проверки для функции `search` с учётом заглавных или строчных букв

Мы, во-первых, добавим новую функцию `search_case_insensitive`, которую мы будем вызывать, когда переменная окружения содержит значение. Мы продолжим следовать этапу TDD, поэтому первый шаг - это снова написать не проходящий проверку. Мы добавим новую проверку для новой функции `search_case_insensitive` и переименуем нашу старую проверку из `one_result` в `case_sensitive`, чтобы прояснить различия между двумя проверками, как показано в приложении 12-20.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-20/src/lib.rs:here}}
```

<span class="caption">Приложение 12-20: Добавление нового не проходящего проверки для функции поиска нечувствительной к  заглавным или строчным буквам, которую мы собираемся добавить</span>

Обратите внимание, что мы также изменили содержимое переменной `contents` из старого проверки. Мы добавили новую строку с писанием `"Duct tape."`, используя заглавную D, которая не должна соответствовать запросу `"duct"` при поиске с учётом заглавных или строчных букв. Такое изменение старого проверки помогает избежать случайного нарушения возможности поиска чувствительного к заглавным или строчным буквам, который мы уже выполнили. Эта проверка должна пройти сейчас и должна продолжать выполняться успешно, пока мы работаем над поиском без учёта заглавных или строчных букв.

Новая проверка для поиска *нечувствительного* к заглавным или строчным буквам использует `"рЖавчинА"` качестве строки запроса. В функции `search_case_insensitive`, которую мы собираемся выполнить, запрос `"рЖавчинА"` должна соответствовать строке содержащей `"Ржавчина:"` с большой буквы R и соответствовать строке `"Trust me."`, хотя обе имеют разные буквы (строчные и заглавные) из запроса. Это наша не проходящая проверка, она не собирается, потому что мы ещё не определили функцию `search_case_insensitive`. Не стесняйтесь добавлять скелет выполнение, которая всегда возвращает пустой вектор, подобно тому, как мы это делали для функции `search` в приложении 12-16, чтобы увидеть сборку проверки и его сбой.

### Выполнение функции `search_case_insensitive`

Функция `search_case_insensitive`, показанная в приложении 12-21, будет почти такая же, как функция `search`. Разница лишь в том, что писание будет строчными буквами для `query` и для каждой `line`, так что для любых букв (строчных или заглавных) входных переменных это будет тот же случай, когда мы проверяем, содержит ли строка запрос.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-21/src/lib.rs:here}}
```

<span class="caption">Приложение 12-21: Определение функции <code>search_case_insensitive</code> с уменьшением регистра строки запроса и строки содержимого перед их сравнением</span>

Сначала преобразуем в нижний регистр строку `query` и сохраняем её в затенённой переменной с тем же именем. Вызов `to_lowercase` для строки запроса необходим, так что независимо от того, будет ли пользовательский запрос `"ржавчина"` , `"РЖАВЧИНА"`, `"Ржавчина"` или `"рЖавчина"`, мы будем преобразовывать запрос к `"ржавчина"` и делать значение нечувствительным к заглавным или строчным буквам. Хотя `to_lowercase` будет обрабатывать Unicode, он не будет точным на 100%. Если бы мы писали существующее приложение, мы бы хотели проделать здесь немного больше работы, но этот раздел посвящён переменным среды, а не Unicode, поэтому мы оставим это здесь.

Обратите внимание, что `query` теперь имеет вид данных `String`, а не срез строки, потому что вызов `to_lowercase` создаёт новые данные, а не ссылается на существующие.  К примеру, запрос: `"рЖавчина"` это срез строки не содержащий строчных букв `u` или `t`, которые мы можем использовать, поэтому мы должны выделить новую `String`, содержащую `«ржавчина»`. Когда мы передаём запрос `query` в качестве переменной способа `contains`, нам нужно добавить знак, поскольку ярлык `contains`, определена для приёмы среза строки.

Затем мы добавляем вызов `to_lowercase` для каждой строки `line` для преобразования всех знаков строчными. Теперь, когда мы преобразовали `line` и `query` в нижний регистр, мы найдём совпадения независимо от того, в каком регистре находится переменная с запросом.

Давайте посмотрим, проходит ли эта выполнение проверки:

```console
{{#include ../listings/ch12-an-io-project/listing-12-21/output.txt}}
```

Отлично! Проверки прошли. Теперь давайте вызовем новую функцию `search_case_insensitive` из функции `run`. Во-первых, мы добавим свойство настройке в стопку `Config` для переключения между поиском с учётом заглавных или строчных букв и без учёта данного условия. Добавление этого поля приведёт к ошибкам сборщика, потому что мы ещё нигде не объявим это поле:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-22/src/lib.rs:here}}
```

Мы добавили поле `ignore_case`, которое содержит разумное значение. Далее нам нужна функция `run`, чтобы проверить значение поля `ignore_case` и использовать его, чтобы решить, вызывать ли функцию `search` или функцию `search_case_insensitive`, как показано в приложении 12-22. Эта рукопись все ещё не собирается.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-22/src/lib.rs:there}}
```

<span class="caption">Приложение 12-22: Вызов либо <code>search</code>, либо <code>search_case_insensitive</code> на основе значения в <code>config.ignore_case</code></span>

Наконец, нам нужно проверить переменную среды. Функции для работы с переменными среды находятся в разделе `env` встроенной библиотеки, поэтому мы хотим подключить это раздел в область видимости в верхней части <em>src/lib.rs</em>. Затем мы будем использовать функцию `var` из раздела `env` для проверки установлено ли любое значение в переменной среды с именем `IGNORE_CASE`, как показано в приложении 12-23.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-23/src/lib.rs:here}}
```

<span class="caption">Приложение 12-23: Проверка переменной среды с именем <code>IGNORE_CASE</code></span>

Здесь мы создаём новую переменную `ignore_case`. Чтобы установить её значение, мы вызываем функцию `env::var` и передаём ей имя переменной окружения `IGNORE_CASE`. Функция `env::var` возвращает `Result`, который будет успешным исходом `Ok` содержащий значение переменной среды, если переменная среды установлена. Он вернёт исход `Err`, если переменная окружения не установлена.

Мы используем способ `is_ok` у `Result`, чтобы проверить установлена ли переменная окружения, что будет означать, что программа должна выполнить поиск без учёта заглавных или строчных букв. Если переменная среды `IGNORE_CASE` не содержит любого значения, то `is_ok` вернёт значение false и программа выполнит поиск c учётом заглавных или строчных букв. Мы не заботимся о <em>значении</em> переменной среды, нас важно только установлена она или нет, поэтому мы проверяем `is_ok`, а не используем `unwrap`, `expect` или любой другой способ, который мы видели у `Result`.

Мы передаём значение переменной `ignore_case` образцу данных `Config`, чтобы функция `run` могла прочитать это значение и решить, следует ли вызывать `search` или `search_case_insensitive`, как мы выполнили в приложении 12-22.

Давайте попробуем! Во-первых, мы запустим нашу программу без установленной переменной среды и с помощью значения запроса `to`, который должен соответствовать любой строке, содержащей слово «to» в нижнем регистре:

```console
{{#include ../listings/ch12-an-io-project/listing-12-23/output.txt}}
```

Похоже, все ещё работает! Теперь давайте запустим программу с `IGNORE_CASE`, установленным в `1`, но с тем же значением запроса `to`.

```console
$ IGNORE_CASE=1 cargo run -- to poem.txt
```

Если вы используете PowerShell, вам нужно установить переменную среды и запустить программу двумя приказами, а не одним:

```console
PS> $Env:IGNORE_CASE=1; cargo run -- to poem.txt
```

Это заставит переменную окружения `IGNORE_CASE` сохраниться до конца сеанса работы окне вывода. Переменную можно отключить с помощью приказов `Remove-Item`:

```console
PS> Remove-Item Env:IGNORE_CASE
```

Мы должны получить строки, содержащие «to», которые могут иметь заглавные буквы:

<!-- manual-regeneration
cd listings/ch12-an-io-project/listing-12-23
IGNORE_CASE=1 cargo run -- to poem.txt
can't extract because of the environment variable
-->

```console
Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
```

Отлично, мы также получили строки, содержащие «To»! Наша программа `minigrep` теперь может выполнять поиск без учёта заглавных или строчных букв, управляемая переменной среды. Теперь вы знаете, как управлять свойствами, заданными с помощью переменных приказной строки или переменных среды.

Некоторые программы допускают использование переменных *и* переменных среды для одной и той же настройке. В таких случаях программы решают, что из них имеет больший приоритет. Для другого самостоятельного упражнения попробуйте управлять чувствительностью к заглавным или строчным буквам с помощью переменной приказной строки или переменной окружения. Решите, переменная приказной строки или переменная среды будет иметь приоритет, если программа выполняется со значениями "учитывать регистр" в одном случае, и "пренебрегать регистр" в другом.

Раздел `std::env` содержит много других полезных функций для работы с переменными среды: ознакомьтесь с его пособием, чтобы узнать доступные.
