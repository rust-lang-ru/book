## Что же такое владение?

*Владение* является центральной особенностью языка Rust. Хотя эту особенность легко объяснить, она весьма сильно повлияла на остальную часть языка.

Все программы должны управлять способом использования памяти компьютера во время работы. В некоторых языках есть система сборки мусора (garbage collection, GC) постоянно следящая за памятью, которая больше не используется программой. В других языках программист должен явно запросить и освободить память. Rust использует третий подход: память управляется с помощью системы владения с набором правил, которые компилятор проверяет только во время компиляции программы. Ни одно из правил владения не замедляет выполнение программы.

Так как эта концепция ещё нова для многих программистов, её осознание и эффективное использование потребует определённого времени. Хорошая новость в том, что чем более опытным вы становитесь, тем сможете более естественно разрабатывать код, являющийся безопасным и эффективным. Думаю, что цель этого стоит.

Понимание концепции владения даст вам основу для понимания всех остальных особенностей, делающих Rust уникальным. В этой главе вы изучите владение на примерах, которые сфокусированы на наиболее часто используемой структуре данных строкового типа.

> ### Стек и куча (heap)
> Во многих языках программирования вам обычно не приходится часто думать о стеке или памяти в куче. Для системного языка программирование место хранения переменной (стек или куча) имеет больше влияния на то, как язык ведёт себя и почему необходимо принимать определённые решения. Позже в данной главе будет описана часть правил владения относительно стека и кучи, а краткое объяснение идёт при подготовке.
> Стек и куча являются частями памяти доступной вашему коду во время выполнения, но они структурированы по разному. Стек сохраняет значения в порядке получения данных и удаляет их в обратном порядке. Это упоминается как концепция *последний зашёл, первый вышел*. Подумайте о стеке как о стопке тарелок: при добавлении тарелок вы размещаете их сверху стопки, а когда тарелка нужна берете её сверху. Добавление и удаление тарелок из середины или снизу не работает! Добавление данных называется *помещением в стек*, а удаление называется *извлечением из стека*.
> Все данные сохраняемые в стеке должны быть известны и иметь фиксированный размер. Данные с неизвестным размером во время компиляции или размером, который может изменится должны сохраняться в куче. Куча является менее организованной: при размещении данных в куче запрашивается определённое количество памяти. Операционная система находит пустой участок кучи, являющийся достаточно большим, помечает его как используемый и возвращает *указатель*, который является адресом данного участка. Данный процесс называется *выделением в куче* и иногда сокращённо называется просто *выделение*. Размещение значений в стеке не считается выделением. По причине того, что указатель имеет известный, фиксированный размер, его можно сохранить в стеке, но когда вам нужны сами данные необходимо проследовать по указателю.
> Подумайте о том, как если бы вы сидели в ресторане. Когда вы заходите, вы указываете количество людей в вашей группе, обслуживающий персонал ищет пустой стол подходящий для всех и ведёт вас к нему. Если кто-то из группы придёт позже, они могут спросить где вы сидите, чтобы вас найти.
> Размещение в стек происходит быстрее, чем выделение в куче, потому что операционная система никогда не делает поиска места для хранения новых данных. Местом размещения всегда является верхушка стека. Выделение памяти в куче требует больше работы, потому что операционная система должна сначала найти достаточно большой участок памяти для хранения данных и затем выполнить резервирование, чтобы подготовится к следующему выделению.
> Доступ данных в куче является более медленным, чем в стеке, потому что необходимо сначала проследовать по указателю для получения данных. Современные процессоры работают быстрее, если они меньше "прыгают" по памяти. Продолжая аналогию, представьте официанта в ресторане, который принимает заказы с нескольких столов. Наиболее эффективным является получение всех заказов со стола перед тем как идти к следующему столу. Принимать один заказ со стола A, затем со стола B, а затем снова со стола A и снова со стола B будет гораздо более медленным процессом. Кроме того, процессор может лучше выполнить работу, если оперирует данными близкими к другим данным (подобно тому как в стеке), а не дальше (как это может быть в куче). Выделение большого количества памяти в куче также занимает время.
> При вызове функции значения передаваемые в неё (потенциально включая и указатели на данные в куче) и локальные переменные функции размещаются в стеке. Когда функция завершается, эти значения извлекаются из стека.
> Отслеживание какие части кода используют данные в куче, минимизация количества дубликатов данных в ней и очистка не используемых там данных, чтобы не закончилась вся память - это все проблемы, которые решает владение. Как только вы поймёте владение, вам больше не понадобится слишком часто думать про стек и кучу. Понимание того, что владение существует для управления данными в куче, помогает объяснить, почему это все работает и как.

### Правила владения

Прежде всего, давайте познакомимся с самими правилами.  Пожалуйста, помните о них во время работы с примерами сделанными для их иллюстрации:

- Каждое значение имеет переменную, которая называется *владельцем* значения.
- У значения может быть только один владелец в один момент времени.
- Когда владелец переменной покидает область видимости, значение удаляется.

### Область видимости переменной

Мы уже прошлись по примеру Rust программы в главе 2. После прохождения базового синтаксиса, мы не будем включать в примеры код функции `fn main() {`, так что если вы будете следовать примерам, вам нужно будет поместить следующие примеры внутрь функции `main` самостоятельно. В результате наши пример будут немного короче и мы сможем фокусироваться на деталях, а не на шаблонном коде.

В качестве первого примера владения мы рассмотрим *область видимости* переменных. Область видимость является диапазоном внутри программы, в котором элемент программы является действительным. Например, есть переменная, которая выглядит так:

```rust
let s = "hello";
```

Переменная `s` ссылается на строковый литерал и значение данной переменной жёстко задано в коде программы. Переменная считается действительной с момента её объявления до конца текущей *области видимости*. В листинге 4-1 есть комментарии с аннотациями где переменная `s` является действительной.

```rust
{  // здесь переменная s не действительна, т.к. ещё не объявлена
     let s = "hello";   // s действительна с этого места и далее

     // операции над переменной s
}   // данная область видимости закончилась, s больше нет
```

<span class="caption">Листинг 4-1: переменная и область видимости в которой она действительна</span>

Другими слова, здесь есть два важных момента:

- когда переменная `s` *появляется* в области видимости, она считается действительной,
- она остаётся действительной до момента *выхода* за границы этой области.

На этом этапе объяснения, взаимосвязь между областями действия и допустимостью переменных аналогична той, что существует в других языках программирования. Теперь мы будем опираться на это понимание, введя тип `String`.

### Тип данных `String`

Для иллюстрации правил владения нужен тип данных более сложный чем, те которые были в разделе ["Типы данных"]<!--  --> главы 3. Типы описанные ранее, являются типами сохраняемыми в стеке и извлекаемые из него, когда их область видимости заканчивается. Но мы хотим рассмотреть данные сохранённые в куче и изучить как Rust знает, в какой момент нужно очищать эти данные.

Воспользуемся типом `String` в качестве примера и сконцентрируемся на частях `String` относящихся ко владению. Данные аспекты применимы и для более сложных типов данных, не важно предоставлены ли они из стандартной библиотеки  или созданы вами. Мы ещё обсудим более детально тип `String` в главе 8.

Мы видели строковые литералы в которых значение строки жёстко закодировано в программе. Строковые литералы удобны, но не подходят для любой ситуации в которой хотим использовать текст. Одна из причин  это не изменяемость данных литерала. Другая причина в том, что не любое строковое значение может быть известным при написании кода: например, что если хочется получить ввод пользователя и сохранить его? В данной ситуации Rust имеет второй строковый тип `String`. Память этому типу выделяется в куче, так что можно сохранять количество текста не известное во время компиляции. Можно создать  `String` из строкового литерала используя функцию `from`, вот так:

```rust
let s = String::from("hello");
```

Два двоеточия (`::`) является оператором, который позволяет воспользоваться в текущем пространстве имён функцией `from` для типа `String` вместо использования некоторого имени функции `string_from`. Мы обсудим синтаксис детальнее в разделе ["Синтаксис методов"]<!--  --> главы 5 и когда поговорим про пространства имён с модулями ["Путь для обращения к элементу в дереве модулей"]<!--  --> главы 7.

Такие строки *могут* быть изменены:

```rust
let mut s = String::from("hello");

s.push_str(", world!"); // push_str() присоединяет след.литерал к String

println!("{}", s); // Печатает `hello, world!`
```

В чем здесь разница? Почему `String` можно менять, а литерал нельзя? Разница в том, как эти два типа работают с памятью.

### Память и способы её выделения

В случае строкового литерала мы знаем его содержимое во время компиляции, так что текст жёстко закодирован напрямую в выполняемый файл. Это причина того, что строковые литералы являются быстрыми и эффективными. Но эти свойства приходят только из-за не изменяемости строковых литералов. К сожалению, нельзя поместить неопределённый кусок памяти в выполняемый файл для каждого кусочка текста, размер которого не известен при компиляции и который может менять свой размер во время выполнения программы.

Чтобы поддерживать изменяемый, увеличивающийся кусок текста типа `String`, ему необходимо выделять память в куче неизвестное во время компиляции для всего содержимого. Это означает:

- Память нужно запрашивать у операционной системы во время выполнения программы.
- Необходим способ возврата этой памяти операционной системе, когда мы закончили работу со `String`.

Первая часть сделана нами, когда вызывается `String::from`, реализация запрашивает необходимую память. Это является довольно универсальным подходом в языках программирования.

Тем не менее, вторая часть отличается. В языках со *сборщиком мусора*, сборщик отслеживает и очищает память, которая больше не используется и не нужно про это думать. Без сборщика мусора, мы отвечаем за определение момента, когда память больше не используется и вызываем код явно возвращающий память, также как когда запрашивали её. Корректное выполнение этих действий было исторически сложной проблемой программирования. Если забываем освободить, то теряем память. Если освободим слишком рано, то получим не действительную переменную. Если освободим дважды, это тоже будет ошибкой. Нужно связать ровно одно `выделение` с ровно одним `освобождением`.

Rust выбирает другой путь: память автоматически возвращается как только переменная владеющая памятью выходит из области видимости. Вот версия примера с областью видимости из листинга 4-1 использующего тип `String` вместо строкового литерала:

```rust
{
     let s = String::from("hello"); // s действительна отсюда и далее

      // действия над s
} // область видимости закончилась s больше не действительна
```

Здесь есть естественная точка в которой можно вернуть память занимаемую `String` обратно в операционную систему: когда переменная `s` уходит из области видимости. Когда переменная выходит из области видимости, Rust вызывает специальную функцию вместо нас. Данная функция называется `drop` и это место где автор `String` может поместить код для возвращения памяти. Rust вызывает `drop` автоматически на символе закрывающая скобка.

> Заметьте: Данный шаблон освобождения ресурсов в конце цикла жизни переменной в C++ иногда называется  *Resource Acquisition Is Initialization (RAII)*. Функция `drop` в Rust будет вам знакома, если вы уже использовали шаблон RAII.

Этот шаблон оказывает глубокое влияние на способ написания кода в Rust. Сейчас это может казаться простым, но  в более сложных ситуациях поведение кода может быть неожиданным, когда хочется иметь несколько переменных использующих данные выделенные в куче. Изучим несколько таких ситуаций.

#### Способы взаимодействия переменных и данных: перемещение

Множество переменных могут взаимодействовать разными способами с одинаковыми данными в Rust. Давайте рассмотрим пример использующий целое в листинге 4-2.

```rust
let x = 5;
let y = x;
```

<span class="caption">Листинг 4-2: назначение значения целого из переменной <code>x</code> в <code>y</code></span>

Возможно мы догадаемся, что делает данный код: “привязать значение `5` к переменной `x`; затем сделать копию значения `x` и привязать его к переменной `y`.” Теперь у нас две переменные, `x` и `y`, обе равны `5`. Действительно тут  происходит именно это, потому что целые являются простыми значениями с известным, фиксированным размером и эти два значения `5` размещаются в стеке.

Теперь рассмотрим версию с типом `String`:

```rust
let s1 = String::from("hello");
let s2 = s1;
```

Выглядит очень похоже на предыдущий код, так что мы могли бы подумать, что этот код работает наверное тем же образом: то есть вторая строка могла бы сделать копию значения `s1` и привязать его к `s2`. Но это не совсем то, что происходит.

Посмотрим на рисунок 4-1 и разберём, что происходит со `String` под капотом. Тип `String` состоит из трёх частей показанных слева: указатель на память занятую содержимым строки, длина и ёмкость. Данная группа данных сохраняется в стеке. Справа память в куче, которая хранит содержимое строки.


<img alt="String in memory" src="https://github.com/ruRust/book/blob/master/rustbook-en/src/img/trpl04-01.svg?raw=true" class="center" style="width: 50%;">

<span class="caption">Рисунок 4-1: представление в памяти строки <code>String</code> содержащей значение <code>"hello"</code> привязанное к <code>s1</code></span>

Длина - это сколько байт памяти использует содержимое  `String` в данный момент. Ёмкость - это общее количество байт памяти, которые `String` получила от операционной системы. Разница между длиной и ёмкостью имеет значение, но не в данном контексте, сейчас можно игнорировать ёмкость.

Когда мы назначили `s1` переменной `s2`, то данные типа `String` были скопированы, что означает мы скопировали указатель, длину и ёмкость, которые находятся в стеке. Мы не копируем данные в куче на которые ссылается указатель. Другими словами данные представленные в памяти выглядят как на картинке 4-2.


<img alt="s1 and s2 pointing to the same value" src="https://github.com/ruRust/book/blob/master/rustbook-en/src/img/trpl04-02.svg?raw=true" class="center" style="width: 50%;">

<span class="caption">Картинка 4-2: представление в памяти переменной <code>s2</code>, которая является копией указателя, длины и ёмкости переменной <code>s1</code></span>

Представление *НЕ* выглядит как на картинке 4-3, при котором память могла бы выглядеть как, если бы Rust ещё скопировал и сами данные в куче. Если Rust сделал бы это, то операция `s2 = s1` могла бы быть очень дорогостоящей в смысле производительности времени выполнения, если данные в куче были бы большими.


<img alt="String in memory" src="https://github.com/ruRust/book/blob/master/rustbook-en/src/img/trpl04-03.svg?raw=true" class="center" style="width: 50%;">

<span class="caption">Картинка 4-3: другая возможность того, как можно было бы сделать при <code>s2 = s1</code>, если бы Rust также копировал бы данные в куче</span>

Ранее мы сказали, что когда переменная выходит из области видимости, Rust автоматически вызывает функцию `drop` и очищает память кучи для данной переменной. Но картинка 4-2 показывает, что теперь оба указателя указывают на одно и тоже место. Это проблема: когда переменная `s2` и переменная `s1` выходят из области видимости они обе будут пытаться освободить одну и туже память в куче. Это известно как "ошибка двойного освобождения" *double free* и является одной из ошибок безопасности памяти, упоминаемых ранее. Освобождение памяти дважды может привести к повреждению памяти, что потенциально может привести к уязвимостям безопасности.

Чтобы убедиться в безопасности использования памяти, расскажем детали того, что происходит в данной ситуации в Rust. Вместо попытки копировать выделенную память, Rust считает что переменная `s1` больше не действительна и таким образом в Rust ничего не нужно освобождать позже, когда `s1` покинет область видимости. Проверьте что происходит при попытке использования переменной `s1` после того как `s2` создана, это не работает:

```rust,ignore,does_not_compile
let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);
```

Вы получите ошибку ниже, потому что Rust не даст использовать не действительную ссылку s1:

```text
error[E0382]: use of moved value: `s1`
 --> src/main.rs:5:28
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |
5 |     println!("{}, world!", s1);
  |                            ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`, which does
  not implement the `Copy` trait
```

Если вы слышали термины "поверхностное копирование" *shallow copy* и "глубокое копирование" *deep copy* в других языках, то концепция копирования указателя, длины и ёмкости без копирования самих данных в куче, возможно выглядит как создание "поверхностной копии". Но так как Rust делает первую переменную недействительной вместо создания поверхностной копии, то такое действие известно как "перемещение" *move*. В данном примере, мы бы сказали, что `s1` была *перемещена* в переменную `s2`. То что происходит на самом деле показано на картинке 4-4.


<img alt="s1 and s2 pointing to the same value" src="https://github.com/ruRust/book/blob/master/rustbook-en/src/img/trpl04-04.svg?raw=true" class="center" style="width: 50%;">

<span class="caption">Картинка 4-4: представление памяти после того как <code>s1</code> была сделана не действительной</span>

Это решает нашу проблему! Действительной остаётся только переменная `s2`, когда она выходит из области видимости, то она одна будет освобождать память в куче.

Дополнительно, присутствует выбор дизайна, который подразумевает следующее: Rust никогда не будет автоматически создавать “глубокие” копии ваших данных. Следовательно, любое такое *автоматическое* копирование, можно считать не дорогим с точки зрения производительности во время выполнения.

#### Способы взаимодействия переменных и данных: клонирование

Если мы *хотим* сделать глубокое копирование данных в куче для типа `String`, а не только данных в стеке, то мы можем использовать общий метод называемый `clone`. Мы обсудим его синтаксис в главе 5, но так как методы являются общими особенностями во многих языках программирования, то вы возможно уже видели их ранее.

Вот пример метода `clone` в действии:

```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```

Код работает отлично и явно выполняет поведение, показанное на картинке 4-3, где данные в куче *действительно* скопированы.

Когда вы видите вызов `clone`, то вы знаете о выполнении некоторого кода, который может быть дорогим. Это является визуальным индикатором о том, что тут происходит что-то другое.

#### Стековые данные: Копирование

Это ещё одна особенность о которой мы ещё не говорили. Этот код использует целые числа, часть которого была показа ранее в листинге 4-2. Этот код работает и не имеет ошибок:

```rust
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
```

Но данный код, кажется противоречит тому, что мы только что изучили: тут не нужно вызывать `clone`, но `x` является все ещё действительной и не перемещена в `y`.

Причина этого в том, что типы вроде целых, размер которых известен во время компиляции, сохраняется полностью в стеке, поэтому такое копирование значений является быстрым. Это означает, что нет причин по которым мы бы хотели помешать `x` оставаться действительной после создания переменной `y`. Другими словами, здесь нет разницы между глубоким и поверхностным копированием, поэтому вызов `clone` не будет делать ничего отличного от обычного поверхностного копирования, и мы можем оставить это как есть.

В Rust есть специальная аннотация называемая типаж `Copy`, который можно разместить на типы вроде целых, размещённых в стеке (мы поговорим про типажи в главе 10). Если тип имеет типаж `Copy`, то предыдущая переменная является используемой после назначения. Rust не позволит аннотировать тип с типажом `Copy`, если тип или любая его часть имеет реализацию типажа `Drop`. Если типу нужно делать что-то особенное, когда значение уходит из области видимости и мы добавляем аннотацию `Copy` к данному типу, мы получим ошибку компиляции. Для изучения как добавлять аннотацию `Copy` к вашему типу, смотрите раздел ["Выводимые типажи"]<!--  --> в приложении C.

Так какие типы имеют типаж `Copy`? Можно проверить документацию любого типа для уверенности, но как общее правило любая группа простых, скалярных значений может быть с типажом `Copy`, и ничего из типов, которые требуют выделения памяти или являются некоторой формой ресурсов, не имеет типажа  `Copy`. Вот некоторые типы, которые являются с `Copy`:

- Все целочисленные типы, такие как `u32`.
- Логический тип данных `bool`, значения которых `true` и `false`.
- Все числа с плавающей запятой такие как `f64`.
- Символьный тип, `char`.
- Кортежи, но только если они содержат типы, которые также `Copy`. Например, `(i32, i32)` является`Copy`, но `(i32, String)` не является.

### Владение и функции

Семантика передачи значений в функции является похожей на назначение значения переменной. Передача переменной в функцию входным параметром будет перемещать или копировать значение, точно также как это делает операция присвоения. Пример в листинге 4-3 с некоторыми аннотациями, показывает где переменные появляться и исчезают из области видимости.

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
     let s = String::from("hello");  // s появляется в обл.видимости

     takes_ownership(s);             // знач-е s's перемещается в фун-ю
                                     // и больше не действительно здесь

      let x = 5;                      // x появляется в обл.видимости
      makes_copy(x);                  // x будет перемещено в функцию,
                                     // но i32 является Copy, поэтому это
                                     // нормально использовать x позже
} // Здесь x уходит из обл.видимости, затем s тоже. Но т.к. значение s было перемещено,
   // ничего особенного не происходит.

fn takes_ownership(some_string: String) { // параметр some_string появляется в обл.видиости
     println!("{}", some_string); } // здесь, some_string уходит из обл.видимости и вызывается `drop`.
   // память освобождена

fn makes_copy(some_integer: i32) { // параметр some_integer появляется в обл.видимости
     println!("{}", some_integer);
} // Здесь, some_integer уходит из обл.видимости. Ничего особенного не происходит.
```

<span class="caption">Листинг 4-3: функции с комментариями про владение и область видимости</span>

Если попытаться использовать `s` после вызова `takes_ownership`, Rust выдаст ошибку времени компиляции. Такие статические проверки защищают от ошибок. Попробуйте добавить код в `main`, который использует переменную `s` и `x`, чтобы увидеть где их можно использовать и где правила владения предотвращают использование.

### Возвращение значений и область видимости

Возвращение значений также может перемещать владение. Листинг 4-4 является примером с похожими комментариями, что даны в листинге 4-3.

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {

      let s1 = gives_ownership();    // gives_ownership перемещает ее                                     // возвращаемое значение в s1

      let s2 = String::from("hello");  // s2 появляется в обл.видим-ти
        let s3 = takes_and_gives_back(s2); // s2 перемещено в функ-ю
                                          // takes_and_gives_back, которая
                                          // также перемещает возвращаемое
                                          // значение в переменную
s3
} // Здесь s3 уходит из обл.видимости и освобождена. s2 тоже уходит из обл.видимости но была перемещена
    // поэтому ничего не происходит. s1 уходит из обл.вид-сти и освобождена.

fn gives_ownership() -> String {      // gives_ownership переместит
                                        // возвращаемое значение в функцию
                                         // которая ее вызывает
       let some_string = String::from("hello"); // some_string появля-ся в обл.видим-сти

      some_string                          // some_string возвращена и
                                          // перемещается в вызывавшую
                                          // функцию
}  // takes_and_gives_back принимает String и возвращает строку

fn takes_and_gives_back(a_string: String) -> String { // a_string появл-ся
                                                    // в обл.видим-сти
       a_string  // a_string возвращена и перемещена наружу в вызывающую функцию
}
```

<span class="caption">Листинг 4-4: перемещение владения и возврат значений</span>

Владение переменной каждый раз следует похожему шаблону: присваивание значения другой переменной перемещает его. Когда переменная содержащая данные в куче выходит из области видимости, содержимое в куче будет очищено функцией `drop` , если только данные не были перемещены во владение другой переменной.

Приём во владение и затем возвращение владения из каждой функцией немного утомительно. А что если мы позволим функции использовать значение, но не забирать его во владение? Весьма раздражает, если все, что мы передаём, также должно быть возвращено обратно, если хочется использовать значение опять. И это в дополнение к любым данным, полученным из тела функции, которые мы также можем захотеть вернуть.

Есть возможность возвращать несколько значений используя кортеж, как в листинге 4-5.

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
     let s1 = String::from("hello");

      let (s2, len) = calculate_length(s1);

      println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
     let length = s.len(); // len() returns the length of a String

      (s, length)
}
```

<span class="caption">Листинг 4-5: возврат владения параметров</span>

Но это слишком много церемоний и много работы для концепции, которая должна быть общей. К счастью для нас, в Rust есть функциональность для данной концепции, называемая *ссылка*.


["Типы данных"]: ch03-02-data-types.html#data-types
["Выводимые типажи"]: appendix-03-derivable-traits.html
["Синтаксис методов"]: ch05-03-method-syntax.html#method-syntax
["Путь для обращения к элементу в дереве модулей"]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html