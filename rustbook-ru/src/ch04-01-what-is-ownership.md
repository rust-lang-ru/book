## Что такое владение?

*Владение* — это набор правил, определяющих, как приложение на языке Ржавчина управляет памятью. Все приложения так или иначе должны управлять тем, как они используют память компьютера во время работы. Некоторые языки имеют сборщик мусора, который самостоятельно управляет неиспользуемой памятью во время работы приложения; в других языках разработчик ПО должен явно выделять и освобождать память. В Ржавчине используется третий подход: память управляется через устройство владения с набором правил, которые проверяются сборщиком. При нарушении любого из правил - приложение не будет собрано. Ни одна из особенностей устройства владения не замедлит работу вашего приложения.

Поскольку владение является новым решением для многих разработчиков ПО, требуется некоторое время, чтобы привыкнуть к нему. Хорошая новость заключается в том, что чем больше у вас будет опыта с Ржавчиной и с правилами устройства владения, тем легче вам будет естественным образом разрабатывать безопасную и производительную рукопись. Держитесь! Не сдавайтесь!

Понимание использования устройства владения является обязательным для понимания всех остальных особенностей языка, которые отличают Ржавчину от всех ранее известных языков. В этой главе вы изучите владение на примерах, которые сосредоточены на наиболее часто используемом виде данных: строки.

> ### Обойма и куча
>
> Многие языки программирования не требуют, чтобы вы слишком часто думали о обойме и куче. Но в языках системного программирования, одним из которых является Ржавчина, то, какое значение находится в обойме или в куче, влияет на поведение языка и на принятие вами определённых решений. Владение будет описано через призму обоймы и кучи позже в этой главе, а пока — краткое пояснение.
>
> И обойма, и куча — это участи оперативной памяти, доступные вашей рукописи для использования во время выполнения. Однако они внутренне устроены по-разному. Обойма хранит значения в порядке их получения, а удаляет — в обратном. Это называется *«последним пришёл — первым ушёл»*. Подумайте о стопке тарелок: когда вы добавляете тарелки, вы кладёте их сверху стопки — когда вам нужна тарелка, вы берёте одну так же сверху. Добавление или удаление тарелок посередине или снизу не сработает! Добавление данных называется *помещением в обойму*, а удаление — извлечением *из обоймы*. Все данные, хранящиеся в обойме, должны иметь известный определенный размер. Данные, размер которых во время сборки неизвестен или может измениться, должны храниться в куче.
>
> Куча устроена менее согласованно: когда вы кладёте данные в кучу, вы запрашиваете определённый размер пространства. Операционная система находит в куче свободный участок памяти достаточного размера, помечает его как используемый и возвращает *указатель*, являющийся адресом этого участка памяти. Этот этап называется *выделением памяти в куче* и иногда сокращается до *выделения памяти* (помещение значений в обойму не считается выделением). Поскольку указатель на участок памяти в куче имеет определённый размер, его можно расположить в обойме, однако когда вам понадобятся действительные данные, вам придётся проследовать по указателю. Представьте, что вы сидите в ресторане. Когда вы входите, вы называете количество человек в вашем объединении, и человек находит свободный стол, которого хватит на всех, и ведёт вас туда. Если кто-то из вашем объединении опоздает, он может спросить, куда вас посадили, чтобы найти вас.
>
> Помещение в обойму происходит более быстро, чем выделение памяти в куче, потому что операционная система не должна искать место для размещения сведений — это место всегда на верхушке обоймы. Для сравнения, выделение памяти в куче требует больше работы, потому что операционная система сначала должна найти участок памяти достаточного размера, а затем произвести некоторые действия для подготовки к следующему выделению памяти.
>
> Доступ к данным в куче медленнее, чем доступ к данным в обойме, потому что вам нужно следовать по адресу указателя, чтобы добраться туда. Современные ЦПУ работают быстрее, если они меньше прыгают по памяти. Продолжая подобие, рассмотрим официанта в ресторане, принимающего заказы со многих столов. Наиболее правильно будет получить все заказы за одним столом, прежде чем переходить к следующему столу. Получение заказа со стола А, затем со стола В, затем снова одного с А, а затем снова одного с В было бы гораздо более медленным делом. Точно так же ЦПУ может выполнять свою работу лучше, если он работает с данными, которые находятся близко к другим данным (как в обойме), а не далеко (как это может быть в куче).
>
> Когда ваша рукопись вызывает способ (функцию), то все значения, переданные в неё (возможно включающие указатели на данные в куче), и свои переменные помещаются в обойму. Когда способ (функция) завершается, эти значения извлекаются из обоймы.
>
> Отслеживание того, какие части рукописи используют какие данные, уменьшение количества повторяющихся данных и очистка неиспользуемых данных в куче, чтобы не исчерпать пространство, — все эти сбои решает владение. Как только вы поймёте, что такое владение, вам не нужно будет слишком часто думать о обойме и куче. Однако знание того, что основная цель владения — управление данными кучи, может помочь объяснить, почему оно работает именно так.

### Правила владения

Во-первых, давайте взглянем на правила владения. Помните об этих правилах, пока мы работаем с примерами, которые их отображают:

- У каждой переменной в Ржавчине есть *владелец*,
- У переменной может быть только один владелец в одно мгновение времени,
- Когда владелец покидает область видимости, переменная удаляется.

### Область видимости переменной

Теперь, когда мы прошли основные правила написания Ржавчины, мы не будем включать всю рукопись `fn main() {` в примеры. Поэтому, если вы будете следовать этому пособию, убедитесь, что следующие примеры помещены в способ (функцию) `main` вручную. В итоге наши примеры будут более краткими, что позволит нам сосредоточиться на существующих подробностях, а не на образцовой рукописи.

В качестве первого примера владения мы рассмотрим *область видимости* некоторых переменных. Область видимости — это раздел внутри приложения, для которого допустима переменная. Возьмём следующую переменную:

```rust
let s = "здравствуй";
```

Переменная `s` относится к строковой записи, где значение строки жёстко определено  в писании нашей приложения. Переменная действительна с места её объявления до конца текущей *области видимости*. В приложении 4-1 показана приложение с примечаниями, указывающими, где начало и конец области видимости для переменной `s` .

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-01/src/main.rs:here}}
```

<span class="caption">Приложение 4-1: Переменная и область действия, где она существует</span>

Другими словами, здесь есть две важных особенности:

- Когда переменная `s` *появляется* в области видимости, она считается действительной,
-  действительной ровно до конца раздела, за которым следует *выход* за границы этой области.

На этом этапе объяснения взаимосвязь между областями видимости и допустимостью переменных подобна той, что существует в других языках программирования. Теперь мы будем опираться на это понимание, введя вид данных `String`.

### Вид данных `String`

Для отображения правил владения нам требуется более сложный вид данных чем те, что мы обсуждали в части ["Виды данных"] Главы 3. Виды данных, рассмотренные ранее, имеют определённый размер, а значит могут быть размещены в обойме и извлечены из неё, когда их область видимости закончится, и могут быть быстро и обыкновенно воспроизведены для создания нового, независимого двойника, если другой части рукописи нужно использовать то же самое значение в другой области видимости. Но мы хотим посмотреть на данные, хранящиеся в куче, и выяснить, как Ржавчина узнаёт, когда нужно очистить эти данные, поэтому вид данных <code>String</code> — отличный пример.

Мы сосредоточимся на тех частях `String`, которые связаны с владением. Эти особенности также применимы к другим сложным видам данных, независимо от того, предоставлены они встроенной библиотекой или созданы вами. Более подробно мы обсудим `String` в [главе 8]<!-- ignore -->.

Мы уже видели строковые записи, где строковое значение жёстко определено  в нашей программе. Строковые записи удобны, но они подходят не для каждого случая, где мы можем хотеть использовать писание. Одна из причин заключается в том, что они неизменны. Кроме того, не каждое строковое значение может быть известно во время написания рукописи: что, если мы захотим принять и сохранить пользовательский ввод? Для таких случаев в Ржавчине есть ещё один строковый вид данных — `String`. Этот вид данных управляет данными, выделенными в куче, и поэтому может хранить размер писания, который во время сборки неизвестен. Также вы можете создать `String` из строковой записи, используя способ (функцию) `from`, например:

```rust
let s = String::from("здравствуй");
```

Приказчик "Двойное двоеточие" `::` позволяет использовать пространство имён данного способа (функции) `from` с видом данных `String`, а не какое-то иное имя, такое как `string_from`. Мы обсудим эти правила написания более подробно в разделе [«Правила написания способов»]. раздел <!-- ignore --> Главы 5, и в ходе обсуждения пространств имён с разделами в [ «Пути для обращения к переменной в дереве разделов»]<!-- ignore --> в главе 7.

Строка такого вида *может* быть изменяема:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-01-can-mutate-string/src/main.rs:here}}
```

В чем же тут разница? Почему строку `String` можно изменить, а записи — нельзя? Разница заключается в том, как эти два вида данных работают с памятью.

### Память и способы её выделения

В случае строковой записи мы знаем её содержимое во время сборки, и оно жёстко прописано в итоговом исполняемом файле. Причина того, что строковые записи более быстрые и производительные, в их неизменяемости. К сожалению, нельзя поместить неопределённый кусок памяти в выполняемый файл для писания, размер которого неизвестен при сборке и может меняться во время выполнения приложения.

Чтобы поддерживать изменяемую, увеличивающуюся переменную вида данных `String`, необходимо выделять память в куче для всего содержимого, размер которого неизвестен во время сборки. Это означает, что:

- Память должна запрашиваться у операционной системы во время выполнения приложения,
- Необходим способ возврата этой памяти операционной системе, когда мы закончили в программе работу со `String`.

Первая часть используется нами: когда мы вызываем `String::from`, его выполнение запрашивает необходимую память. Это работает довольно похоже во всех языках программирования.

Однако вторая часть отличается. В языках со *сборщиком мусора (GC)*, память, которая больше не используется, отслеживается и очищается с его помощью — нам не нужно об этом думать. В большинстве языков без сборщика мусора мы обязаны сами определять, когда память больше не используется, и вызывать рукопись для явного её освобождения, точно так же, как мы делали это для её запроса. Правильное выполнение этого этапа во все времена было сложной неполадкой программирования. Если мы забудем освободить память, она будет потеряна. Если мы сделаем это слишком рано, у нас будет недопустимая переменная. Сделать это дважды — тоже будет ошибкой. Нам нужно соединить ровно один `allocate` ровно с одним `free`.

Ржавчина выбирает другой путь: память самостоятельно возвращается, как только владеющая памятью переменная выходит из области видимости. Вот исполнение примера с областью видимости из приложения 4-1, в котором используется вид данных `String` вместо строковой записи:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-02-string-scope/src/main.rs:here}}
```

Существует одна возможность, когда мы можем вернуть память, необходимую нашему `String`, обратно распределителю — когда `s` выходит за пределы области видимости. Когда переменная выходит за пределы области видимости, Ржавчина вызывает для нас особую способ (функцию). Этот способ (функция) называется [`drop`]<!-- ignore -->, и именно здесь составитель`String` может поместить рукопись для возврата памяти. Ржавчина самостоятельно вызывает `drop` после закрывающей узорчатой скобки.

> Примечание: в C++ этот способ освобождения памяти в конце времени жизни переменной иногда называется *«Получение ресурса есть объявление» (англ. Resource Acquisition Is Initialization (RAII))*. Способ (функция) `drop` в Ржавчине покажется вам знакомой, если вы использовали образцы RAII.

Этот способ оказывает глубокое влияние на способ написания рукописи в Ржавчине. Сейчас это может казаться простым, но в более сложных случаях поведение рукописи может быть неожиданным, например когда хочется иметь несколько переменных, использующих данные, выделенные в куче. Изучим несколько таких случаев.

<!-- Old heading. Do not remove or links may break. -->

<a id="ways-variables-and-data-interact-move"></a>

#### Взаимодействие переменных и данных с помощью перемещения

Несколько переменных могут по-разному взаимодействовать с одними и теми же данными в Ржавчине. Давайте рассмотрим пример использования целого числа в приложении 4-2.

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-02/src/main.rs:here}}
```

<span class="caption">Приложение 4-2. Присвоение целочисленного значения переменной <code>x</code> переменной <code>y</code></span>

Мы можем догадаться, что делает эта рукопись: «привязать значение `5` к `x`; затем сделать повтор значения в `x` и привязать его к `y`». Теперь у нас есть две переменные: `x` и `y`, и обе равны `5`. Это то, что происходит на самом деле, потому что целые числа — это простые значения с известным конечным размером, и эти два значения `5` помещаются в обойму.

Теперь рассмотрим исполнение с видом данных `String`:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-03-string-move/src/main.rs:here}}
```

Это выглядит очень похоже, поэтому мы можем предположить, что происходит то же самое: вторая строка сделает повтор значения в `s1` и привяжет его к `s2`. Но это не совсем так.

Взгляните на рисунок 4-1, чтобы увидеть, что происходит со `String` под капотом. `String` состоит из трёх частей, показанных слева: указатель на память, в которой хранится содержимое строки, длина и ёмкость. Это объединение данных хранится в обойме. Справа — память в куче, которая хранит содержимое.

<img alt="Two tables: the first table contains the representation of s1 on the&lt;br&gt;stack, consisting of its length (5), capacity (5), and a pointer to the first&lt;br&gt;значение in the second table. The second table contains the representation of the&lt;br&gt;string data on the heap, byte by byte." src="img/trpl04-01.svg" class="center" style="ширина: 150%;" />

<span class="caption">Рисунок 4-1: представление в памяти <code>String</code>, содержащей значение <code>"здравствуй"</code>, привязанное к <code>s1</code></span>

Длина — это размер памяти в байтах, которое в настоящее время использует содержимое `String`. Ёмкость — это общий размер памяти в байтах, которое `String` получил от распределителя. Разница между длиной и ёмкостью имеет значение, но не в этой среде, поэтому в данное мгновение можно пренебречь ёмкостью.

Когда мы присваиваем `s1` значению `s2`, данные `String` повторяются, то есть мы повторяем указатель, длину и ёмкость, которые находятся в обойме. Мы не повторяем данные в куче, на которые указывает указатель. Другими словами, представление данных в памяти выглядит так, как показано на рис. 4-2.

<img alt="Three tables: tables s1 and s2 representing those strings on the&lt;br&gt;stack, respectively, and both pointing to the same string data on the heap." src="img/trpl04-02.svg" class="center" style="ширина: 150%;" />

<span class="caption">Рисунок 4-2: представление в памяти переменной <code>s2</code>, имеющей повтор указателя, длины и ёмкости <code>s1</code></span>

Представление *не* похоже на рисунок 4-3, как выглядела бы память, если бы вместо этого Ржавчина также воспроизвела данные кучи. Если бы Ржавчина сделала это, действие `s2 = s1` могла бы быть очень дорогой с точки зрения производительности во время выполнения, если бы данные в куче были большими.

<img alt="Two tables: the first table contains the representation of s1 on the&lt;br&gt;stack, consisting of its length (5), capacity (5), and a pointer to the first&lt;br&gt;значение in the second table. The second table contains the representation of the&lt;br&gt;string data on the heap, byte by byte." src="img/trpl04-03.svg" class="center" style="ширина: 150%;" />

<span class="caption">Рисунок 4-3: другой исход того, что может сделать <code>s2 = s1</code>, если Ржавчина также воспроизведет данные кучи</span>

Ранее мы сказали, что когда переменная выходит за пределы области видимости, Ржавчина самостоятельно вызывает способ (функцию) `drop` и очищает память в куче для данной переменной. Но на рис. 4.2 оба указателя данных указывают на одно и то же место. Это неполадка: когда переменные `s2` и `s1` выходят из области видимости, они обе будут пытаться освободить одну и ту же память в куче. Это известно как *ошибка двойного освобождения (double free)* и является одной из ошибок безопасности памяти, упоминаемых ранее. Освобождение памяти дважды может привести к повреждению памяти, что возможно может привести к уязвимостям безопасности.

Чтобы обеспечить безопасное управление памятью, после строки `let s2 = s1;` , Ржавчина считает `s1` более недействительным. Следовательно, Ржавчине не нужно ничего освобождать, когда `s1` выходит за пределы области видимости. Посмотрите, что происходит, когда вы пытаетесь использовать `s1` после создания `s2` ; это не сработает:

<Listing number="4-1" caption="Значение в области не действительно">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-04-cant-use-after-move/src/main.rs:here}}
```

</Listing>

Вы получите похожую ошибку, потому что Ржавчина не позволяет вам использовать недействительную ссылку:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-04-cant-use-after-move/output.txt}}
```

Если вы слышали понятия *поверхностное повторение* и *глубокое повторение* при работе с другими языками, подход повторения указателя, длины и ёмкости без повторения данных, вероятно, звучит как создание поверхностных повторов. Но поскольку Ржавчина также отменяет первую переменную, вместо того, чтобы называть это поверхностным повторением, это называется *перемещением*. В этом примере мы бы сказали, что `s1` был *перемещён* в `s2`. Итак, что на самом деле происходит, показано на рисунке 4-4.

<img alt="Три таблицы: таблицы s1 и s2, представляющие эти строки в обойме соответственно, и обе указывающие на одни и те же строковые данные в куче. Таблица s1 выделена серым цветом, потому что s1 больше недействительна; только s2 можно использовать для доступа к данным кучи." src="img/trpl04-04.svg" class="center" style="ширина:150%;" />

<span class="caption">Рисунок 4-4: представление в памяти после того, как <code>s1</code> был признан недействительным</span>

Это решает нашу неполадку! Действительной остаётся только переменная `s2`. Когда она выходит из области видимости, то она одна будет освобождать память в куче.

Такой выбор внешнего вида языка даёт дополнительное преимущество: Ржавчина никогда не будет самостоятельно создавать «глубокие» повторы ваших данных. Следовательно любое такое *самостоятельное* повторение можно считать недорогим с точки зрения производительности во время выполнения.

<!-- Old heading. Do not remove or links may break. -->

<a id="ways-variables-and-data-interact-clone"></a>

#### Взаимодействие переменных и данных с помощью удваивания

Если мы *хотим* глубоко воспроизвести данные кучи `String`, а не только данные обоймы, мы можем использовать общий способ, называемый `clone`. Мы обсудим правила написания способов в главе 5, но поскольку способы являются общей чертой многих языков программирования, вы, вероятно, уже встречались с ними.

Вот пример работы способа `clone`:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-05-clone/src/main.rs:here}}
```

Это отлично работает и очевидно приводит к поведению, представленному на рисунке 4-3, где данные кучи *были* воспроизведены.

Когда вы видите вызов `clone`, вы знаете о выполнении некоторой рукописи, которая может быть дорогим. В то же время использование <code>clone</code> является внешним показателем того, что тут происходит что-то необычное.

#### Данные из обоймы: повторение

Способ о которой мы ранее не говорили. Эта рукопись, часть которой была показа ранее в приложении 4-2, использует целые числа. Она работает без ошибок:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-06-copy/src/main.rs:here}}
```

Но эта рукопись, кажется, противоречит тому, что мы только что узнали: у нас нет вызова `clone`, но `x` всё ещё действительна и не была перемещена в `y`.

Причина в том, что такие виды данных, как целые числа, размер которых известен во время сборки, полностью хранятся в обойме, поэтому повторы действительных значений создаются быстро. Это означает, что нет причин, по которым мы хотели бы предотвратить доступность `x` после того, как создадим переменную `y`. Другими словами, здесь нет разницы между глубоким и поверхностным повторением, поэтому вызов `clone` ничем не отличается от обычного поверхностного повторения, и мы можем его опустить.

В Ржавчине есть особое изложение, называемое сущностью `Copy`, которую мы можем размещать в видах данных, хранящихся в обойме, как и целые числа (подробнее о видах данных мы поговорим в [главе 10]<!-- ignore -->). Если вид данных использует сущность `Copy`, переменные, которые его используют, не перемещаются, а обыкновенно повторяются, что делает их действительными после присвоения другой переменной.

Ржавчина не позволит нам определять вид данных с помощью `Copy`, если вид данных или любая из его частей использует `Drop`. Если для вида данных нужно, чтобы произошло что-то особенное, когда значение выходит за пределы области видимости, и мы добавляем изложение `Copy` к этому виду данных, мы получим ошибку времени сборки. Чтобы узнать, как добавить изложение `Copy` к вашему виду для использования сущности, смотрите [раздел «Производные сущности»]<!-- ignore --> в приложении С.

Но какие же виды данных используют сущность `Copy`? Можно проверить пособие для любого вида данных для уверенности, но как правило любое объединение простых одиночных значений может быть использовать `Copy`, и никакие виды данных, которые требуют выделения памяти в куче или являются некоторым видом данных памяти, не используют сущности `Copy`. Вот некоторые виды данных, которые используют `Copy`:

- Все целочисленные виды данных, такие как `u32`,
- Разумный вид данных `bool`, возможные значения которого `true` и `false`,
- Все виды данных с плавающей запятой, такие как `f64`.
- Знаковый вид данных `char`,
- составные ряды, но только если они содержат виды данных, которые также используют `Copy`. Например, `(i32, i32)` будет с `Copy`, но составной ряд `(i32, String)` уже нет.

### Владение и способы (функции)

Устройство передачи значения способу (функции) подобно тому, что происходит при присвоении значения переменной. Передача переменной в способ (функцию) приведёт к перемещению или воспроизведению, как и присваивание. В приложении 4-3 есть пример с некоторыми изложениями, показывающими, где переменные входят в область видимости и выходят из неё.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-03/src/main.rs}}
```

<span class="caption">Приложение 4-3. Способы (функции) с определенными владельцами и областью действия</span>

Если попытаться использовать `s` после вызова `takes_ownership`, Ржавчина выдаст ошибку времени сборки. Такие постоянные проверки защищают от ошибок. Попробуйте добавить рукопись в `main`, которая использует переменную `s` и `x`, чтобы увидеть где их можно использовать и где правила владения предотвращают их использование.

### Возвращение значений и область видимости

Возвращаемые значения также могут передавать право владения. В приложении 4-4 показан пример способа (функции), возвращающей некоторое значение, с такими же изложениями, как в приложении 4-3.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-04/src/main.rs}}
```

<span class="caption">Приложение 4-4: Передача права владения на возвращаемые значения</span>

Владение переменной каждый раз следует одному и тому же образцу данных: присваивание значения другой переменной передаёт его. Когда переменная, содержащая данные в куче, выходит из области видимости, содержимое в куче будет очищено функцией `drop`, если только данные не были перемещены во владение другой переменной.

Хотя это работает, получение права владения, а затем возвращение владения каждой функцией немного утомительно. Что, если мы хотим, чтобы способ (функция) использовала значение, но не становилась владельцем? Очень раздражает, что всё, что мы передаём, также должно быть передано обратно, если мы хотим использовать это снова, в дополнение к любым данным, полученным из тела способа (функции), которые мы также можем захотеть вернуть.

Ржавчина позволяет нам возвращать несколько значений с помощью составного ряда, как показано в приложении 4-5.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-05/src/main.rs}}
```

<span class="caption">Приложение 4-5: Возврат права владения на свойства</span>

Но это слишком высокопарно и многословно для подходов, которые должны быть общими. К счастью для нас, в Ржавчине есть возможность использовать значение без передачи права владения, называемое *ссылками*.


["Виды данных"]: ch03-02-data-types.html#data-types
[главе 8]: ch08-02-strings.html
[главе 10]: ch10-02-traits.html
[раздел «Производные сущности»]: appendix-03-derivable-traits.html
[«Правила написания способов»]: ch05-03-method-syntax.html#method-syntax
[ «Пути для обращения к переменной в дереве разделов»]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html
[`drop`]: ../std/ops/trait.Drop.html#tymethod.drop