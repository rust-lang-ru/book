<!-- Old heading. Do not remove or links may break. -->

<a id="the-match-control-flow-operator"></a>

## Управляющее средство `match`

В Ржавчине есть чрезвычайно мощный рычаг управления потоком, именуемый `match`, который позволяет сравнивать значение с различными образцами данных и затем выполнять рукопись в зависимости от того, какой из образцов совпал. Образцы могут состоять из записанных значений, имён переменных, подстановочных знаков и многого другого; в главе 18 рассматриваются все различные виды данных образцов и то, что они делают. Сила <code>match</code> заключается в выразительности образцов и в том, что сборщик проверяет, что все возможные исходы.

Думайте о выражении `match` как о машине для упорядочивания монет: монеты скользят по дорожке с различными по размеру отверстиями, и каждая монета падает через первое попавшееся отверстие, в которое она поместилась. Таким же образом значения проходят через каждый образец данных в `match`, и при первом же "подходящем" образце значение попадает в соответствующий раздел рукописи, который будет использоваться во время выполнения.

Говоря о монетах, давайте используем их в качестве примера, используя `match`! Для этого мы напишем функцию, которая будет получать на вход неизвестную монету Соединённых Штатов и, подобно счётной машине, определять, какая это монета, и возвращать её стоимость в центах, как показано в приложении 6-3.

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-03/src/main.rs:here}}
```

<span class="caption">Приложение 6-3: Перечисление и выражение <code>match</code>, использующее в качестве образцов его исходы</span>

Давайте разберём `match` в функции `value_in_cents`. Сначала пишется ключевое слово `match`, затем следует выражение, которое в данном случае является значением `coin`. Это выглядит очень похоже на условное выражение, используемое в `if`, но есть большая разница: с `if` выражение должно возвращать <em>разумное значение</em>, а здесь это может быть любой вид данных. Вид данных `coin` в этом примере — перечисление вида данных<code>Coin</code>, объявленное в строке 1.

Далее идут ветки `match`. Ветки состоят из двух частей: образец данных и некоторая рукопись. Здесь первая ветка имеет образец данных, который является значением `Coin::Penny`, затем идёт приказчик `=>`, который разделяет образец данных и рукопись для выполнения. Рукопись в этом случае - это просто значение `1`. Каждая ветка отделяется от последующей при помощи запятой.

Когда используется выражение `match`, оно сравнивает полученное значение с образцом каждого ответвления по порядку. Если образец данных совпадает со значением, то выполняется рукопись, связанная с этим образцом. Если этот образец данных не соответствует значению, то выполнение продолжается со следующей ветки, так же, как в устройстве по упорядочиванию монет. У нас может быть столько ответвлений, сколько нужно: в приложении 6-3 наш `match` состоит из четырёх ответвлений.

Рукопись, связанная с каждым ответвлением, является выражением, а полученное значение выражения в соответствующем ответвлении — это значение, которое возвращается для всего выражения `match`.

Обычно узорчатые скобки не используются, если рукопись совпадающей ветви невелика, как в приложении 6-3, где каждая ветвь просто возвращает значение. Если вы хотите выполнить несколько строк рукописи в одной ветви, вы должны использовать узорчатые скобки, а запятая после этой ветви необязательна. Например, следующая рукопись выводит "Lucky penny!" каждый раз, когда способ вызывается с `Coin::Penny`, но при этом он возвращает последнее значение раздела - `1`:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-08-match-arm-multiple-lines/src/main.rs:here}}
```

### Образцы, привязывающие значения

Есть ещё одно полезное качество у веток в выражении <code>match</code>: они могут привязываться к частям тех значений, которые совпали с образцом. Благодаря этому можно извлекать значения из исходов перечисления.

В качестве примера, давайте изменим один из исходов перечисления так, чтобы он хранил в себе данные. С 1999 по 2008 год Соединённые Штаты чеканили 25 центов с различным внешнем видом на одной стороне для каждого из 50 штатов. Ни одна другая монета не получила внешнего вида штата, только четверть доллара имела эту дополнительную особенность. Мы можем добавить эти сведения в наш `enum` путём изменения исхода `Quarter` и включить в него значение `UsState`, как сделано в приложении 6-4.

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-04/src/main.rs:here}}
```

<span class="caption">Приложение 6-4: Перечисление <code>Coin</code>, в котором исход <code>Quarter</code> также сохраняет значение <code>UsState</code></span>

Представьте, что ваш друг пытается собрать четвертаки всех 50 штатов. Упорядочивая монеты по виду, мы также будем сообщать название штата, к которому относится каждый четвертак, чтобы, если у нашего друга нет такой монеты, он мог добавить её в своё собрание.

В выражении match для этой рукописи мы добавляем переменную с именем `state` в образец данных, который соответствует значениям исхода `Coin::Quarter`. Когда `Coin::Quarter` совпадёт с образцом, переменная `state` будет привязана к значению штата этого четвертака. Затем мы сможем использовать `state` в рукописи этой ветки, вот так:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-09-variable-in-pattern/src/main.rs:here}}
```

Если мы сделаем вызов функции `value_in_cents(Coin::Quarter(UsState::Alaska))`, то `coin` будет иметь значение `Coin::Quarter(UsState::Alaska)`. Когда мы будем сравнивать это значение с каждой из веток, ни одна из них не будет совпадать, пока мы не достигнем исхода `Coin::Quarter(state)`. В это мгновение `state` привяжется к значению `UsState::Alaska`. Затем мы сможем использовать эту привязку в выражении `println!`, получив таким образом внутреннее значение исхода `Quarter` перечисления `Coin`.

### Сопоставление образца данных для `Option<T>`

В предыдущем разделе мы хотели получить внутреннее значение `T` для случая `Some` при использовании `Option<T>`; мы можем обработать вид данных `Option<T>` используя `match`, как уже делали с перечислением `Coin`! Вместо сравнения монет мы будем сравнивать исходы `Option<T>`, независимо от этого изменения рычаг работы выражения `match` останется прежним.

Допустим, мы хотим написать функцию, которая принимает `Option<i32>` и если есть значение внутри, то добавляет 1 к существующему значению. Если значения нет, то функция должна возвращать значение `None` и не пытаться выполнить какие-либо действия.

Такую функцию довольно легко написать благодаря выражению `match`, рукопись будет выглядеть как в приложении 6-5.

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-05/src/main.rs:here}}
```

<span class="caption">Приложение 6-5: Функция, использующая выражение <code>match</code> для <code>Option&lt;i32&gt;</code></span>

Давайте более подробно рассмотрим первое использование `plus_one`. Когда мы вызываем `plus_one(five)`, переменная `x` в теле `plus_one` будет иметь значение `Some(5)`. Затем мы сравниваем это значение с каждой ветвью сопоставления:

```rust,ignore
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-05/src/main.rs:first_arm}}
```

Значение `Some(5)` не соответствует образцу данных `None`, поэтому мы продолжаем со следующим ответвлением:

```rust,ignore
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-05/src/main.rs:second_arm}}
```

Совпадает ли `Some(5)` с образцом `Some(i)`? Да, это так! У нас такой же исход. Тогда переменная `i` привязывается к значению, содержащемуся внутри `Some`, поэтому переменная `i` получает значение `5`. Затем выполняется рукопись сопряженная для данного ответвления, поэтому мы добавляем 1 к значению  переменной`i` и создаём новое значение `Some` со значением `6` внутри.

Теперь давайте рассмотрим второй вызов `plus_one` в приложении 6-5, где `x` является `None`. Мы входим в выражение `match` и сравниваем значение с первым ответвлением:

```rust,ignore
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-05/src/main.rs:first_arm}}
```

Оно совпадает! Для данной ветки образец  данных (<em>None</em>) не подразумевает наличие какого-то значения к которому можно было бы что-то добавить, поэтому программа останавливается и возвращает значение которое находится справа от `=>` - т.е. `None`. Так как образец данных первой ветки совпал, то никакие другие образцы веток не сравниваются.

Соединение `match` и перечислений полезно во многих случаях. Вы часто будете видеть подобное сочетание в рукописи на Ржавчине: сделать сопоставление значений перечисления используя `match`, привязать переменную к данным внутри значения, выполнить рукопись на основе привязанных данных. Сначала это может показаться немного сложным, но как только вы привыкнете, то захотите чтобы такая возможность была бы во всех языках. Это неизменно любимый пользователями приём.

### Match охватывает все исходы значения

Есть ещё одна особенность `match`, которую мы должны обсудить: образцы должны покрывать все возможные исходы. Рассмотрим это исполнение нашей функции `plus_one`, которое содержит ошибку и не собирается:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-10-non-exhaustive-match/src/main.rs:here}}
```

Мы не обработали исход `None`, поэтому эта рукопись вызовет сбой в программе. К счастью, Ржавчина знает и умеет ловить такой случай. Если мы попытаемся собрать такую рукопись, мы получим ошибку сборки:

```console
{{#include ../listings/ch06-enums-and-pattern-matching/no-listing-10-non-exhaustive-match/output.txt}}
```

Ржавчина знает, что мы не описали все возможные исходы, и даже знает, какой именно из образцов мы упустили! Сопоставления в Ржавчине являются *исчерпывающими*: мы должны покрыть все возможные исходы, чтобы рукопись была правильной. Особенно в случае `Option<T>`, когда Ржавчина не даёт нам забыть обработать явным образом значение `None`, тем самым он защищает нас от предположения, что у нас есть значение, в то время как у нас может быть и пустота, что делает невозможным совершить ошибку на миллиард долларов, о которой говорилось ранее.

### Гибкие образцы и исполнитель `_`

Используя перечисления, мы также можем выполнять особые действия для нескольких определённых значений, а для всех остальных значений выполнять одно действие по умолчанию. Представьте, что мы выполняем игру, в которой при выпадении 3 игрок не двигается, а получает новую шляпу нового образца . Если выпадает 7, игрок теряет шляпу. При всех остальных значениях ваш игрок перемещается на столько-то мест на игровом поле. Вот средство `match`, выполняющее этот ход мыслей, в котором итог броска костей жёстко задан, а не является случайным значением, а вся остальной ход мыслей представлена функциями без тел, поскольку их выполнение не входит в рамки данного примера:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-15-binding-catchall/src/main.rs:here}}
```

Для первых двух веток образцами данных являются записанные значения 3 и 7. Для последней ветки, которая охватывает все остальные возможные значения, образцом является переменная, которую мы решили назвать `other`. Рукопись, выполняемая для ветки `other`, использует эту переменную, передавая её в функцию `move_player`.

Эта рукопись собирается, даже если мы не перечислили все возможные значения вида данных `u8`, потому что последний образец данных будет соответствовать всем значениям, не указанным в определенном списке. Этот гибкий образец данных удовлетворяет требованию, что соответствие должно быть исчерпывающим. Обратите внимание, что мы должны поместить ветку с гибким образцом последней, потому что образцы оцениваются по порядку. Ржавчина предупредит нас, если мы добавим ветки после гибкого образца, потому что эти последующие ветки никогда не будут выполняться!

В Ржавчине также есть образец данных, который можно использовать, когда мы не хотим использовать значение в гибком образце: `_`, который является особым образцом, который соответствует любому значению и не привязывается к этому значению. Это говорит Ржавчине, что мы не собираемся использовать это значение, поэтому Ржавчина не будет предупреждать нас о неиспользуемой переменной.

Давайте изменим правила игры так: если выпадает что-то, кроме 3 или 7, нужно бросить ещё раз. Нам не нужно использовать значение в этом случае, поэтому мы можем изменить нашу рукопись, чтобы использовать `_` вместо переменной с именем `other`:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-16-underscore-catchall/src/main.rs:here}}
```

Этот пример также удовлетворяет требованию исчерпывающей полноты, поскольку мы явно пренебрегаем все остальные значения в последней ветке; мы ничего не забыли.

Если мы изменим правила игры ещё раз, чтобы в ваш ход не происходило ничего другого, если вы бросаете не 3 или 7, мы можем выразить это, используя единичное значение (пустой вид данных упорядоченного ряда, о котором мы упоминали в разделе ["Упорядоченные ряды"]<!-- ignore -->) в качестве рукописи, которая идёт вместе с веткой `_`:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-17-underscore-unit/src/main.rs:here}}
```

Здесь мы явно говорим Ржавчине, что не собираемся использовать никакое другое значение, которое не соответствует образцам в предыдущих ветках, и не хотим запускать никакую рукопись в этом случае.

Подробнее о образцах и совпадениях мы поговорим в [Главе 18]<!-- ignore -->. Пока же мы перейдём к правилам написания `if let`, который может быть полезен в случаях, когда выражение `match` слишком многословно.


["Упорядоченные ряды"]: ch03-02-data-types.html#the-tuple-type
[Главе 18]: ch18-00-patterns.html