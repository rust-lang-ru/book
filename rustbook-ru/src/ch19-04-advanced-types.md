## Продвинутые виды

Перечень видов данных Ржавчине имеет некоторые сущности, о которых мы уже упоминали, но ещё не обсуждали. Мы начнём с общего обзора newtypes, а затем разберёмся, чем они могут пригодиться в качестве видов данных. Далее мы перейдём к псевдонимам видов данных - возможности, похожей на newtypes, но с несколько иной смыслом. Мы также обсудим вид данных `!` и виды с изменяемым размером.

### Использование образца Newtype для обеспечения безопасности видов данных и создания абстракций

> Примечание: В этом разделе предполагается, что вы прочитали предыдущий раздел ["Использование образца Newtype для использования внешних сущностей для внешних видов данных."]<!-- ignore -->

Образец данных newtype полезен и для других задач, помимо тех, которые мы обсуждали до сих пор, в частности, для постоянного обеспечения того, чтобы значения никогда не путались, а также для указания единиц измерения значения. Пример использования newtypes для указания единиц измерения вы видели в приложении 19-15: вспомните, как стопки `Millimeters` и `Meters` обернули значения `u32` в newtype. Если бы мы написали функцию со свойством вида данных `Millimeters`, мы не смогли бы собрать программу, которая случайно попыталась бы вызвать эту функцию со значением вида данных `Meters` или обычным `u32`.

Мы также можем использовать образец данных newtype для абстрагирования от некоторых подробностей использования вида данных: новый вид может предоставлять открытый API, который отличается от API скрытого внутри вида данных.

Newtypes также позволяют скрыть внутреннее выполнение. Например, мы можем создать вид данных `People`, который обернёт `HashMap<i32, String>`, хранящий ID человека, связанный с его именем. Рукопись, использующая `People`, будет взаимодействовать только с открытым API, который мы предоставляем, например, способ добавления имени в собрание `People`; этой рукописи не нужно будет знать, что внутри мы присваиваем вид данных `i32` ID именам. Образец данных newtype - это лёгкий способ достижения инкапсуляции для скрытия подробностей использования, который мы обсуждали в разделе ["Инкапсуляция, скрывающая подробности использования"](ch17-01-what-is-oo.html#encapsulation-that-hides-implementation-details)<!-- ignore --> Главы 17.

### Создание родственных видов данных с помощью псевдонимов вида данных

Ржавчина предоставляет возможность объявить *псевдоним вида данных* чтобы дать существующему виду другое имя. Для этого мы используем ключевое слово `type`. Например, мы можем создать псевдоним вида данных `Kilometers` для `i32` следующим образом:

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-04-kilometers-alias/src/main.rs:here}}
```

Теперь псевдоним `Kilometers` является *родственным* для `i32`; в отличие от видов данных `Millimeters` и `Meters`, которые мы создали в приложении 19-15, `Kilometers` не является отдельным, новым видом. Значения, имеющие вид данных `Kilometers`, будут обрабатываться так же, как и значения вида данных `i32`:

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-04-kilometers-alias/src/main.rs:there}}
```

Поскольку `Kilometers` и `i32` являются одним и тем же видом данных, мы можем добавлять значения обоих видов данных и передавать значения `Kilometers` функциям, принимающим свойства `i32`. Однако, используя этот способ, мы не получаем тех преимуществ проверки видов данных, которые мы получаем от образца newtype, рассмотренного ранее. Другими словами, если мы где-то перепутаем значения `Kilometers` и `i32`, сборщик не выдаст нам ошибку.

Родственные в основном используются для сокращения повторений. Например, у нас может быть такой многословный вид:

```rust,ignore
Box<dyn Fn() + Send + 'static>
```

Написание таких длинных видов данных в описании самих функций и в виде наставлений видов данных по всему рукописи может быть утомительным и чреватым ошибками. Представьте себе дело, наполненный таким рукописью, как в приложении 19-24.

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-24/src/main.rs:here}}
```

<span class="caption">Приложение 19-24: Использование длинного вида данных во многих местах</span>

Псевдоним вида данных делает эту рукопись более удобной для работы, сокращая количество повторений. В приложении 19-25 мы ввели псевдоним `Thunk` для вида данных verbose и можем заменить все использования этого вида данных более коротким псевдонимом `Thunk`.

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-25/src/main.rs:here}}
```

<span class="caption">Приложение 19-25: Представление псевдонима <code>Thunk</code> для уменьшения количества повторений</span>

Такую рукопись гораздо легче читать и писать! Выбор осмысленного имени для псевдонима вида данных также может помочь прояснить ваши намерения (*thunk* - название для рукописи, которая будет вычисляться позднее, поэтому это подходящее имя для сохраняемого замыкания).

Псевдонимы видов данных также часто используются с видом данных `Result<T, E>` для сокращения повторений. Рассмотрим раздел `std::io` во встроенной библиотеке. Действия ввода-вывода часто возвращают `Result<T, E>` для обработки случаев, когда эти действия не удаются. В данной библиотеке есть способ `std::io::Error`, который отражает все возможные ошибки ввода/вывода. Многие функции в `std::io` будут возвращать `Result<T, E>`, где `E` - это `std::io::Error`, например, эти функции в сущности `Write`:

```rust,noplayground
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-05-write-trait/src/lib.rs}}
```

`Result<..., Error>` часто повторяется. Поэтому `std::io` содержит такое объявление псевдонима вида данных:

```rust,noplayground
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-06-result-alias/src/lib.rs:here}}
```

Поскольку это объявление находится в разделе `std::io`, мы можем использовать полный псевдоним `std::io::Result<T>`; это и есть `Result<T, E>`, где в качестве `E` выступает `std::io::Error`. Ярлыки функций сущности `Write` в итоге выглядят следующим образом:

```rust,noplayground
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-06-result-alias/src/lib.rs:there}}
```

Псевдоним вида данных помогает двумя способами: он облегчает написание рукописи *и* даёт нам согласованный внешняя оболочка для всего из `std::io`. Поскольку это псевдоним, то это просто ещё один вид данных `Result<T, E>`, что означает, что с ним мы можем использовать любые способы, которые работают с `Result<T, E>`, а также особые правила написания вроде `?` приказчика.

### Вид данных Never, который никогда не возвращается

В Ржавчине есть особый вид данных `!`, который на жаргоне теории видов данных известен как *empty type* (пустой вид данных), потому что он не содержит никаких значений. Мы предпочитаем называть его *never type* (никакой вид данных), потому что он используется в качестве возвращаемого вида, когда функция ничего не возвращает. Вот пример:

```rust,noplayground
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-07-never-type/src/lib.rs:here}}
```

Эта рукопись читается как "функция `bar` ничего не возвращает". Функции, которые ничего не возвращают, называются *рассеивающими функциями* (diverging functions). Мы не можем производить значения вида данных `!`, поэтому `bar` никогда ничего не вернёт.

Но для чего нужен вид данных, для которого вы никогда не сможете создать значения? Напомним рукопись из приложения 2-5, отрывка "игры в загадки"; мы воспроизвели его часть здесь в приложении 19-26.

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-05/src/main.rs:ch19}}
```

<span class="caption">Приложение 19-26: Сопоставление <code>match</code> с веткой, которая заканчивается <code>continue</code></span>

В то время мы опустили некоторые подробности в этой рукописи. В главе 6 раздела ["Приказчик управления потоком `match`"](ch06-02-match.html#the-match-control-flow-operator)<!--  --> мы обсуждали, что все ветви `match` должны возвращать одинаковый вид данных. Например, следующая рукопись не работает:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-08-match-arms-different-types/src/main.rs:here}}
```

Вид данных `guess` в этой рукописи должен быть целым *и* строкой, а Ржавчина требует, чтобы `guess` имел только один вид данных. Так что же возвращает `continue`? Как нам позволили вернуть `u32` из одной ветви и при этом иметь другую ветвь, которая оканчивается `continue` в приложении 19-26?

Как вы уже возможно догадались, `continue` имеет  значение `!`. То есть, когда Ржавчина вычисляет вид данных `guess`, он смотрит на обе сопоставляемые ветки, первая со значением `u32` и последняя со значением `!`. Так как `!` никогда не может иметь значение, то Ржавчина решает что видом данных `guess` является вид данных `u32`.

Условный подход к описанию такого поведения заключается в том, что выражения вида данных `!` могут быть преобразованы в любой другой вид данных. Нам позволяется завершить этот `match` с помощью `continue`, потому что `continue` не возвращает никакого значения; вместо этого он передаёт управление обратно в начало круговорота, поэтому в случае `Err` мы никогда не присваиваем значение `guess`.

Вид never полезен также для макроса `panic!`. Вспомните функцию `unwrap`, которую мы вызываем для значений `Option<T>`, чтобы создать значение или вызвать сбой с этим определением:

```rust,ignore
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-09-unwrap-definition/src/lib.rs:here}}
```

В этой рукописи происходит то же самое, что и в `match` в приложении 19-26: Ржавчина видит, что `val` имеет вид данных `T`, а `panic!` имеет вид данных `!`, поэтому итогом общего выражения `match` является `T`. Эта рукопись работает, потому что `panic!` не производит никакого значения; он завершает программу. В случае `None` мы не будем возвращать значение из `unwrap`, поэтому эта рукопись работает.

Последнее выражение, которое имеет вид данных `!` это `loop`:

```rust,ignore
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-10-loop-returns-never/src/main.rs:here}}
```

В данном случае круговорот никогда не завершится, поэтому `!` является значением выражения. Но это не будет так, если мы добавим `break`, так как круговорот завершит свою работу, когда дойдёт до `break`.

### Виды данных с изменяемым размером и сущность `Sized`

Ржавчине необходимо знать некоторые подробности о видах данных, например, сколько места нужно выделить для значения определённого вида данных. Из-за этого одна из сущностей системы видов данных поначалу вызывает некоторое недоумение: подход *видов данных с изменяемым размером*. Иногда называемые *DST* или *безразмерные виды данных*, эти виды данных позволяют нам писать рукопись, используя значения, размер которых мы можем узнать только во время выполнения.

Давайте углубимся в подробности изменяемого вида данных `str`, который мы использовали на протяжении всей книги. Все верно, не вида  данных `&str`, а вида  данных `str` самого по себе, который является DST. Мы не можем знать, какой длины строка до мгновения времени выполнения, то есть мы не можем создать переменную вида данных `str` и не можем принять переменную вида данных `str`. Рассмотрим следующую рукопись, которая не работает:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-11-cant-create-str/src/main.rs:here}}
```

Ржавчина должна знать, сколько памяти выделить для любого значения определенного вида данных и все значения вида данных должны использовать одинаковый размер памяти. Если Ржавчина позволила бы нам написать такую рукопись, то эти два значения `str` должны были бы занимать одинаковое количество памяти. Но они имеют разную длину: `s1` нужно 12 байтов памяти, а для `s2` нужно 15. Вот почему невозможно создать переменную имеющую вид данных изменяемого размера.

Так что же нам делать? В этом случае вы уже знаете ответ: мы преобразуем виды данных `s1` и `s2` в `&str`, а не в `str`. Вспомните из раздела ["Строковые срезы"] Главы 4, что устройство данных среза просто хранит начальное положение и длину среза. Так, в отличие от `&T`, который содержит только одно значение - адрес памяти, где находится `T`, в `&str` хранятся *два* значения - адрес `str` и его длина. Таким образом, мы можем узнать размер значения `&str` во время сборки: он вдвое больше длины `usize`. То есть, мы всегда знаем размер `&str`, независимо от длины строки, на которую оно ссылается. В целом, именно так в Ржавчине используются виды данных изменяемого размера: они содержат дополнительный бит метаданных, который хранит размер изменяемой сведений. Золотое правило изменяемых размерных видов данных заключается в том, что мы всегда должны помещать значения таких видов данных за каким-либо указателем.

Мы можем соединить `str` со всеми видами указателей: например, `Box<str>` или `Rc<str>`. На самом деле, вы уже видели это раньше, но с другим изменяемым размерным видом данных: сущностями. Каждый сущность - это изменяемый размерный вид данных, на который мы можем ссылаться, используя имя сущности. В главе 17 в разделе ["Использование сущность-предметов, допускающих значения разных видов данных"](ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types) мы упоминали, что для использования сущностей в качестве сущность-предметов мы должны поместить их за указателем, например `&dyn Trait` или `Box<dyn Trait>` (`Rc<dyn Trait>` тоже подойдёт).

Для работы с DST Ржавчина использует сущность `Sized` чтобы решить, будет ли размер вида данных известен на этапе сборки. Эту сущность самостоятельно используется для всего, чей размер известен к времени сборки. Кроме того, Ржавчина неявно добавляет ограничение на `Sized` к каждой гибкой функции. То есть, определение гибкой функции, такое как:

```rust,ignore
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-12-generic-fn-definition/src/lib.rs}}
```

на самом деле рассматривается как если бы мы написали её в виде:

```rust,ignore
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-13-generic-implicit-sized-bound/src/lib.rs}}
```

По умолчанию обобщённые функции будут работать только с видами данных чей размер известен во время сборки. Тем не менее, можно использовать следующие особые правила написания, чтобы ослабить это ограничение:

```rust,ignore
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-14-generic-maybe-sized/src/lib.rs}}
```

Ограничение сущности `?Sized` означает «`T` может или не может быть `Sized`», эта наставление отменяет обычное правило, согласно которому гибкие виды данных должны иметь известный размер во время сборки. Использовать правила написания `?Trait` в таком качестве можно только для `Sized`, и ни для каких других особенностей.

Также обратите внимание, что мы поменяли вид данных свойства `t` с `T` на `&T`. Поскольку вид данных мог бы не быть `Sized`, мы должны использовать его за каким-либо указателем. В данном случае мы выбрали ссылку.

Далее мы поговорим о функциях и замыканиях!


["Строковые срезы"]: ch04-03-slices.html#string-slices
["Использование образца Newtype для использования внешних сущностей для внешних видов данных"]: ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types