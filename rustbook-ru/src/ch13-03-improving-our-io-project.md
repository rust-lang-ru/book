## Улучшение нашего дела с вводом/выводом

Вооружившись полученными знаниями об повторителях, мы можем улучшить выполнение работы с вводом/выводом в деле Главы 12, применяя повторители для того, чтобы сделать некоторые места в рукописи более понятными и краткими. Давайте рассмотрим, как повторители могут улучшить нашу выполнение функции `Config::build` и функции `search`.

### Удаляем `clone`, используем повторитель 

В приложении 12-6 мы добавили рукопись, которая принимает срез значений `String` и создаёт образец данных стопки `Config` путём упорядочивания среза и удваивания значений, позволяя стопке `Config` владеть этими значениями. В приложении 13-17 мы воспроизвели выполнение функции `Config::build`, как это было в приложении 12-23:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch13-functional-features/listing-12-23-reproduced/src/lib.rs:ch13}}
```

<span class="caption">Приложение 13-17: Репродукция функции <code>Config::build</code> из приложения 12-23</span>

Ранее мы говорили, что не стоит беспокоиться о бесполезных вызовах `clone`, потому что мы удалим их в будущем. Ну что же, время пришло!

Нам понадобился здесь `clone`, потому что в свойстве `args` у нас срез с переменными `String`, но функция `build` не владеет `args`. Чтобы образец данных `Config` владел значениями, нам пришлось удваивать их из `args` в переменные `query` и `file_path`.

Благодаря нашим новым знаниям об повторителях мы можем изменить функцию `build`, чтобы вместо заимствования среза она принимала в качестве переменной повторитель . Мы будем использовать возможность повторителя вместо рукописи, которая проверяет длину среза и обращается по порядковому указателю к определённым значениям. Это позволит лучше понять, что делает функция `Config::build`, поскольку повторитель будет обращаться к значениям.

Как только `Config::build` получит в своё распоряжение повторитель и перестанет использовать действия упорядочивания с заимствованием, мы сможем переместить значения `String` из повторителя в `Config` вместо того, чтобы вызывать `clone` и создавать новое выделение памяти.

#### Использование возвращённого повторителя напрямую

Откройте файл *src/main.rs* дела ввода-вывода, который должен выглядеть следующим образом:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch13-functional-features/listing-12-24-reproduced/src/main.rs:ch13}}
```

Сначала мы изменим начало функции `main`, которая была в приложении 12-24, на рукопись в приложении 13-18, который теперь использует повторитель . Это не будет собираться, пока мы не обновим `Config::build`.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-18/src/main.rs:here}}
```

<span class="caption">Приложение 13-18: Передача возвращаемого значения из <code>env::args</code> в <code>Config::build</code></span>

Функция `env::args` возвращает повторитель ! Вместо того чтобы собирать значения повторителя в вектор и затем передавать срез в `Config::build`, теперь мы передаём владение повторителем, возвращённым из `env::args` в `Config::build` напрямую.

Далее нам нужно обновить определение `Config::build`. В файле *src/lib.rs* вашего дела ввода-вывода изменим ярлык `Config::build` так, чтобы она выглядела как в приложении 13-19. Это все ещё не собирается, потому что нам нужно обновить тело функции.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-19/src/lib.rs:here}}
```

<span class="caption">Приложение 13-19: Обновление ярлыки <code>Config::build</code> для определения повторителя как ожидаемого свойства</span>

Пособие встроенной библиотеки для функции `env::args` показывает, что вид данных возвращаемого ею повторителя - `std::env::Args`, и этот вид данных использует признак `Iterator` и возвращает значения `String`.

Мы обновили ярлык функции `Config::build`, чтобы свойство `args` имел гибкий вид данных ограниченный сущностью `impl Iterator<Item = String>` вместо `&[String]`. Такое использование правил написания `impl Trait`, который мы обсуждали в разделе [" Сущности как свойства"]<!-- ignore --> Главы 10, означает, что `args` может быть любым видом данных, выполняющим вид данных `Iterator` и возвращающим переменные `String`.

Поскольку мы владеем `args` и будем изменять `args` в этапе повторения над ним, мы можем добавить ключевое слово `mut` в свод требований свойства `args`, чтобы сделать его изменяемым.

#### Использование способов сущности `Iterator` вместо порядковых указателей

Далее мы подправим содержимое `Config::build`. Поскольку `args` использует признак `Iterator`, мы знаем, что можем вызвать у него способ `next`! В приложении 13-20 рукопись из приложения 12-23 обновлён для использования способа `next`:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-20/src/lib.rs:here}}
```

<span class="caption">Приложение 13-20: Изменяем тело <code>Config::build</code> так, чтобы использовать способы повторителя</span>

Помните, что первое значение в возвращаемых данных `env::args` - это имя программы. Мы хотим пренебрегать его и перейти к следующему значению, поэтому сперва мы вызываем `next` и ничего не делаем с возвращаемым значением. Затем мы вызываем `next`, чтобы получить значение, которое мы хотим поместить в поле `query` в `Config`. Если `next` возвращает `Some`, мы используем `match` для извлечения значения. Если возвращается `None`, это означает, что было задано недостаточно переменных, и мы досрочно возвращаем значение `Err`. То же самое мы делаем для значения `file_path`.

### Делаем рукопись понятнее с помощью переходников повторителей

Мы также можем воспользоваться преимуществами повторителей в функции `search` в нашем деле с действиеми ввода-вывода, которая воспроизведена здесь в приложении 13-21 так же, как и в приложении 12-19:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-19/src/lib.rs:ch13}}
```

<span class="caption">Приложение 13-21: Выполнение функции <code>search</code> из приложения 12-19</span>

Мы можем написать эту рукопись в более сжатом виде, используя способы переходника повторителя. Это также позволит нам избежать наличия изменяемого временного вектора `results`. Функциональное исполнение программирования предпосчитывает уменьшить количество изменяемого состояния, чтобы сделать рукопись более понятной. Удаление изменяемого состояния может позволить в будущем сделать поиск одновременным, поскольку нам не придётся управлять одновременным доступом к вектору `results`. В приложении 13-22 показано это изменение:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-22/src/lib.rs:here}}
```

<span class="caption">Приложение 13-22: Использование способов переходника повторителя в выполнении функции <code>search</code></span>

Напомним, что назначение функции `search` - вернуть все строки в `contents`, которые содержат `query`. Подобно примеру `filter` в приложении 13-16, эта рукопись использует переходник `filter`, чтобы сохранить только те строки, для которых `line.contains(query)` возвращает `true`. Затем мы собираем совпадающие строки в другой вектор с помощью `collect`. Так гораздо проще! Не стесняйтесь сделать такое же изменение для использования способов повторителя в функции `search_case_insensitive`.

### Выбор между круговоротами или повторителями

Следующий здоровый вопрос - какое исполнение вы должны выбрать в своей рукописи и почему: подлинное исполнение в приложении 13-21 или исполнение с использованием повторителей в приложении 13-22. Большинство программистов на языке Ржавчина предпочитают использовать исполнение повторителей. Сначала разобраться с ним немного сложно, но как только вы почувствуете, что такое различные переходники повторителей и что они делают, понять повторители станет проще. Вместо того чтобы возиться с различными переменными круговорота и создавать новые векторы, рукопись сосредотачивается на высокоуровневой цели круговорота. Это абстрагирует часть обычного рукописи, поэтому легче увидеть подходы, единственные для этой рукописи, такие как условие выборки, которое должен пройти каждая переменная в повторителе.

Но действительно ли эти две выполнения равнозначны? Интуитивно можно предположить, что более низкоуровневый круговорот будет быстрее. Давайте поговорим о производительности.


[" Сущности как свойства"]: ch10-02-traits.html#traits-as-parameters