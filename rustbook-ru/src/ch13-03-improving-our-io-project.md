## Собственный ящик с использованием ввода/вывода

Вооружившись полученными знаниями об повторителях, мы можем применить возможности для работы с вводом/выводом сведений, ранее рассмотрено в разделе Главы 12, применяя повторители для того, чтобы сделать упростить рукопись, сделать её более понятной и краткой. Давайте рассмотрим, как повторители могут справиться с этим при использовании способа (функции) `Config::build` и `search`.

### Удаляем `clone`, используем повторитель 

В приложении 12-6 мы добавили рукопись, которая принимает срез значений `String` и создаёт образец данных стопки `Config` путём упорядочивания среза и удваивания значений, позволяя стопке `Config` владеть этими значениями. В приложении 13-17 мы воспроизвели вызов способа (функции) `Config::build`, как это было в приложении 12-23:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch13-functional-features/listing-12-23-reproduced/src/lib.rs:ch13}}
```

<span class="caption">Приложение 13-17: Повтор способа (функции) <code>Config::build</code> из приложения 12-23</span>

Ранее мы говорили, что не стоит беспокоиться о бесполезных вызовах `clone`, потому что мы удалим их в будущем. Ну что же, время пришло!

Нам понадобился здесь `clone`, потому что в свойстве `args` у нас срез с переменными `String`, но способ (функция) `build` не владеет `args`. Чтобы образец данных `Config` владел значениями, нам пришлось раздваивать (выделять) их из `args` по отдельности в переменные `запрос` и `путь_до_файла`.

Благодаря нашим новым знаниям об повторителях мы можем изменить способ (функцию) `build`, чтобы вместо заимствования среза без права владения она принимала в качестве переменной повторитель . Мы будем использовать возможность повторителя вместо рукописи, которая проверяет длину среза и обращается по порядковому указателю к определённым значениям. Это позволит лучше понять, что делает способ (функция) `Config::build`, поскольку повторитель будет обращаться к значениям.

Как только `Config::build` получит в своё распоряжение повторитель и перестанет использовать действия упорядочивания с заимствованием, мы сможем переместить значения `String` из повторителя в `Config` вместо того, чтобы вызывать `clone` и создавать новое выделение памяти.

#### Использование возвращённого повторителя напрямую

Откройте файл _src/main.rs_ приложения ввода-вывода, который должен выглядеть следующим образом:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch13-functional-features/listing-12-24-reproduced/src/main.rs:ch13}}
```

Сначала мы изменим начало способа (функции) `main`, который был в приложении 12-24, на рукопись в приложении 13-18, которая теперь использует повторитель . Это не будет собираться, пока мы не обновим `Config::build`.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-18/src/main.rs:here}}
```

<span class="caption">Приложение 13-18: Передача возвращаемого значения из <code>env::args</code> в <code>Config::build</code></span>

Способ (функция) `env::args` возвращает повторитель ! Вместо того чтобы собирать значения повторителя в вектор и затем передавать срез в виде ссылки в `Config::build`, теперь мы передаём право владения повторителю, возвращённым из `env::args` в `Config::build` напрямую.

Далее нам нужно изменить описание `Config::build`. В файле _src/lib.rs_ вашего приложения ввода-вывода изменим ярлык `Config::build` так, чтобы он выглядел как в приложении 13-19. Эта рукопись не соберётся, потому что нам нужно обновить тело способа (функции).

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-19/src/lib.rs:here}}
```

<span class="caption">Приложение 13-19: Обновление ярлыка <code>Config::build</code> для определения повторителя как ожидаемого свойства</span>

Пособие встроенной библиотеки для способа (функции) `env::args` показывает, что вид данных возвращаемого ею повторителя - `std::env::Args`, и этот вид данных использует сущность `Iterator` и возвращает значения `String`.

Мы обновили ярлык способа (функции) `Config::build`, чтобы свойство `args` имело обобщенный вид данных, ограниченный сущностью `impl Iterator<Предмет = String>` вместо `&[String]`. Такое использование правил написания `impl Trait`, которые мы обсуждали в разделе [" Сущности как свойства"]<!-- ignore --> Главы 10, означает, что `args` может быть любым видом данных, использующий сущность `Iterator` и возвращающим вид данных `String`.

Поскольку мы владеем `args` и будем изменять `args` в этапе повторения над ним, мы можем добавить ключевое слово `mut` в свод требований свойства `args`, чтобы сделать его изменяемым.

#### Использование способов сущности `Iterator` вместо порядковых указателей

Далее мы подправим содержимое `Config::build`. Поскольку `args` использует сущность `Iterator`, мы знаем, что можем вызвать у него способ `next`! В приложении 13-20 рукопись из приложения 12-23 обновлён для использования способа `next`:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-20/src/lib.rs:here}}
```

<span class="caption">Приложение 13-20: Изменяем тело <code>Config::build</code> так, чтобы использовать способы повторителя</span>

Помните, что первое значение в возвращаемых данных `env::args` - это имя приложения. Мы хотим пренебречь им и перейти к следующему значению, поэтому сперва мы вызываем `next` и ничего не делаем с возвращаемым значением. Затем мы вызываем `next`, чтобы получить значение, которое мы хотим поместить в поле `запрос` в `Config`. Если `next` возвращает `Some`, мы используем `match` для извлечения значения. Если возвращается `None`, это означает, что было задано недостаточно переменных, и мы досрочно возвращаем значение `Err`. То же самое мы делаем для значения `путь_до_файла`.

### Делаем рукопись понятнее с помощью переходников повторителей

Мы также можем воспользоваться преимуществами повторителей в способе (функции) `search` в нашем деле с действиями ввода-вывода, которая воспроизведена здесь в приложении 13-21 так же, как и в приложении 12-19:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-19/src/lib.rs:ch13}}
```

<span class="caption">Приложение 13-21: Выполнение способа (функции) <code>search</code> из приложения 12-19</span>

Мы можем написать эту рукопись в более сжатом виде, используя способ переходника повторителя. Это также позволит нам избежать наличия изменяемого временного вектора `results`. Функциональное исполнение программирования предпосчитывает уменьшить количество изменяемого состояния, чтобы сделать рукопись более понятной. Удаление изменяемого состояния может позволить в будущем сделать поиск одновременным, поскольку нам не придётся управлять одновременным доступом к вектору `results`. В приложении 13-22 показано это изменение:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-22/src/lib.rs:here}}
```

<span class="caption">Приложение 13-22: Использование способов переходника повторителя в выполнении способа (функции) <code>search</code></span>

Напомним, что назначение способа (функции) `search` - вернуть все строки в `contents`, которые содержат `запрос`. Подобно примеру `filter` в приложении 13-16, эта рукопись использует способ `filter`, чтобы сохранить только те строки, для которых `строка.contains(запрос)` возвращает `true`. Затем мы собираем совпадающие строки в другой вектор с помощью `collect`. Так гораздо проще! Не стесняйтесь сделать такое же изменение для использования способов повторителя в способе (функции) `search_case_insensitive`.

### Выбор между круговоротами или повторителями

Следующий здоровый вопрос - какое исполнение вы должны выбрать в своей рукописи и почему: подлинное исполнение в приложении 13-21 или исполнение с использованием повторителей в приложении 13-22. Большинство разработчиков ПО на языке Ржавчина предпочитают использовать исполнение повторителей. Сначала разобраться с ним немного сложно, но как только вы почувствуете, что такое различные переходники повторителей и что они делают, понять повторители станет проще. Вместо того чтобы возиться с различными переменными круговорота и создавать новые векторы, рукопись сосредотачивается на высокоуровневой цели круговорота. Это абстрагирует часть обычного рукописи, поэтому легче увидеть подходы, единственные для этой рукописи, такие как условие выборки, которое должен пройти каждая переменная в повторителе.

Но действительно ли эти две выполнения равнозначны? Интуитивно можно предположить, что более низкоуровневый круговорот будет быстрее. Давайте поговорим о производительности.


[" Сущности как свойства"]: ch10-02-traits.html#traits-as-parameters