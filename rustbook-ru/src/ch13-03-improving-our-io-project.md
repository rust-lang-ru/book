## Улучшение проекта ввода/вывода

Обладая новыми знаниями об итераторах, можно улучшить проект ввода-вывода главы 12 используя итераторы, чтобы сделать места в коде более понятными и краткими. Давайте посмотрим, как итераторы могут улучшить нашу реализацию функции `Config::new` и функции `search`.

### Удаление метода `clone` используя итератор

В листинге 12-6 мы добавили код, который использовал срез  `String` и создал экземпляр структуры `Config`, взяв по индексам данные из среза и клонировав эти значения, таким образом позволив структуре `Config` владеть значениями. В листинге 13-24 мы повторили реализацию функции `Config::new`, как это было в листинге 12-23:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
impl Config {
    pub fn new(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var("CASE_INSENSITIVE").is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
```

<span class="caption">Листинг 13-24: Воспроизведение функции <code>Config::new</code> из листинга 12-23</span>

В то время мы говорили, что не стоит беспокоиться о неэффективных вызовах `clone`, потому что мы удалим их в будущем. Ну что же, это время пришло!

Нам был нужен вызов `clone` потому что у нас есть срез с элементами `String` в параметре `args`, но  функция `new` не владеет `args`. Чтобы вернуть владение экземпляром `Config`, нам пришлось клонировать значения из полей `query` и `filename` стуктуры `Config`, поэтому экземпляр `Config` может владеть своими значениями.

Обладая новыми знаниями об итераторах, мы можем изменить функцию `new`, чтобы она стала владельцем итератора аргумента, а не заимствовала срез. Мы будем использовать функциональность итератора вместо кода, который проверяет длину среза и получает данные по индексу. Это делает более понятным, что выполняет функция `Config::new`, потому что итератор получит доступ к значениям.

Как только `Config::new` заберет во владение итератор и перестанет использовать заимствующие операции индексирования, мы можем переместить значения `String` из итератора в `Config` вместо вызова `clone` и выполнения нового выделения памяти.

#### Использование возвращенного итератора напрямую

Откройте файл *src/main.rs* проекта ввода-вывода, который должен выглядеть следующим образом:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {}", err);
        process::exit(1);
    });

    // --snip--
}
```

Мы изменим начало функции `main`, которая была в  истинге 12-24, на код из листинга 13-25. Он не скомпилируется, пока мы не обновим `Config::new`.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
fn main() {
    let config = Config::new(env::args()).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {}", err);
        process::exit(1);
    });

    // --snip--
}
```

<span class="caption">Листинг 13-25: Передача возвращаемого значения <code>env::args</code> в <code>Config::new</code></span>

Функция `env::args` возвращает итератор! Вместо того, чтобы собирать значения итератора в вектор и затем передавать срез в `Config::new`, мы напрямую передаем во владение итератор, возвращенный из `env::args` параметром в `Config::new`.

Далее нам нужно обновить определение `Config::new`. В файле *src/lib.rs* вашего проекта ввода/вывода давайте изменим сигнатуру `Config::new` как показано в листинге 13-26. Код все равно еще не компилируется, потому что нам нужно обновить тело функции.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
impl Config {
    pub fn new(mut args: std::env::Args) -> Result<Config, &'static str> {
        // --snip--
```

<span class="caption">Листинг 13-26: Обновление сигнатуры <code>Config::new</code> для ожидания итератора</span>

Документация стандартной библиотеки для функции `env::args` показывает, что типом возвращаемого итератора является `std::env::Args`. Мы обновили сигнатуру функции `Config::new`, поэтому параметр `args ` имеет тип `std::env::Args` вместо `&[String]`. Поскольку мы забираем во владение `args` и будем изменять `args` перебирая его элементы, мы можем добавить ключевое слово `mut` в спецификацию параметра `args`, чтобы сделать его изменяемым.

#### Использование методов типажа `Iterator` вместо индексов

Далее мы вносим изменения в код тела `Config::new`. Стандартная библиотека документациитакже упоминает, что `std::env::Args` реализует типаж `Iterator`, поэтому мы знаем, что можем вызвать метод `next`! Листинг 13-27 обновляет код из листинга 12-23 с использованием метода `next`:

<span class="filename">Файл: src/lib.rs</span>

```rust
# fn main() {}
# use std::env;
#
# struct Config {
#     query: String,
#     filename: String,
#     case_sensitive: bool,
# }
#
impl Config {
    pub fn new(mut args: std::env::Args) -> Result<Config, &'static str> {
        args.next();

        let query = match args.next() {
            Some(arg) => arg,
            None => return Err("Didn't get a query string"),
        };

        let filename = match args.next() {
            Some(arg) => arg,
            None => return Err("Didn't get a file name"),
        };

        let case_sensitive = env::var("CASE_INSENSITIVE").is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
```

<span class="caption">Листинг 13-27: Новое содержание функции <code>Config::new</code> с использованием методов итератора</span>

Помните, что первое значение в возвращаемом значении типа `env::args` является имя программы. Мы хотим игнорировать его и перейти к следующему значению, поэтому сначала мы вызываем `next` и ничего не делаем с возвращаемым значением. Во-вторых, мы вызываем `next`, чтобы получить значение, которое мы хотим поместить в поле `query` структуры `Config`. Если `next` возвращает `Some`, мы используем `match` для извлечения значения. Если он возвращает `None`, это означает, что было передано недостаточно аргументов и мы рано выходим со значением `Err`. Мы делаем то же самое для значения `filename`.

### Делаем код понятнее с помощью адаптеров итераторов

Мы также можем использовать преимущества итераторов в функции `search` в проекте ввода/вывода, который приводится здесь в листинге 13-28, как это было в листинге 12-19:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
```

<span class="caption">Листинг 13-28: Реализация функции <code>search</code> из листинга 12-19</span>

Мы можем написать этот код более кратко, используя адаптерные методы итератора. Это также позволяет нам избежать использование изменяемого промежуточного вектора `result`. Стиль функционального программирования предпочитает минимизировать количество изменяемых состояний, чтобы сделать код более понятным. Удаление изменяемого состояния может позволить в будущем усовершенствовать и сделать поиск параллельным, потому что нам не нужно управлять одновременным доступом к вектору `results`. Листинг 13-29 показывает это изменение:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    contents.lines()
        .filter(|line| line.contains(query))
        .collect()
}
```

<span class="caption">Листинг 13-29: Использование адаптерных методов итератора в реализации функции <code>search</code></span>

Напомним, что целью функции `search` является возвращение всех строк `content`, содержащих `query`. Подобно примеру `filter` в листинге 13-19, этот код использует адаптер `filter` для выбора только тех строк, для которых код `line.contains(query)` возвращается значение `true`. Затем мы собираем совпадающие строки в другой вектор с помощью `collect`. Все намного проще! Не стесняйтесь вносить похожие изменения, чтобы использовать методы итератора в функции `search_case_insensitive`.

Следующий логический вопрос - какой стиль вы должны выбрать в своем собственном коде и почему, тот что был в исходной реализации в листинге 13-28 или версию с использованием итераторов в листинге 13-29. Большинство программистов на Rust предпочитают использовать стиль с итератором. Поначалу немного сложнее освоиться, но как только вы изучите различные адаптерные методы итераторов и то, что они делают, итераторы будет легче понять. Вместо того, чтобы возиться с различными элементами цикла и создавать новые векторы, код фокусируется на высокоуровневом смысле цикла. Это абстрагирует часть обычного кода, поэтому легче увидеть концепции уникальные для этого кода, такие как условие фильтрации, которое должен пройти каждый элемент в итераторе.

Но действительно ли эти конструкции равнозначны? Это вызывает сомнение. Рассуждения по поводу производительности мы продолжим в следующей секции этой главы.
