## Сравнение производительности круговоротов и повторителей

Чтобы определить, что лучше использовать круговороты или повторители, нужно знать, какая выполнение быстрее: исполнение функции `search` с явным круговоротом `for` или исполнение с повторителями.

Мы выполнили проверка производительности, разместив всё содержимое книги *(“The Adventures of Sherlock Holmes” by Sir Arthur Conan Doyle)* в строку вида данных `String` и поискали слово *the* в её содержимом. Вот итоги проверки функции `search` с использованием круговорота `for` и с использованием повторителей:

```text
test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
```

Исполнение с использованием повторителей была немного быстрее! Мы не будем приводить здесь непосредственно рукопись проверки, поскольку мысль не в том, чтобы доказать, что решения в точности равнозначны, а в том, чтобы получить общее представление о том, как эти две выполнения близки по производительности.

Для более исчерпывающего проверки, вам нужно проверить различные писания разных размеров в качестве содержимого для `contents`, разные слова и слова различной длины в качестве `query` и всевозможные другие исходы. Дело в том, что повторители, будучи высокоуровневой абстракцией, собираются примерно в тот же рукопись, как если бы вы написали его низкоуровневый исход самостоятельно. Повторители - это одна из *абстракций с нулевой стоимостью* ( zero-cost abstractions ) в Ржавчине под которой мы подразумеваем, что использование абстракции не накладывает дополнительных расходов во время выполнения. Подобно тому, как Бьёрн Страуструп, внешнем видер и разработчик C++, определяет *нулевые накладные расходы* ( zero-overhead ) в книге “Foundations of C++” (2012):

> В целом, выполнение C++ подчиняется принципу отсутствия накладных расходов: за то, чем вы не пользуетесь, платить не нужно. И далее: тот рукопись, что вы используете, нельзя сделать ещё лучше.

В качестве другого примера приведём рукопись, взятую из аудио декодера. Распорядок обратного преобразования использует математическое действие последовательного предсказания для оценки будущих значений на основе последовательной функции предыдущих выборок. Рукопись использует соединение вызовов повторителя для выполнения математических вычислений для трёх переменных в области видимости: срез данных `buffer`, массив из 12 множителей `coefficients` и число для сдвига данных в переменной `qlp_shift`. Переменные определены в примере, но не имеют начальных значений. Хотя эта рукопись не имеет большого значения вне среды, она является кратким, существующим примером того, как Ржавчина переводит мысли высокого уровня в рукопись низкого уровня.

```rust,ignore
let buffer: &mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&buffer[i - 12..i])
                                 .map(|(&c, &s)| c * s as i64)
                                 .sum::<i64>() >> qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
```

Чтобы вычислить значение переменной `prediction`, эта рукопись перебирает каждое из 12 значений в переменной `coefficients` и использует способ `zip` для объединения значений множителей с предыдущими 12 значениями в переменной `buffer`. Затем, для каждой пары мы перемножаем значения, складываем все итоги и у итога сложения сдвигаем биты вправо в переменную `qlp_shift`.

Для вычислений в таких приложениях, как аудио декодеры, часто требуется производительность. Здесь мы создаём повторитель , используя два переходника, впоследствии потребляющих значение. В какой ассемблерный рукописи будет собираться эта рукопись на Ржавчине? На время написания этой Главы она собирается в то же самое, что вы написали бы руками. Не существует круговорота, соответствующего повторения по значениям в «множителях»`coefficients`: Ржавчина знает, что существует двенадцать повторений, поэтому она «разворачивает» круговорот. *Разворачивание* - это улучшение, которая устраняет издержки рукописи управления круговоротом и вместо этого порождает повторяющуюся рукопись для каждом повторении круговорота.

Все множители сохраняются в регистрах, что означает очень быстрый доступ к значениям. Нет никаких проверок границ доступа к массиву во время выполнения. Все эти переработки, которые может применить Ржавчина делают полученный рукопись чрезвычайно производительным. Теперь, когда вы это знаете, используйте повторители и замыкания без страха! Они представляют рукопись в более высокоуровневом виде, но без потери производительности во время выполнения.

## Итоги

Замыкания (closures) и повторители (iterators) это возможности Ржавчины, вдохновлённые мыслями полезных языков. Они позволяют Ржавчина ясно выражать мысли высокого уровня с производительностью низкоуровневого рукописи. Выполнения замыканий и повторителей таковы, что нет влияния на производительность выполнения рукописи. Это одна из целей Ржавчина направленных на обеспечение абстракций с нулевой стоимостью (zero-cost abstractions).

Теперь, когда мы улучшили представление рукописи в нашем деле, рассмотрим некоторые возможности, которые нам предоставляет `cargo` для обнародования нашей рукописи в хранилища.
