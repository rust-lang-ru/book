## Определение разделов для управления видимости и закрытости

В этой главе мы поговорим о разделах и других частях их устройства, а именно: *путях* (paths), которые позволяют именовать переменные; ключевом слове `use`, которое приносит путь в область видимости; ключевом слове `pub`, которое делает переменные общедоступными. Мы также обсудим ключевое слово `as`, внешние дополнения и приказчик glob. А пока давайте сосредоточимся на разделах!

Во-первых, мы начнём со списка правил, чтобы вам было легче понять при согласовании рукописи в будущем. Затем мы подробно объясним каждое из правил.

### Шпаргалка по разделам

Здесь мы даём краткий обзор того, как разделы, пути, ключевое слово `use` и ключевое слово `pub` работают в сборщике и как большинство разработчиков согласуют свою рукопись. В этой главе мы рассмотрим примеры каждого из этих правил, и это удобное мгновение чтобы напомнить о том, как работают разделы.

- **Начнём с корня дополнения**: при сборке сборщик сначала ищет корневой раздел дополнения (обычно это *src/lib.rs* для библиотечного дополнения или *src/main.rs* для двоичного дополнения) для сборки рукописи.
- **Объявление разделов**: В файле корневого раздела дополнения вы можете объявить новые разделы; скажем, вы объявляете раздел “garden” с помощью `mod garden;`. Сборщик будет искать рукопись раздела в следующих местах:
    - в этом же файле, между узорчатых скобок, которые заменяют точку с запятой после `mod garden`
    - в файле *src/garden.rs*
    - в файле *src/garden/mod.rs*
- **Объявление подразделов**: В любом файле, кроме корневого раздела дополнения, вы можете объявить подразделы. К примеру, вы можете объявить  `mod vegetables;` в *src/garden.rs*. Сборщик будет искать рукопись подраздела в папке с именем родительского раздела в следующих местах:
    - в этом же файле, сразу после `mod vegetables`, между узорчатых скобок, которые заменяют точку с запятой
    - в файле *src/garden/vegetables.rs*
    - в файле *src/garden/vegetables/mod.rs*
- **Пути к рукописи в разделах**: После того, как раздел станет частью вашего дополнения и если допускают правила закрытости, вы можете ссылаться на рукопись в этом разделе из любого места вашего дополнения, используя путь к рукописи. Например, вид данных `Asparagus`, в подразделе vegetables раздела garden, будет найден по пути `crate::garden::vegetables::Asparagus`.
- **Скрытие или общедоступность**: Рукопись в разделе по умолчанию скрыта от родительского раздела. Чтобы сделать раздел общедоступным, объявите его как `pub mod` вместо `mod`. Чтобы сделать содержимое общедоступного раздела тоже общедоступными, используйте `pub` перед их объявлением.
- **Ключевое слово `use`**: Внутри области видимости использование ключевого слова `use` создаёт псевдонимы для переменных, чтобы уменьшить повторение длинных путей. В любой области видимости, в которой может обращаться к `crate::garden::vegetables::Asparagus`, вы можете создать псевдоним `use crate::garden::vegetables::Asparagus;` и после этого вам нужно просто писать `Asparagus`, чтобы использовать этот вид данных в этой области видимости.

Мы создали двоичный дополнение `backyard`, который отображает эти правила. Содержимое дополнения, также названное как `backyard`, содержит следующие файлы и папки:

```text
backyard
├── Cargo.lock
├── Cargo.toml
└── src
    ├── garden
    │   └── vegetables.rs
    ├── garden.rs
    └── main.rs
```

Файл корневого раздела дополнения в нашем случае  *src/main.rs*, и его содержимое:

<span class="filename">Файл: src/main.rs</span>

```rust,noplayground,ignore
{{#rustdoc_include ../listings/ch07-managing-growing-projects/quick-reference-example/src/main.rs}}
```

Строка `pub mod garden;` говорит сборщику о подключении  в *src/garden.rs*:

<span class="filename">Файл: src/garden.rs</span>

```rust,noplayground,ignore
{{#rustdoc_include ../listings/ch07-managing-growing-projects/quick-reference-example/src/garden.rs}}
```

А здесь `pub mod vegetables;` указывает на подключаемую рукопись в *src/garden/vegetables.rs*. Содержимое данной рукописи:

```rust,noplayground,ignore
{{#rustdoc_include ../listings/ch07-managing-growing-projects/quick-reference-example/src/garden/vegetables.rs}}
```

Теперь давайте рассмотрим подробности этих правил и проверим их в действии!

### Объединение связанной рукописи в разделах

*Разделы* позволяют упорядочивать рукопись внутри дополнения для удобства читаемости и лёгкого повторного использования. Разделы также позволяют нам управлять *закрытостью* переменных, поскольку рукопись внутри раздела по умолчанию является закрытой. Частные переменные — это внутренние подробности выполнения, недоступные для внешнего использования. Мы можем сделать разделы и переменные внутри них общедоступными, что позволит внешней рукописи использовать их и зависеть от них.

В качестве примера, давайте напишем библиотечное дополнение предоставляющий возможность ресторана. Мы определим ярлыки функций, но оставим их тела пустыми, чтобы сосредоточиться на согласовании рукописи, вместо выполнения рукописи для ресторана.

В ресторанной индустрии некоторые части ресторана называются *передом дома*, а другие *задней частью дома*. Перед дома это там где находятся конечные потребители; здесь размещаются места конечных потребителей, официанты принимают заказы и оплаты, а бармены делают напитки. Задняя часть дома это где шеф-повара и повара работают на кухне,  работают посудомоечные машины, а управленцы занимаются управленческой деятельностью.

Чтобы внутренне выстроить дополнение подобно тому, как работает настоящий ресторан, можно согласовать размещение функций во вложенных разделах. Создадим новую библиотеку (библиотечное дополнение) с именем `restaurant` выполнив приказ `cargo new restaurant --lib`; затем вставим рукопись из приложения 7-1 в *src/lib.rs* для определения некоторых разделов и ярлыков функций. Это раздел переда дома:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-01/src/lib.rs}}
```

<span class="caption">Приложение 7-1: Раздел <code>front_of_house</code> , содержащий другие разделы, которые в свою очередь содержат функции</span>

Мы определяем раздел, начиная с ключевого слова  `mod`, затем определяем название раздела (в данном случае `front_of_house`) и размещаем узорчатые скобки вокруг тела раздела. Внутри разделов, можно иметь другие разделы, как в случае с разделами `hosting` и `serving`. Разделы также могут содержать определения для других переменных, таких как стопки, перечисления, постоянные переменные, сущности или — как в приложении 7-1 — функции.

Используя разделы, мы можем объединять связанные определения вместе и сказать почему они являются связанными. Разработчикам будет легче найти необходимую возможность в объединенной рукописи, вместо того чтобы искать её в одном общем списке. Разработчики, добавляющие новые функции в эту рукопись, будут знать, где разместить рукопись для поддержания порядка в программе.

Как мы упоминали ранее, файлы *src/main.rs* и *src/lib.rs* называются *корневыми разделами дополнения*. Причина такого именования в том, что содержимое любого из этих двух файлов образует раздел с именем `crate` в корне дерева разделов дополнения, известным как *дерево разделов*.

В приложении 7-2 показано дерево разделов для дерева разделов, приведённого в рукописи приложения 7-1.

```text
crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
```

<span class="caption">Приложение 7-2: Древо разделов для приложения из Приложения 7-1</span>

Это дерево показывает, как некоторые из разделов вкладываются друг в друга; например, `hosting` находится внутри `front_of_house`. Дерево также показывает, что некоторые разделы являются  *братьями* (siblings) друг для друга, то есть они определены в одном разделе; `hosting` и `serving` это братья, которые определены внутри `front_of_house`. Если раздел A содержится внутри раздела B, мы говорим, что раздел A является *потомком* (child) раздела B, а раздел B является *родителем* (parent) раздела A. Обратите внимание, что родителем всего дерева разделов является неявный раздел с именем `crate`.

Дерево разделов может напомнить вам дерево папок файловой системы на компьютере; это очень удачное сравнение! По подобию с папками в файловой системе, мы используем разделы для согласования рукописи. И так же, как нам надо искать файлы в папках на компьютере, нам требуется способ поиска нужных разделов.
