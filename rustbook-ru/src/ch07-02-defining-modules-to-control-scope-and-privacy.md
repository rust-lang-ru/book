## Определение разделов для управления видимости и закрытости

В этой главе мы поговорим о разделах и их устройстве, а именно: *путях* (paths), которые позволяют обращаться к содержимому. Ключевое слове `use`, которое подключает содержимое (звено), а `pub` позволяет сделать содержимое (звено) общедоступным. Мы также обсудим ключевое слово `as`, внешние дополнения и приказчик glob. А пока давайте сосредоточимся на разделах!



### Памятка по разделам
Во-первых, мы начнём со списка правил, чтобы вам было легче понять при согласовании рукописи в будущем. Затем мы подробно объясним каждое из правил.
Здесь мы даём краткий обзор того, как разделы, пути, ключевые слова `use` и  `pub` работают в сборщике и как большинство разработчиков согласуют свою рукопись. В этой главе мы рассмотрим примеры каждого из этих правил, и это удобное мгновение чтобы напомнить о том, как работают разделы.

- **Начнём с корня ящика**: при сборке ящика сначала выполняется поиск в корневом разделе ящика (обычно это *src/lib.rs* для библиотечного ящика или *src/main.rs* для исполняемого ящика) для сборки рукописи.
- **Объявление разделов**: В файле корневого раздела ящика вы можете объявить новые разделы. Скажем, вы объявляете раздел `“сад”` с помощью `mod сад;`. <br>Сборщик будет искать рукопись раздела в следующих местах:
    - в этом же файле, внутри тела раздела - между узорчатых скобок, которые заменяют точку с запятой после `mod сад`
    - в файле *src/сад.rs*
    - в файле *src/сад/mod.rs*
- **Объявление подразделов**: В любом файле, кроме корневого раздела ящика, вы можете объявить подразделы. К примеру, вы можете объявить  `mod овощи;` в *src/сад.rs*.<br> Сборщик будет искать рукопись подраздела в папке с именем родительского раздела в следующих местах:
    - в этом же файле, сразу после `mod овощи`, внутри тела раздела - между узорчатых скобок, которые заменяют `;` (точку с запятой)
    - в файле *src/сад/овощи.rs*
    - в файле *src/сад/овощи/mod.rs*
- **Пути к рукописи в разделах**: После того, как раздел станет частью вашего ящика и если допускают правила закрытости, вы можете ссылаться на рукопись в этом разделе из любого места вашего ящика, используя путь к рукописи. Например, вид данных `Спаржа`, в подразделе `овощи` раздела `сад`, будет найден по пути `crate::сад::овощи::Спаржа`.
- **Скрытость или общедоступность**: Рукопись в разделе по умолчанию скрыта от родительского раздела. Чтобы сделать раздел общедоступным, объявите его как `pub mod` вместо `mod`. Чтобы сделать содержимое общедоступного раздела тоже общедоступными, используйте `pub` перед их объявлением.
- **Ключевое слово `use`**: Внутри области видимости использование ключевого слова `use` создаёт ярлыки для переменных, чтобы уменьшить повторение длинных путей. В любой области видимости, которая может обращаться к `crate::сад::овощи::Спаржа`, вы можете создать ярлык `use crate::сад::овощи::Спаржа;` и после этого вам нужно просто указать `Спаржа`, чтобы использовать этот вид данных в этой области видимости.

Мы создали исполняемый ящик `backyard`, который содержит эти правила. Содержимое ящика, также названное как `backyard`, содержит следующие файлы и папки:

```text
backyard
├── Cargo.lock
├── Cargo.toml
└── src
    ├── сад
    │   └── овощи.rs
    ├── сад.rs
    └── main.rs
```

Файл корневого раздела дополнения в нашем случае  *src/main.rs*, и его содержимое:

<span class="filename">Файл: src/main.rs</span>

```rust,noplayground,ignore
{{#rustdoc_include ../listings/ch07-managing-growing-projects/quick-reference-example/src/main.rs}}
```

Строка `pub mod сад;` говорит сборщику о подключении раздела `сад`, который находится в *src/сад.rs*:

<span class="filename">Файл: src/сад.rs</span>

```rust,noplayground,ignore
{{#rustdoc_include ../listings/ch07-managing-growing-projects/quick-reference-example/src/garden.rs}}
```

Раздел `pub mod овощи;` указывает на подключаемый подраздел в *src/сад/овощи.rs*. Содержимое данного подраздела:

```rust,noplayground,ignore
{{#rustdoc_include ../listings/ch07-managing-growing-projects/quick-reference-example/src/garden.rs}}
```

Теперь давайте рассмотрим подробности этих правил и проверим их в действии!

### Объединение связанной рукописи в разделах

*Разделы* позволяют упорядочить рукопись внутри ящика для удобства прочтения и облегчения повторного использования. Разделы также позволяют нам управлять *закрытостью* содержимого, поскольку содержимое внутри раздела по умолчанию является закрытым. Частное содержимое — это внутренние звенья раздела (способы-переменные-сущности и т.д.), недоступные для внешнего использования. Мы можем сделать разделы и связанное внутри них содержимое внутри них общедоступно, что позволит внешним ящикам,дополнениям использовать их и быть с ним привязанными.

В качестве примера, давайте создадим библиотечный ящик, предназначенный для управления рестораном. Мы изложим способы (функции), но оставим их тела пустыми, чтобы сосредоточиться на создании и согласовании рукописи, вместо вызова этих способов (способов (функций)) для управления рестораном.

В ресторане принято, что есть 2 части ресторана, которые называются *передом дома*, а другие *тылом_дома*. *Перед дома* это там, где находятся конечные потребители. Здесь рассаживаются посетители, официанты принимают заказы и оплаты, а бармены делают напитки. Тыл дома это где шеф-повара и повара работают на кухне,  работают посудомоечные машины, а управленцы занимаются решением поступающих вопросов.

Чтобы внутренне выстроить ящик подобно тому, как работает настоящий ресторан, необходимо согласовать размещение способов (способов (функций)) во вложенных разделах. Создадим новую библиотеку (библиотечный ящик) с именем `restaurant` вызвав приказ `cargo new restaurant --lib`. Затем вставим рукопись из приложения 7-1 в *src/lib.rs* для определения некоторых разделов и изложений способов (функций). Это раздел переда дома:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-01/src/lib.rs}}
```

<span class="caption">Приложение 7-1: Раздел <code>перед_дома</code> , содержащий другие подразделы, которые в свою очередь содержат способы (функции)</span>

Мы создаём раздел, начиная с ключевого слова `mod`, затем определяем название раздела (в данном случае `перед_дома`). После чего помещаем содержимое раздела внутрь узорчатых скобок. Внутри разделов, можно иметь другие подразделы, как в случае с разделами `hosting` и `serving`. Разделы также могут содержать в себе другие звенья - такие как переменные, стопки, перечисления, постоянные переменные, сущности или — как в приложении 7-1 — способы (функции).

Используя разделы, мы можем объединять связанное их содержимое вместе и сказать, почему они являются связанными. Разработчикам будет легче найти необходимое содержимое в одном общем ящике с разделами, вместо того чтобы искать её в одном бесконечно длинном списке. Разработчики, добавляющие новые возможности в этот ящик, будут знать, где разместить изложение того или иного звена для согласования общего устройства ящика.

Как мы упоминали ранее, файлы *src/main.rs* и *src/lib.rs* называются *корневыми разделами ящика*. Причина такого именования в том, что содержимое любого из этих двух файлов создаёт ящик с именем `crate` в корне дерева разделов, известным как *дерево разделов*.

В приложении 7-2 показано дерево разделов для ящика из приложения 7-1.

```text
crate
 └── перед_дома
     ├── hosting
     │   ├── добавить_в_ожидание
     │   └── сесть_за_стол
     └── serving
         ├── сделать_заказ
         ├── подать_заказ
         └── оплатить
```

<span class="caption">Приложение 7-2: Древо разделов ящика из Приложения 7-1</span>

Это дерево показывает, как некоторые из разделов вкладываются друг в друга. Например, `hosting` находится внутри `перед_дома`. Дерево также показывает, что некоторые разделы являются  *родственными* (siblings) друг для друга, то есть они определены в одном разделе. Так `hosting` и `serving` это родственные разделы, которые определены внутри `перед_дома`. Если раздел A содержится внутри раздела B, мы говорим, что раздел A является *порождённым* (child) от раздела B, а раздел B является *родителем* (parent) раздела A. Обратите внимание, что родителем всего дерева разделов является неявный раздел с именем `crate`.

Дерево разделов может напоминать вам дерево папок файловой системы на компьютере, это очень удачное сравнение! По подобию с папками в файловой системе, мы используем разделы для согласования ящиков. И так же, как нам надо искать файлы в папках на компьютере, нам требуется способ поиска нужных разделов.
