## Подключение путей в область видимости с помощью ключевого слова `use`

Необходимость записывать пути к функциям вызова может показаться неудобной и повторяющейся. В приложении 7-7 независимо от того, выбирали ли мы безусловный или относительный путь к способы (функции) `add_to_waitlist` , каждый раз, когда мы хотели вызвать `add_to_waitlist` , нам приходилось также указывать `front_of_house` и `hosting` . К счастью, есть способ упростить этот этап: мы можем один раз создать псевдоним на путь при помощи ключевого слова `use`, а затем использовать более короткое имя везде в области видимости.

В приложении 7-11 мы подключили раздел `crate::front_of_house::hosting` в область действия способы (функции) `eat_at_restaurant`, поэтому нам достаточно только указать `hosting::add_to_waitlist` для вызова способы (функции) `add_to_waitlist` внутри `eat_at_restaurant`.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground,test_harness
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-11/src/lib.rs}}
```

<span class="caption">Приложение 7-11: Добавление раздела в область видимости при помощи <code>use</code></span>

Добавление `use` и пути в область видимости подобно созданию условной ссылки в файловой системе. С добавлением `use crate::front_of_house::hosting` в корневой раздел дополнения, `hosting` становится допустимым именем в этой области, как если бы раздел `hosting` был определён в корневом разделе дополнения. Пути, подключённые в область видимости с помощью `use`, также проверяются на доступность, как и любые другие пути.

Обратите внимание, что `use` создаёт псевдоним только для той именно области, в которой это объявление `use` и находится. В приложении 7-12 способ (функция) `eat_at_restaurant` передаётся в новый дочерний раздел с именем `customer`, область действия которого отличается от области действия указания `use`, поэтому тело способы (функции) не будет собираться:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground,test_harness,does_not_compile,ignore
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-12/src/lib.rs}}
```

<span class="caption">Приложение 7-12: Указание <code>use</code> применяется только в её собственной области видимости</span>

Ошибка сборщика показывает, что данный псевдоним не может использоваться в разделе `customer`:

```console
{{#include ../listings/ch07-managing-growing-projects/listing-07-12/output.txt}}
```

Обратите внимание, что есть также предупреждение о том, что `use` не используется в своей области! Чтобы решить эту неполадку, можно переместить `use` в раздел `customer`, или же можно сослаться на псевдоним в родительском разделе с помощью `super::hosting` в дочернем разделе `customer`.

### Создание определенных путей с `use`

В приложении 7-11 вы могли бы задаться вопросом, почему мы указали  `use crate::front_of_house::hosting`, а затем вызвали `hosting::add_to_waitlist` внутри `eat_at_restaurant` вместо указания в  `use` полного пути прямо до способы (функции) `add_to_waitlist` для получения того же итога, что в приложении 7-13.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground,test_harness
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-13/src/lib.rs}}
```

<span class="caption">Приложение 7-13: Добавление способы (функции) <code>add_to_waitlist</code> в область видимости с <code>use</code> не обычным способом</span>

Хотя приложении 7-11 и 7-13 выполняют одну и ту же задачу, рукопись в приложении 7-11 является принятым способом подключения способы (функции) в область видимости с помощью `use`. Подключение родительского раздела способы (функции) в область видимости при помощи `use` означает, что мы должны указывать родительский раздел при вызове способа (функции). Указание родительского раздела при вызове способа (функции) даёт понять, что способ (функция) не определена своё, но в то же время сводя к уменьшению повторение полного пути. В рукописи приложения 7-13 не ясно, где именно определена `add_to_waitlist`.

С другой стороны, при подключении стопок, перечислений и других переменных используя `use`, согласно принятых договоренностей правильным будет указывать полный путь. Приложение 7-14 показывает принятый способ подключения одного из видов данных встроенной библиотеки - `HashMap` в область видимости исполняемого дополнения.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-14/src/main.rs}}
```

<span class="caption">Приложение 7-14: Включение <code>HashMap</code> в область видимости принятым способом</span>

За этим устойчивым выражением нет веской причины: это просто соглашение, которое появилось само собой. Люди привыкли читать и писать рукопись на Ржавчине таким образом.

Исключением из этого устойчивого выражения является случай, когда мы подключаем два имени переменных или способа с одинаковыми именами в область видимости используя указанию `use` — Ржавчина просто не позволяет этого сделать. Приложение 7-15 показывает, как подключить в область действия два способа с одинаковыми именами `Result`, но из разных родительских разделов и как на них ссылаться.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-15/src/lib.rs:here}}
```

<span class="caption">Приложение 7-15: Для включения двух способов с одинаковыми именами в одну область видимости необходимо использовать их родительские разделы.</span>

Как видите, использование имени родительских разделов позволяет различать два исхода `Result`. Если бы вместо этого мы указали `use std::fmt::Result` и `use std::io::Result`, мы бы имели два способа `Result` в одной области видимости, и Ржавчина не смогла бы понять какой из двух способов `Result` мы имели в виду, когда нашла бы их употребление в рукописи.

### Предоставление новых имён с помощью ключевого слова `as`

Есть другое решение сбоев добавления двух способов с одинаковыми именами в одну и ту же область видимости используя `use`: после пути можно указать `as` и новое своё имя (псевдоним) для способа. Приложение 7-16 показывает как по-другому написать рукопись из приложения 7-15, путём переименования одного из двух способов `Result` используя `as`.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-16/src/lib.rs:here}}
```

<span class="caption">Приложение 7-16: Переименование способа, когда он включён в область видимости с помощью ключевого слова <code>as</code></span>

во втором указании `use` мы выбрали новое имя `IoResult` для способа `std::io::Result`, которое теперь не будет враждовать со способом `Result` из `std::fmt`, который также подключён в область видимости. Приложения 7-15 и 7-16 считаются идиоматичными, поэтому выбор за вами!

### Реэкспорт имён с `pub use`

Когда мы подключаем имя в область видимости, используя ключевое слово `use`, то имя, доступное в новой области видимости, является закрытым. Чтобы позволить рукописи, которая вызывает нашу рукопись, ссылаться на это имя, как если бы оно было определено в области видимости данной рукописи, можно объединить `pub` и `use`. Этот способ называется *реэкспортом (re-exporting)*, потому что мы подключаем переменную или способ в область видимости, но также делаем эту переменную или способ доступным для подключения в других областях видимости.

Приложение 7-17 показывает рукопись из приложения 7-11, где `use` в корневом разделе заменено на `pub use`.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground,test_harness
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-17/src/lib.rs}}
```

<span class="caption">Приложение 7-17: Предоставление имени для использования любой рукописью из новой области при помощи <code>pub use</code></span>

До этого изменения наша внешняя рукопись должна была вызывать способ (функцию) `add_to_waitlist` , используя путь `restaurant::front_of_house::hosting::add_to_waitlist()` . Теперь, когда это объявление `pub use` повторно экспортировало раздел `hosting` из корневого раздела, внешняя рукопись теперь может использовать вместо него путь `restaurant::hosting::add_to_waitlist()` .

Реэкспорт полезен, когда внутреннее устройство вашей рукописи отличается от того, как разработчики, вызывающие вашу рукопись, думают о предметной области. Например, по подобию с рестораном люди, управляющие им, думают о «передней части дома» и «задней части дома». Но конечные потребители, посещающие ресторан, вероятно, не будут думать о частях ресторана в таких понятиях. Используя `pub use` , мы можем написать нашу рукопись с одним устройством, но сделать общедоступным другое устройство. Благодаря этому наша библиотека хорошо согласована для разработчиков ПО, работающих над библиотекой, и для разработчиков ПО, вызывающих библиотеку. Мы рассмотрим ещё один пример `pub use` и его влияние на пособие вашего дополнения в разделе <a href="ch14-02-publishing-to-crates-io.html#exporting-a-convenient-public-api-with-pub-use" data-md-type="link">«Экспорт удобного общедоступного API с `pub use`»</a><!-- ignore --> Главы 14.

### Использование внешних дополнений

В Главе 2 мы запрограммировали игру угадывания числа, где использовался внешнее дополнение с именем `rand` для создания случайного числа. Чтобы использовать `rand` в нашем деле, мы добавили эту строку в *Cargo.toml*:

<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch14-03-cargo-workspaces.md
-->

<span class="filename">Файл: Cargo.toml</span>

```toml
{{#include ../listings/ch02-guessing-game-tutorial/listing-02-02/Cargo.toml:9:}}
```

Добавление `rand` в качестве дополнения в *Cargo.toml* указывает Cargo загрузить дополнение `rand` и все его зависимости из [crates.io](https://crates.io/) и сделать `rand` доступным для нашего дела.

Затем, чтобы подключить определения `rand` в область видимости нашего дополнения, мы добавили строку `use` начинающуюся с названия дополнения `rand` и списка способов, которые мы хотим подключить в область видимости. Напомним, что в разделе ["Создание случайного числа"]<!-- ignore --> Главы 2, мы подключили сущность `Rng` в область видимости и вызвали способ (функцию) `rand::thread_rng`:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-03/src/main.rs:ch07-04}}
```

Члены сообщества Ржавчина сделали много дополнений доступными на источнике [crates.io](https://crates.io/), и добавление любого из них в ваше дело включает в себя одни и те же шаги: добавить внешние дополнения в файл *Cargo.toml* вашего приложения, использовать `use` для подключения содержимого внешних дополнений в область видимости.

Обратите внимание, что встроенная библиотека `std` также является дополнением, внешним по отношению к нашему делу. Поскольку встроенная библиотека поставляется с языком Ржавчина, нам не нужно изменять *Cargo.toml* для подключения `std`. Но нам нужно ссылаться на неё при помощи `use`, чтобы добавить переменные оттуда в область видимости нашего дела. Например, с `HashMap` мы использовали бы эту строку:

```rust
use std::collections::HashMap;
```

Это безусловный путь, начинающийся с `std`, имени дополнения встроенной библиотеки.

### Использование вложенных путей для уменьшения длинных списков `use`

Если мы используем несколько способов, определённых в одном дополнение или в том же разделе, то перечисление каждой переменной в отдельной строке может занимать много вертикального пространства в файле. Например, эти два указания `use` используются в программе угадывания числа (приложение 2-4) для подключения способов из `std` в область видимости:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch07-managing-growing-projects/no-listing-01-use-std-unnested/src/main.rs:here}}
```

Вместо этого, мы можем использовать вложенные пути, чтобы добавить эти переменные в область видимости одной строкой. Мы делаем это, как показано в приложении 7-18, указывая общую часть пути, за которой следуют два двоеточия, а затем узорчатые скобки вокруг списка тех частей продолжения пути, которые отличаются.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-18/src/main.rs:here}}
```

<span class="caption">Приложение 7-18: Указание вложенного пути для добавления нескольких способов с одинаковой приставкой в область видимости</span>

В больших приложениех, подключение множества содержимого из одного дополнения или раздела с использованием вложенных путей может значительно сократить количество необходимых отдельных указаний `use`!

Можно использовать вложенный путь на любом уровне, что полезно при объединении двух указаний `use`, которые имеют общую часть пути. Например, в приложении 7-19 показаны два указания `use`: одна подключает `std::io`, а другая подключает `std::io::Write` в область видимости.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-19/src/lib.rs}}
```

<span class="caption">Приложение 7-19: Два указания <code>use</code>, в которых один путь является частью другого</span>

Общей частью этих двух путей является `std::io`, и это полный первый путь. Чтобы объединить эти два пути в одном указании `use`, мы можем использовать ключевое слово `self` во вложенном пути, как показано в приложении 7-20.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-20/src/lib.rs}}
```

<span class="caption">Приложение 7-20: Объединение путей из Приложения 7-19 в одно указание <code>use</code></span>

Эта строка подключает `std::io` и `std::io::Write` в область видимости.

### Приказчик * (glob)

Если мы хотим включить в область видимости *все* общедоступные переменные, определённые в пути, мы можем указать этот путь, за которым следует приказчик `*`:

```rust
use std::collections::*;
```

Это указание `use` подключает все открытые переменные из раздела `std::collections` в текущую область видимости. Будьте осторожны при использовании приказчика `*`! Он может усложнить понимание, какие имена находятся в области видимости и где были определены имена, используемые в вашей программе.

Приказчик `*` часто используется при проверке для подключения всего что есть в разделе `tests`; мы поговорим об этом в разделе ["Как писать проверки"]<!-- ignore --> Главы 11. Приказчик `*` также иногда используется как часть образца *самостоятельного подключения (prelude)*: смотрите [пособие по встроенной библиотеке](https://doc.rust-lang.org/std/prelude/index.html#other-preludes)<!-- ignore --> для получения дополнительных сведений об этом образце.


["Создание случайного числа"]: ch02-00-guessing-game-tutorial.html#generating-a-random-number
["Как писать проверки"]: ch11-01-writing-tests.html#how-to-write-tests