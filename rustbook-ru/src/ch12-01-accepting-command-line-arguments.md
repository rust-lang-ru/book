## Принятие переменных приказной строки

Создадим новый ящик с окном вывода приложения как обычно с помощью приказов `cargo new`. Мы назовём ящик `minigrep`, чтобы различать наше приложение от `grep`, которое возможно уже есть в вашей системе.

```console
$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
```

Первая задача - заставить `minigrep` принимать две переменных приказной строки: путь к файлу и строку для поиска. То есть мы хотим иметь возможность запускать нашу программу через `cargo run`, с использованием двойного дефиса, чтобы указать, что следующие переменные предназначены для нашей приложения, а не для `cargo`, это путь к файлу в котором нужно искать и строка для поиска, как описано ниже:

```console
$ cargo run -- searchstring example-filename.txt
```

В данное мгновение приложение созданная `cargo new` не может обрабатывать переменные, которые мы ей передаём. Некоторые существующие библиотеки на [crates.io](https://crates.io/) могут помочь с написанием приложения, которая принимает переменные приказной строки, но так как вы просто изучаете этот подход, давайте применим эту возможность сами.

### Чтение значений переменных

Чтобы `minigrep` мог воспринимать значения переменных приказной строки, которые мы ему передаём, нам понадобится способ (функция) `std::env::args`, входящая во встроенную библиотеку Ржавчины. Этот способ (функция) возвращает значение переменных приказной строки с помощью повторителя, переданных в `minigrep`. Мы подробно рассмотрим повторители в [главе 13]<!-- ignore -->. Пока вам достаточно знать две вещи об повторителях: повторители порождают последовательность значений, и мы можем вызвать способ `collect` у повторителя, чтобы собрать все значение в один вид данных, например в вектор, который будет содержать все переменные, произведённые повторителем.

Рукопись, представленная в Приложении 12-1 позволяет вашей программе `minigrep` получать любые переданные ей значения приказной строки, а затем собирать значения в вектор.

<span class="filename">Файл: src/main.rs . Сбор значений приказной строки в вектор и их вывод </span>

```rust
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-01/src/main.rs}}
```

<span class="caption">Приложение 12-1: Собираем переменные приказной строки в вектор и выводим их в окно</span>

Сначала мы вводим раздел `std::env` в область видимости с помощью указания `use`, чтобы мы могли использовать его способ (функцию) `args`. Обратите внимание, что способ (функция) `std::env::args` вложена в два уровня разделов. Как мы обсуждали в [главе 7]<!-- ignore -->, в случаях, когда нужная способ (функция) оказывается вложенной в более чем один раздел, советуется выносить в область видимости родительский раздел, а не способ (функцию). Таким образом, мы можем легко использовать другие способы (функции) из `std::env`. Это менее двусмысленно, чем добавление `use std::env::args` и последующий вызов способа (функции) только с `args`, потому что `args` может быть легко принят за способ (функцию), определённую в текущем разделе.

> ### Способ (функция) `args` и недействительный знак Unicode
> Обратите внимание, что `std::env::args` вызовет сбой, если какая-либо переменная содержит недопустимый знак Unicode. Если вашей программе необходимо принимать переменные, содержащие недопустимые знаки Unicode, используйте вместо этого `std::env::args_os`. Этот способ (функция) возвращает способ (повторитель), который выдаёт значения `OsString` вместо значений `String`. Мы решили использовать `std::env::args` здесь для простоты, потому что значения `OsString` отличаются для каждой ОС и устройства и с ними сложнее работать, чем со значениями `String`.

В первой строке внутри `main` мы вызываем `env::args` и сразу используем способ `collect`, чтобы собрать все значения `String` в `Vec<String>`. Мы можем использовать способ `collect` для сбора значений во многие виды данных, поэтому мы явно определяем вид данных `args`, чтобы указать, что мы хотим вектор строк. Хотя нам очень редко нужно определять виды данных в Ржавчине, `collect` - это один из способов, при использовании которого вам часто нужно указывать вид данных, потому что Ржавчина не может сама определить в какой именно вид данных необходимо собрать значения.

И в заключение мы выводим вектор с помощью отладочного макроса. Попробуем запустить рукопись сначала без переменных, а затем с двумя переменными:

```console
{{#include ../listings/ch12-an-io-project/listing-12-01/output.txt}}
```

```console
{{#include ../listings/ch12-an-io-project/output-only-01-with-args/output.txt}}
```

Обратите внимание, что первое значение в векторе `"target/debug/minigrep"` является путём до нашего исполняемого файла. Это соответствует поведению списка переменных в Си, позволяя приложением использовать значения, с которым они были вызваны при выполнении. Часто бывает удобно иметь доступ к пути приложения, если вы хотите вывести его в сообщениях или изменить поведение приложения в зависимости от того, какое значение приказной строки было использовано для вызова приложения. В рамках этой Главы, мы рассмотрим только две переменных, которые нам нужны.

### Сохранения полученных значений в переменные

На текущее мгновение приложение может получить доступ к значениям, указанным в качестве переменных приказной строки. Теперь нам требуется сохранять значения этих двух значений в переменных, чтобы мы могли использовать их в остальных частях приложения. Мы сделаем это в приложении 12-2.

<span class="filename">Файл: src/main.rs</span>

```rust,should_panic,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-02/src/main.rs}}
```

<span class="caption">Приложение 12-2: Создание переменных для хранения значений, полученных при вызове исполняемого приложения</span>

Как видно из вывода вектора, имя приложения занимает первое значение в векторе по адресу `args[0]`, значит наши переданные значения начинаются с порядкового указателя `1`. Первая переменная `minigrep` - это строка, которую мы ищем, поэтому мы помещаем ссылку на `1` указатель `query`. Вторым значением является путь к файлу, поэтому мы помещаем ссылку на `2` указатель в `file_path`.

Для проверки соблюдения правил работы нашей приложения, значения переменных выводятся в окно вывода. Далее, запустим нашу программу со следующими значениями: `test` и `sample.txt`:

```console
{{#include ../listings/ch12-an-io-project/listing-12-02/output.txt}}
```

Отлично, приложение работает! Нам нужно чтобы переданные значения были сохранены в переменных соответствующих видов данных. Позже мы добавим обработку ошибок с наиболее распространенными случаями, например, когда пользователь не предоставляет переменные; сейчас мы пренебрегаем этим случаем и поработаем над добавлением возможности чтения файла.


[главе 13]: ch13-00-functional-features.html
[главе 7]: ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#creating-idiomatic-use-paths