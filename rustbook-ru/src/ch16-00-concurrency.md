# Многопоточность без страха

Безопасное и качественное управление многопоточным программированием — ещё одна из основных целей Ржавчины. Воплощение в Ржавчине *Многопоточного программирования* - это когда разные части приложения выполняются независимо друг от друга, *одновременное программирование* - это когда разные части приложения выполняются одновременно. Данные возможности становятся всё более важными, поскольку всё больше компьютеров используют преимущества выполнения нескольких этапов. Так сложилось, что программирование в этих условиях было сложным и подвержено ошибкам: Ржавчина надеется изменить это.

Первоначально объединение разработчиков Ржавчины считало, что обеспечение безопасности памяти и предотвращение неполадок многопоточности — это два отдельных сбоя, которые необходимо решать различными способами. Со временем объединение разработчиков обнаружило, что устройство владения и перечень видов данных являются мощным набором средств, помогающих управлять безопасностью памяти *и* устранять неполадки как многопоточности, так и одновременности! Используя устройство владения и проверку видов данных, многие ошибки многопоточности выявляются во время сборки в Ржавчине, а не во время выполнения. Поэтому вместо того, чтобы тратить много времени на попытки воспроизвести точные обстоятельства, при которых возникает ошибка многопоточности во время выполнения, решение будет другим . Неправильная рукопись будет выявлена во время сборки с указанием ошибок и не будет собрана. В итоге вы можете исправить свою рукопись во время работы над ней, а не после развёртывания на рабочем отдельном вычислителе. Мы назвали эту особенность Ржавчины *бесстрашной* *многопоточностью*. Бесстрашная многопоточность позволяет вам писать рукопись, которая не содержит скрытых ошибок и легко повторно согласуется без внесения новых ошибок.

> Примечание: для простоты понимания мы введём понятие - множественные сбои *многопоточности*, хотя более точное понятие здесь *&nbsp;— многопоточные и/или одновременные*. Если бы эта книга была о многопоточности и/или одновременности, мы бы посвятили данным понятиям исключительно всю книгу. В данной главе, всякий раз, когда мы используем понятие *«многопоточность»*, всегда стоит считать что это сокращение от понятия *«многопоточность и/или одновременность»*.

Многие языки программирования предлагают довольно устоявшиеся решения неполадок многопоточности. Например, Erlang обладает элегантной возможностью для многопоточности при передаче сообщений, но не определяет четких способов совместного использования состояний между потоками. Поддержка только подмножества возможных решений является разумным подходом для языков более высокого уровня, поскольку язык более высокого уровня обещает выгоду при отказе от некоторого управления над получением абстракций. Однако ожидается, что языки низкого уровня обеспечат решение с наилучшей производительностью в любом  случае и будут иметь меньше абстракций по сравнению с аппаратным обеспечением. Поэтому Ржавчина предлагает множество средств для выявления неполадок любым способом, который подходит для вашего случая и требований.

Вот сути, которые мы рассмотрим в этой главе:

- Как создать потоки для одновременного запуска нескольких отрывков рукописи
- Многопоточность *передачи сообщений*, где потоки передают сообщения между этапами
- Многопоточность для *совместно используемого состояния*, когда несколько потоков имеют доступ к некоторому отрывку данных
- Сущности `Sync` и `Send`, которые расширяют заверения многопоточности в Ржавчине для пользовательских видов данных, а также видов данных, предоставляемых встроенной библиотекой
