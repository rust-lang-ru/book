# Управление растущими проектами с помощью пакетов, крейтов и модулей

По мере написания больших программ организация кода будет важна, потому что отслеживание всей программы в голове становиться невозможным. С помощью группирования связанных функций и разделения кода с различными функционалом, вы делаете яснее, где искать код реализующий определенную функцию, что и где необходимо изменить в коде так, чтобы функционал изменился.

Программы, которые мы писали до сих пор, были в одном модуле в одном файле. По мере роста проекта, можно организовывать код, разделив его на несколько модулей и несколько файлов. Пакет может содержать несколько бинарных крейтов и опционально один крейт библиотеки. По мере роста пакета можно извлекать части в отдельные крейты, которые становятся внешними зависимостями. Эта глава охватывает все эти техники. Cargo предоставляет рабочие пространства для очень крупных проектов из набора взаимосвязанных пакетов развивающихся вместе, которые мы рассмотрим в [«Рабочие пространства Cargo»](ch14-03-cargo-workspaces.html)<comment> раздел в главе 14.</comment>

Дополнительно к группированию функциональности, инкапсуляция деталей реализации позволяет повторно использовать код на более высоком уровне: после реализации операции, другой код может вызывать этот код через открытый интерфейс, не зная как работает реализация. То, как вы пишете код, определяет какие части
общедоступны для использования другим кодом, а какие части  являются частными деталями реализации для которых вы оставляете за собой право на изменения. Это еще один способ ограничить количество деталей, которые вы должны держать в голове.

Связанное понятие - это область видимости: вложенный контекст в котором написан код и имеет набор имен, которые определены «в текущей области видимости». При чтении, письме и компиляции кода, программистам и компиляторам необходимо знать, относится ли конкретное имя в определенном месте к переменной, к функции, к структуре, к перечислению, к модулю, к константе или другому элементу и что означает этот элемент. Можно создавать области видимости и изменять какие имена входят или выходят за их рамки. Нельзя иметь два элемента с тем же именем в той же области; есть доступные инструменты для разрешения конфликтов имен.

Rust имеет ряд функций, которые позволяют управлять организацией кода, например какие детали открыты, какие детали являются частными и какие имена есть в каждой области программы. Эти особенности иногда вместе именуемые *модульной системой* включают в себя:

- **Пакеты:** (Packages) Функции Cargo позволяющие собирать, тестировать и делиться крейтами
- **Крейты:** (Crates) Дерево модулей, которые создают библиотечный или исполняемый файл
- **Модули** (Modules) и их использование с помощью **use:** Позволяет контролировать организацию, область видимости и конфиденциальность путей
- **Пути:** (Paths) способ именования элемента, такого как структура, функция или модуль

В этой главе мы рассмотрим все эти функции, обсудим как они взаимодействуют и объясним, как использовать их для управления областью видимости. К концу у вас должно быть солидное понимание модульной системы и умение работать с областями видимости как профессионал!
